
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>terraform-provider-infomaniak: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">/home/runner/work/terraform-provider-infomaniak/terraform-provider-infomaniak/main.go (90.0%)</option>
				
				<option value="file1">terraform-provider-infomaniak/internal/apis/client.go (50.0%)</option>
				
				<option value="file2">terraform-provider-infomaniak/internal/apis/dbaas/implementation/client.go (0.0%)</option>
				
				<option value="file3">terraform-provider-infomaniak/internal/apis/dbaas/models.go (0.0%)</option>
				
				<option value="file4">terraform-provider-infomaniak/internal/apis/domain/implementation/client.go (0.0%)</option>
				
				<option value="file5">terraform-provider-infomaniak/internal/apis/domain/models.go (0.0%)</option>
				
				<option value="file6">terraform-provider-infomaniak/internal/apis/helpers/types.go (0.0%)</option>
				
				<option value="file7">terraform-provider-infomaniak/internal/apis/helpers/user_agent.go (0.0%)</option>
				
				<option value="file8">terraform-provider-infomaniak/internal/apis/kaas/implementation/client.go (0.0%)</option>
				
				<option value="file9">terraform-provider-infomaniak/internal/apis/kaas/mock/cache.go (60.6%)</option>
				
				<option value="file10">terraform-provider-infomaniak/internal/apis/kaas/mock/client.go (46.4%)</option>
				
				<option value="file11">terraform-provider-infomaniak/internal/apis/kaas/mock/gen.go (81.8%)</option>
				
				<option value="file12">terraform-provider-infomaniak/internal/apis/kaas/models.go (15.4%)</option>
				
				<option value="file13">terraform-provider-infomaniak/internal/provider/provider.go (71.4%)</option>
				
				<option value="file14">terraform-provider-infomaniak/internal/provider/registry/registry.go (100.0%)</option>
				
				<option value="file15">terraform-provider-infomaniak/internal/provider/utils.go (62.5%)</option>
				
				<option value="file16">terraform-provider-infomaniak/internal/services/dbaas/dbaas_backup_resource.go (5.9%)</option>
				
				<option value="file17">terraform-provider-infomaniak/internal/services/dbaas/dbaas_data_source.go (13.0%)</option>
				
				<option value="file18">terraform-provider-infomaniak/internal/services/dbaas/dbaas_resource.go (3.1%)</option>
				
				<option value="file19">terraform-provider-infomaniak/internal/services/dbaas/dbaas_restore_resource.go (6.7%)</option>
				
				<option value="file20">terraform-provider-infomaniak/internal/services/dbaas/register.go (100.0%)</option>
				
				<option value="file21">terraform-provider-infomaniak/internal/services/dbaas/utils.go (0.0%)</option>
				
				<option value="file22">terraform-provider-infomaniak/internal/services/domain/record_raw_target_compute.go (0.0%)</option>
				
				<option value="file23">terraform-provider-infomaniak/internal/services/domain/record_resource.go (3.6%)</option>
				
				<option value="file24">terraform-provider-infomaniak/internal/services/domain/register.go (100.0%)</option>
				
				<option value="file25">terraform-provider-infomaniak/internal/services/domain/zone_resource.go (6.4%)</option>
				
				<option value="file26">terraform-provider-infomaniak/internal/services/kaas/kaas_data_source.go (9.1%)</option>
				
				<option value="file27">terraform-provider-infomaniak/internal/services/kaas/kaas_instance_pool_data_source.go (82.1%)</option>
				
				<option value="file28">terraform-provider-infomaniak/internal/services/kaas/kaas_instance_pool_resource.go (62.3%)</option>
				
				<option value="file29">terraform-provider-infomaniak/internal/services/kaas/kaas_resource.go (41.5%)</option>
				
				<option value="file30">terraform-provider-infomaniak/internal/services/kaas/register.go (100.0%)</option>
				
				<option value="file31">terraform-provider-infomaniak/internal/services/scopes/scopes.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "context"
        "flag"
        "log"
        "terraform-provider-infomaniak/internal/provider"
        "terraform-provider-infomaniak/internal/services/dbaas"
        "terraform-provider-infomaniak/internal/services/domain"
        "terraform-provider-infomaniak/internal/services/kaas"

        "github.com/hashicorp/terraform-plugin-framework/providerserver"
)

var (
        // these will be set by the goreleaser configuration
        // to appropriate values for the compiled binary.
        version string = "dev"

        // goreleaser can pass other information to the main package, such as the specific commit
        // https://goreleaser.com/cookbooks/using-main.version/
)

func main() <span class="cov10" title="295">{
        var debug bool

        flag.BoolVar(&amp;debug, "debug", false, "set to true to run the kaas with support for debuggers like delve")
        flag.Parse()

        opts := providerserver.ServeOpts{
                Address: "registry.terraform.io/Infomaniak/infomaniak",
                Debug:   debug,
        }

        // Register resources
        kaas.Register()
        domain.Register()
        dbaas.Register()

        err := providerserver.Serve(context.Background(), provider.New(version), opts)

        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err.Error())
        }</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package apis

import (
        "terraform-provider-infomaniak/internal/apis/dbaas"
        implem_dbaas "terraform-provider-infomaniak/internal/apis/dbaas/implementation"
        "terraform-provider-infomaniak/internal/apis/domain"
        "terraform-provider-infomaniak/internal/apis/kaas"

        implem_kaas "terraform-provider-infomaniak/internal/apis/kaas/implementation"
        mock_kaas "terraform-provider-infomaniak/internal/apis/kaas/mock"

        implem_domain "terraform-provider-infomaniak/internal/apis/domain/implementation"
)

type Client struct {
        Kaas   kaas.Api
        Domain domain.Api
        DBaas  dbaas.Api
}

// NewMockClient defines the mock client for Infomaniak's API,
// It is used for testing or dryrunning
func NewMockClient() *Client <span class="cov10" title="263">{
        return &amp;Client{
                Kaas: mock_kaas.New(),
        }
}</span>

// NewClient defines the client for Infomaniak's API
func NewClient(baseUri, token, version string) *Client <span class="cov0" title="0">{
        return &amp;Client{
                Kaas:   implem_kaas.New(baseUri, token, version),
                DBaas:  implem_dbaas.New(baseUri, token, version),
                Domain: implem_domain.New(baseUri, token, version),
        }
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package implementation

import (
        "fmt"
        "terraform-provider-infomaniak/internal/apis/dbaas"
        "terraform-provider-infomaniak/internal/apis/helpers"

        "resty.dev/v3"
)

// Ensure that our client implements Api
var (
        _ dbaas.Api = (*Client)(nil)
)

type Client struct {
        resty *resty.Client
}

func New(baseUri, token, version string) *Client <span class="cov0" title="0">{
        return &amp;Client{
                resty: resty.New().
                        SetBaseURL(baseUri).
                        SetAuthToken(token).
                        SetHeader("User-Agent", helpers.GetUserAgent(version)),
        }
}</span>

func (client *Client) FindPack(dbType string, name string) (*dbaas.DBaaSPack, error) <span class="cov0" title="0">{
        var result helpers.NormalizedApiResponse[[]*dbaas.DBaaSPack]

        resp, err := client.resty.R().
                SetResult(&amp;result).
                SetError(&amp;result).
                SetQueryParam("filter[type]", dbType).
                SetQueryParam("filter[names][]", name).
                Get(EndpointPacks)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if resp.IsError() </span><span class="cov0" title="0">{
                return nil, result.Error
        }</span>

        <span class="cov0" title="0">data := result.Data
        if len(data) != 1 || data[0].Name != name </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("pack not found")
        }</span>

        <span class="cov0" title="0">return data[0], nil</span>
}

func (client *Client) GetDBaaS(publicCloudId int, publicCloudProjectId int, dbaasId int) (*dbaas.DBaaS, error) <span class="cov0" title="0">{
        var result helpers.NormalizedApiResponse[*dbaas.DBaaS]

        resp, err := client.resty.R().
                SetPathParam("public_cloud_id", fmt.Sprint(publicCloudId)).
                SetPathParam("public_cloud_project_id", fmt.Sprint(publicCloudProjectId)).
                SetPathParam("dbaas_id", fmt.Sprint(dbaasId)).
                SetQueryParam("with", "packs,projects,tags").
                SetResult(&amp;result).
                SetError(&amp;result).
                Get(EndpointDatabase)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if resp.IsError() </span><span class="cov0" title="0">{
                return nil, result.Error
        }</span>

        <span class="cov0" title="0">return result.Data, nil</span>
}

func (client *Client) CreateDBaaS(input *dbaas.DBaaS) (int, error) <span class="cov0" title="0">{
        var result helpers.NormalizedApiResponse[int]

        resp, err := client.resty.R().
                SetPathParam("public_cloud_id", fmt.Sprint(input.Project.PublicCloudId)).
                SetPathParam("public_cloud_project_id", fmt.Sprint(input.Project.ProjectId)).
                SetBody(input).
                SetResult(&amp;result).
                SetError(&amp;result).
                Post(EndpointDatabases)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov0" title="0">if resp.IsError() </span><span class="cov0" title="0">{
                return 0, result.Error
        }</span>

        <span class="cov0" title="0">return result.Data, nil</span>
}

func (client *Client) UpdateDBaaS(input *dbaas.DBaaS) (bool, error) <span class="cov0" title="0">{
        var result helpers.NormalizedApiResponse[bool]

        resp, err := client.resty.R().
                SetPathParam("public_cloud_id", fmt.Sprint(input.Project.PublicCloudId)).
                SetPathParam("public_cloud_project_id", fmt.Sprint(input.Project.ProjectId)).
                SetPathParam("dbaas_id", fmt.Sprint(input.Id)).
                SetBody(input).
                SetResult(&amp;result).
                SetError(&amp;result).
                Patch(EndpointDatabase)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov0" title="0">if resp.IsError() </span><span class="cov0" title="0">{
                return false, result.Error
        }</span>

        <span class="cov0" title="0">return result.Data, nil</span>
}

func (client *Client) DeleteDBaaS(publicCloudId int, publicCloudProjectId int, dbaasId int) (bool, error) <span class="cov0" title="0">{
        var result helpers.NormalizedApiResponse[bool]

        resp, err := client.resty.R().
                SetPathParam("public_cloud_id", fmt.Sprint(publicCloudId)).
                SetPathParam("public_cloud_project_id", fmt.Sprint(publicCloudProjectId)).
                SetPathParam("dbaas_id", fmt.Sprint(dbaasId)).
                SetResult(&amp;result).
                SetError(&amp;result).
                Delete(EndpointDatabase)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov0" title="0">if resp.IsError() </span><span class="cov0" title="0">{
                return false, result.Error
        }</span>

        <span class="cov0" title="0">return result.Data, nil</span>
}

func (client *Client) GetPassword(publicCloudId int, publicCloudProjectId int, dbaasId int) (*dbaas.DBaaSConnectionInfo, error) <span class="cov0" title="0">{
        var result helpers.NormalizedApiResponse[*dbaas.DBaaSConnectionInfo]

        resp, err := client.resty.R().
                SetPathParam("public_cloud_id", fmt.Sprint(publicCloudId)).
                SetPathParam("public_cloud_project_id", fmt.Sprint(publicCloudProjectId)).
                SetPathParam("dbaas_id", fmt.Sprint(dbaasId)).
                SetResult(&amp;result).
                SetError(&amp;result).
                Get(EndpointDatabasePassword)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if resp.IsError() </span><span class="cov0" title="0">{
                return nil, result.Error
        }</span>

        <span class="cov0" title="0">return result.Data, nil</span>
}

func (client *Client) CreateBackup(publicCloudId int, publicCloudProjectId int, dbaasId int) (*dbaas.DBaaSBackup, error) <span class="cov0" title="0">{
        var result helpers.NormalizedApiResponse[*dbaas.DBaaSBackup]

        resp, err := client.resty.R().
                SetPathParam("public_cloud_id", fmt.Sprint(publicCloudId)).
                SetPathParam("public_cloud_project_id", fmt.Sprint(publicCloudProjectId)).
                SetPathParam("dbaas_id", fmt.Sprint(dbaasId)).
                SetResult(&amp;result).
                SetError(&amp;result).
                Post(EndpointDatabaseBackups)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if resp.IsError() </span><span class="cov0" title="0">{
                return nil, result.Error
        }</span>

        <span class="cov0" title="0">return result.Data, nil</span>
}

func (client *Client) GetBackup(publicCloudId int, publicCloudProjectId int, dbaasId int, backupId string) (*dbaas.DBaaSBackup, error) <span class="cov0" title="0">{
        var result helpers.NormalizedApiResponse[*dbaas.DBaaSBackup]

        resp, err := client.resty.R().
                SetPathParam("public_cloud_id", fmt.Sprint(publicCloudId)).
                SetPathParam("public_cloud_project_id", fmt.Sprint(publicCloudProjectId)).
                SetPathParam("dbaas_id", fmt.Sprint(dbaasId)).
                SetPathParam("backup_id", fmt.Sprint(backupId)).
                SetResult(&amp;result).
                SetError(&amp;result).
                Get(EndpointDatabaseBackup)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if resp.IsError() </span><span class="cov0" title="0">{
                return nil, result.Error
        }</span>

        <span class="cov0" title="0">return result.Data, nil</span>
}

func (client *Client) DeleteBackup(publicCloudId int, publicCloudProjectId int, dbaasId int, backupId string) (bool, error) <span class="cov0" title="0">{
        var result helpers.NormalizedApiResponse[bool]

        resp, err := client.resty.R().
                SetPathParam("public_cloud_id", fmt.Sprint(publicCloudId)).
                SetPathParam("public_cloud_project_id", fmt.Sprint(publicCloudProjectId)).
                SetPathParam("dbaas_id", fmt.Sprint(dbaasId)).
                SetPathParam("backup_id", fmt.Sprint(backupId)).
                SetResult(&amp;result).
                SetError(&amp;result).
                Delete(EndpointDatabaseBackup)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov0" title="0">if resp.IsError() </span><span class="cov0" title="0">{
                return false, result.Error
        }</span>

        <span class="cov0" title="0">return result.Data, nil</span>
}

func (client *Client) CreateRestore(publicCloudId int, publicCloudProjectId int, dbaasId int, backupId string) (*dbaas.DBaaSRestore, error) <span class="cov0" title="0">{
        var result helpers.NormalizedApiResponse[*dbaas.DBaaSRestore]

        resp, err := client.resty.R().
                SetPathParam("public_cloud_id", fmt.Sprint(publicCloudId)).
                SetPathParam("public_cloud_project_id", fmt.Sprint(publicCloudProjectId)).
                SetPathParam("dbaas_id", fmt.Sprint(dbaasId)).
                SetQueryParam("backup_id", backupId).
                SetResult(&amp;result).
                SetError(&amp;result).
                Post(EndpointDatabaseRestores)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if resp.IsError() </span><span class="cov0" title="0">{
                return nil, result.Error
        }</span>

        <span class="cov0" title="0">return result.Data, nil</span>
}

func (client *Client) GetRestore(publicCloudId int, publicCloudProjectId int, dbaasId int, restoreId string) (*dbaas.DBaaSRestore, error) <span class="cov0" title="0">{
        var result helpers.NormalizedApiResponse[*dbaas.DBaaSRestore]

        resp, err := client.resty.R().
                SetPathParam("public_cloud_id", fmt.Sprint(publicCloudId)).
                SetPathParam("public_cloud_project_id", fmt.Sprint(publicCloudProjectId)).
                SetPathParam("dbaas_id", fmt.Sprint(dbaasId)).
                SetPathParam("restore_id", fmt.Sprint(restoreId)).
                SetResult(&amp;result).
                SetError(&amp;result).
                Get(EndpointDatabaseRestore)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if resp.IsError() </span><span class="cov0" title="0">{
                return nil, result.Error
        }</span>

        <span class="cov0" title="0">return result.Data, nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package dbaas

import "fmt"

type DBaaSPack struct {
        Id   int    `json:"id,omitempty"`
        Name string `json:"name,omitempty"`
}

type DBaaS struct {
        Id      int          `json:"id,omitempty"`
        Project DBaaSProject `json:"project,omitzero"`
        PackId  int          `json:"pack_id,omitempty"`
        Pack    *DBaaSPack   `json:"pack,omitempty"`

        Type    string `json:"type,omitempty"`
        Version string `json:"version,omitempty"`
        Name    string `json:"name,omitempty"`
        Region  string `json:"region,omitempty"`
        Status  string `json:"status,omitempty"`
}

type DBaaSConnectionInfo struct {
        Host     string `json:"host"`
        Port     string `json:"port"`
        User     string `json:"user"`
        Password string `json:"password"`
        Ca       string `json:"ca"`
}

type DBaaSBackup struct {
        Id     string `json:"id,omitempty"`
        Status string `json:"status,omitempty"`
}

type DBaaSRestore struct {
        Id     string `json:"id,omitempty"`
        Status string `json:"status,omitempty"`
}

func (dbaas *DBaaS) Key() string <span class="cov0" title="0">{
        return fmt.Sprintf("%d-%d-%d", dbaas.Project.PublicCloudId, dbaas.Project.ProjectId, dbaas.Id)
}</span>

type DBaaSProject struct {
        PublicCloudId int `json:"public_cloud_id,omitempty"`
        ProjectId     int `json:"id,omitempty"`
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package implementation

import (
        "fmt"
        "strings"
        "terraform-provider-infomaniak/internal/apis/domain"
        "terraform-provider-infomaniak/internal/apis/helpers"

        "resty.dev/v3"
)

// Ensure that our client implements Api
var (
        _ domain.Api = (*Client)(nil)
)

type Client struct {
        resty *resty.Client
}

func New(baseUri, token, version string) *Client <span class="cov0" title="0">{
        return &amp;Client{
                resty: resty.New().
                        SetBaseURL(baseUri).
                        SetAuthToken(token).
                        SetHeader("User-Agent", helpers.GetUserAgent(version)),
        }
}</span>

func (client *Client) GetZone(fqdn string) (*domain.Zone, error) <span class="cov0" title="0">{
        var result helpers.NormalizedApiResponse[*domain.Zone]

        resp, err := client.resty.R().
                SetPathParam("fqdn", fmt.Sprint(fqdn)).
                SetQueryParam("with", "records,idn").
                SetResult(&amp;result).
                SetError(&amp;result).
                Get(EndpointZone)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if resp.IsError() </span><span class="cov0" title="0">{
                return nil, result.Error
        }</span>

        <span class="cov0" title="0">return result.Data, nil</span>
}

func (client *Client) CreateZone(fqdn string) (*domain.Zone, error) <span class="cov0" title="0">{
        var result helpers.NormalizedApiResponse[*domain.Zone]

        resp, err := client.resty.R().
                SetPathParam("fqdn", fmt.Sprint(fqdn)).
                SetQueryParam("with", "records,idn").
                SetResult(&amp;result).
                SetError(&amp;result).
                Post(EndpointZone)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if resp.IsError() </span><span class="cov0" title="0">{
                return nil, result.Error
        }</span>

        <span class="cov0" title="0">return result.Data, nil</span>
}

func (client *Client) DeleteZone(fqdn string) (bool, error) <span class="cov0" title="0">{
        var result helpers.NormalizedApiResponse[bool]

        resp, err := client.resty.R().
                SetPathParam("fqdn", fmt.Sprint(fqdn)).
                SetResult(&amp;result).
                SetError(&amp;result).
                Delete(EndpointZone)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov0" title="0">if resp.IsError() </span><span class="cov0" title="0">{
                return false, result.Error
        }</span>

        <span class="cov0" title="0">return result.Data, nil</span>
}

func (client *Client) GetRecord(zoneFqdn string, id int64) (*domain.Record, error) <span class="cov0" title="0">{
        var result helpers.NormalizedApiResponse[*domain.Record]

        resp, err := client.resty.R().
                SetPathParam("zone_fqdn", strings.TrimSuffix(zoneFqdn, ".")).
                SetPathParam("id", fmt.Sprint(id)).
                SetQueryParam("with", "idn,records_description").
                SetResult(&amp;result).
                SetError(&amp;result).
                Get(EndpointRecord)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if resp.IsError() </span><span class="cov0" title="0">{
                return nil, result.Error
        }</span>

        <span class="cov0" title="0">return result.Data, nil</span>
}

type CreateRecordRequest struct {
        Type   string `json:"type"`
        Source string `json:"source"`
        Target string `json:"target"`
        TTL    int64  `json:"ttl"`
}

func (client *Client) CreateRecord(zoneFqdn, recordType, source, target string, ttl int64) (*domain.Record, error) <span class="cov0" title="0">{
        var result helpers.NormalizedApiResponse[*domain.Record]

        var input = CreateRecordRequest{
                Type:   recordType,
                Source: source,
                Target: target,
                TTL:    ttl,
        }

        resp, err := client.resty.R().
                SetPathParam("zone_fqdn", strings.TrimSuffix(zoneFqdn, ".")).
                SetQueryParam("with", "idn,records_description").
                SetResult(&amp;result).
                SetBody(input).
                SetError(&amp;result).
                Post(EndpointRecords)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if resp.IsError() </span><span class="cov0" title="0">{
                return nil, result.Error
        }</span>

        <span class="cov0" title="0">return result.Data, nil</span>
}

func (client *Client) UpdateRecord(zoneFqdn string, id int64, recordType, source, target string, ttl int64) (*domain.Record, error) <span class="cov0" title="0">{
        var result helpers.NormalizedApiResponse[*domain.Record]

        var input = CreateRecordRequest{
                Type:   recordType,
                Source: source,
                Target: target,
                TTL:    ttl,
        }

        resp, err := client.resty.R().
                SetPathParam("zone_fqdn", strings.TrimSuffix(zoneFqdn, ".")).
                SetPathParam("id", fmt.Sprint(id)).
                SetQueryParam("with", "idn,records_description").
                SetResult(&amp;result).
                SetBody(input).
                SetError(&amp;result).
                Put(EndpointRecord)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if resp.IsError() </span><span class="cov0" title="0">{
                return nil, result.Error
        }</span>

        <span class="cov0" title="0">return result.Data, nil</span>
}

func (client *Client) DeleteRecord(zoneFqdn string, id int64) (bool, error) <span class="cov0" title="0">{
        var result helpers.NormalizedApiResponse[bool]

        resp, err := client.resty.R().
                SetPathParam("zone_fqdn", strings.TrimSuffix(zoneFqdn, ".")).
                SetPathParam("id", fmt.Sprint(id)).
                SetResult(&amp;result).
                SetError(&amp;result).
                Delete(EndpointRecord)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov0" title="0">if resp.IsError() </span><span class="cov0" title="0">{
                return false, result.Error
        }</span>

        <span class="cov0" title="0">return result.Data, nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package domain

import "slices"

type Zone struct {
        ID             int        `json:"id,omitempty"`
        FQDN           string     `json:"fqdn,omitempty"`
        DNSSEC         ZoneDNSSEC `json:"dnssec,omitempty"`
        Nameservers    []string   `json:"nameservers,omitempty"`
        Records        []Record   `json:"records,omitempty"`
        ClusterRecords []Record   `json:"cluster_records,omitempty"`
}

type ZoneDNSSEC struct {
        IsEnabled bool `json:"is_enabled,omitempty"`
}

type RecordType = string

var (
        RecordA      RecordType = "A"
        RecordAAAA   RecordType = "AAAA"
        RecordCAA    RecordType = "CAA"
        RecordCNAME  RecordType = "CNAME"
        RecordDNAME  RecordType = "DNAME"
        RecordDS     RecordType = "DS"
        RecordMX     RecordType = "MX"
        RecordNS     RecordType = "NS"
        RecordSMIMEA RecordType = "SMIMEA"
        RecordSRV    RecordType = "SRV"
        RecordSSHFP  RecordType = "SSHFP"
        RecordTLSA   RecordType = "TLSA"
        RecordTXT    RecordType = "TXT"
)

var RecordTypes = []RecordType{RecordA, RecordAAAA, RecordCAA, RecordCNAME, RecordDNAME, RecordNS, RecordDS, RecordMX, RecordSMIMEA, RecordSRV, RecordSSHFP, RecordTLSA, RecordTXT}

func IsValidRecordType(t RecordType) bool <span class="cov0" title="0">{
        return slices.Contains(RecordTypes, t)
}</span>

type Record struct {
        ID        int        `json:"id,omitempty"`
        Source    string     `json:"source,omitempty"`
        SourceIDN *string    `json:"source_idn,omitempty"`
        Type      RecordType `json:"type,omitempty"`
        TTL       int        `json:"ttl,omitempty"`
        Target    string     `json:"target,omitempty"`
        DynDNSID  int        `json:"dyndns_id,omitempty"`
        // Description string     `json:"description,omitempty"`
}

type (
        recordTypeA      struct{ string }
        recordTypeAAAA   struct{ string }
        recordTypeCAA    struct{ string }
        recordTypeCNAME  struct{ string }
        recordTypeDNAME  struct{ string }
        recordTypeDS     struct{ string }
        recordTypeMX     struct{ string }
        recordTypeNS     struct{ string }
        recordTypeSMIMEA struct{ string }
        recordTypeSRV    struct{ string }
        recordTypeSSHFP  struct{ string }
        recordTypeTLSA   struct{ string }
        recordTypeTXT    struct{ string }
)

var (
        RecordTypeA      = recordTypeA{"A"}
        RecordTypeAAAA   = recordTypeAAAA{"AAAA"}
        RecordTypeCAA    = recordTypeCAA{"CAA"}
        RecordTypeCNAME  = recordTypeCNAME{"CNAME"}
        RecordTypeDNAME  = recordTypeDNAME{"DNAME"}
        RecordTypeDS     = recordTypeDS{"DS"}
        RecordTypeMX     = recordTypeMX{"MX"}
        RecordTypeNS     = recordTypeNS{"NS"}
        RecordTypeSMIMEA = recordTypeSMIMEA{"SMIMEA"}
        RecordTypeSRV    = recordTypeSRV{"SRV"}
        RecordTypeSSHFP  = recordTypeSSHFP{"SSHFP"}
        RecordTypeTLSA   = recordTypeTLSA{"TLSA"}
        RecordTypeTXT    = recordTypeTXT{"TXT"}
)

type RecordConstraint interface {
        recordTypeA | recordTypeAAAA | recordTypeCAA | recordTypeCNAME | recordTypeDNAME | recordTypeDS | recordTypeMX | recordTypeSMIMEA | recordTypeSRV | recordTypeSSHFP | recordTypeTLSA | recordTypeTXT | recordTypeNS
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package helpers

import (
        "fmt"
        "strings"
)

type NormalizedApiResponse[K any] struct {
        Result string    `json:"result"`
        Data   K         `json:"data"`
        Error  *ApiError `json:"error"`
}

type ApiError struct {
        Description string          `json:"description"`
        Errors      []*ApiError     `json:"errors"`
        Context     ApiErrorContext `json:"context"`
}

type ApiErrorContext struct {
        Attribute string `json:"attribute"`
        Values    []any  `json:"values"`
}

func (apiError *ApiError) Error() string <span class="cov0" title="0">{
        var builder strings.Builder

        builder.WriteString(apiError.Description)

        if len(apiError.Context.Values) &gt; 0 </span><span class="cov0" title="0">{
                builder.WriteString(fmt.Sprintf(" (possible values: %v)", apiError.Context.Values))
        }</span>

        <span class="cov0" title="0">if len(apiError.Errors) &gt; 0 </span><span class="cov0" title="0">{
                builder.WriteString(":\n")
        }</span>

        <span class="cov0" title="0">for _, err := range apiError.Errors </span><span class="cov0" title="0">{
                tabulated := "  " + strings.ReplaceAll(err.Error(), "\n", "\n  ")
                builder.WriteString(tabulated + "\n")
        }</span>

        <span class="cov0" title="0">return strings.TrimSuffix(builder.String(), "\n")</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package helpers

import "fmt"

const (
        userAgentFormat = "terraform-provider-infomaniak/%s (resty; +https://github.com/Infomaniak/terraform-provider-infomaniak)"
)

func GetUserAgent(version string) string <span class="cov0" title="0">{
        return fmt.Sprintf(userAgentFormat, version)
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package implementation

import (
        "fmt"
        "terraform-provider-infomaniak/internal/apis/helpers"
        "terraform-provider-infomaniak/internal/apis/kaas"

        "resty.dev/v3"
)

// Ensure that our client implements Api
var (
        _ kaas.Api = (*Client)(nil)
)

type Client struct {
        resty *resty.Client
}

func New(baseUri, token, version string) *Client <span class="cov0" title="0">{
        return &amp;Client{
                resty: resty.New().
                        SetBaseURL(baseUri).
                        SetAuthToken(token).
                        SetHeader("User-Agent", helpers.GetUserAgent(version)),
        }
}</span>

func (client *Client) GetPacks() ([]*kaas.KaasPack, error) <span class="cov0" title="0">{
        var result helpers.NormalizedApiResponse[[]*kaas.KaasPack]

        resp, err := client.resty.R().
                SetResult(&amp;result).
                SetError(&amp;result).
                Get(EndpointPacks)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if resp.IsError() </span><span class="cov0" title="0">{
                return nil, result.Error
        }</span>

        <span class="cov0" title="0">return result.Data, nil</span>
}

func (client *Client) GetVersions() ([]string, error) <span class="cov0" title="0">{
        var result helpers.NormalizedApiResponse[[]string]

        resp, err := client.resty.R().
                SetResult(&amp;result).
                SetError(&amp;result).
                Get(EndpointVersions)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if resp.IsError() </span><span class="cov0" title="0">{
                return nil, result.Error
        }</span>

        <span class="cov0" title="0">return result.Data, nil</span>
}

func (client *Client) GetKaas(publicCloudId int, publicCloudProjectId int, kaasId int) (*kaas.Kaas, error) <span class="cov0" title="0">{
        var result helpers.NormalizedApiResponse[*kaas.Kaas]

        resp, err := client.resty.R().
                SetPathParam("public_cloud_id", fmt.Sprint(publicCloudId)).
                SetPathParam("public_cloud_project_id", fmt.Sprint(publicCloudProjectId)).
                SetPathParam("kaas_id", fmt.Sprint(kaasId)).
                SetQueryParam("with", "packs,projects,instances,tags").
                SetResult(&amp;result).
                SetError(&amp;result).
                Get(EndpointKaas)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if resp.IsError() </span><span class="cov0" title="0">{
                return nil, result.Error
        }</span>

        <span class="cov0" title="0">return result.Data, nil</span>
}

func (client *Client) GetKubeconfig(publicCloudId int, publicCloudProjectId int, kaasId int) (string, error) <span class="cov0" title="0">{
        var result helpers.NormalizedApiResponse[string]

        resp, err := client.resty.R().
                SetPathParam("public_cloud_id", fmt.Sprint(publicCloudId)).
                SetPathParam("public_cloud_project_id", fmt.Sprint(publicCloudProjectId)).
                SetPathParam("kaas_id", fmt.Sprint(kaasId)).
                SetResult(&amp;result).
                SetError(&amp;result).
                Get(EndpointKaasKubeconfig)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">if resp.IsError() </span><span class="cov0" title="0">{
                return "", result.Error
        }</span>

        <span class="cov0" title="0">return result.Data, nil</span>
}

func (client *Client) CreateKaas(input *kaas.Kaas) (int, error) <span class="cov0" title="0">{
        var result helpers.NormalizedApiResponse[int]

        resp, err := client.resty.R().
                SetPathParam("public_cloud_id", fmt.Sprint(input.Project.PublicCloudId)).
                SetPathParam("public_cloud_project_id", fmt.Sprint(input.Project.ProjectId)).
                SetBody(input).
                SetResult(&amp;result).
                SetError(&amp;result).
                Post(EndpointKaases)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov0" title="0">if resp.IsError() </span><span class="cov0" title="0">{
                return 0, result.Error
        }</span>

        <span class="cov0" title="0">return result.Data, nil</span>
}

func (client *Client) UpdateKaas(input *kaas.Kaas) (bool, error) <span class="cov0" title="0">{
        var result helpers.NormalizedApiResponse[bool]

        resp, err := client.resty.R().
                SetPathParam("public_cloud_id", fmt.Sprint(input.Project.PublicCloudId)).
                SetPathParam("public_cloud_project_id", fmt.Sprint(input.Project.ProjectId)).
                SetPathParam("kaas_id", fmt.Sprint(input.Id)).
                SetBody(input).
                SetResult(&amp;result).
                SetError(&amp;result).
                Patch(EndpointKaas)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov0" title="0">if resp.IsError() </span><span class="cov0" title="0">{
                return false, result.Error
        }</span>

        <span class="cov0" title="0">return result.Data, nil</span>
}

func (client *Client) DeleteKaas(publicCloudId int, publicCloudProjectId int, kaasId int) (bool, error) <span class="cov0" title="0">{
        var result helpers.NormalizedApiResponse[bool]

        resp, err := client.resty.R().
                SetPathParam("public_cloud_id", fmt.Sprint(publicCloudId)).
                SetPathParam("public_cloud_project_id", fmt.Sprint(publicCloudProjectId)).
                SetPathParam("kaas_id", fmt.Sprint(kaasId)).
                SetResult(&amp;result).
                SetError(&amp;result).
                Delete(EndpointKaas)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov0" title="0">if resp.IsError() </span><span class="cov0" title="0">{
                return false, result.Error
        }</span>

        <span class="cov0" title="0">return result.Data, nil</span>
}

func (client *Client) GetInstancePool(publicCloudId int, publicCloudProjectId int, kaasId int, instancePoolId int) (*kaas.InstancePool, error) <span class="cov0" title="0">{
        var result helpers.NormalizedApiResponse[*kaas.InstancePool]

        resp, err := client.resty.R().
                SetPathParam("public_cloud_id", fmt.Sprint(publicCloudId)).
                SetPathParam("public_cloud_project_id", fmt.Sprint(publicCloudProjectId)).
                SetPathParam("kaas_id", fmt.Sprint(kaasId)).
                SetPathParam("kaas_instance_pool_id", fmt.Sprint(instancePoolId)).
                SetResult(&amp;result).
                SetError(&amp;result).
                Get(EndpointInstancePool)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if resp.IsError() </span><span class="cov0" title="0">{
                return nil, result.Error
        }</span>

        // Default Max = Min
        <span class="cov0" title="0">if result.Data.MaxInstances == 0 </span><span class="cov0" title="0">{
                result.Data.MaxInstances = result.Data.MinInstances
        }</span>

        <span class="cov0" title="0">return result.Data, nil</span>
}

func (client *Client) CreateInstancePool(publicCloudId int, publicCloudProjectId int, input *kaas.InstancePool) (int, error) <span class="cov0" title="0">{
        var result helpers.NormalizedApiResponse[int]

        resp, err := client.resty.R().
                SetPathParam("public_cloud_id", fmt.Sprint(publicCloudId)).
                SetPathParam("public_cloud_project_id", fmt.Sprint(publicCloudProjectId)).
                SetPathParam("kaas_id", fmt.Sprint(input.KaasId)).
                SetBody(input).
                SetResult(&amp;result).
                SetError(&amp;result).
                Post(EndpointInstancePools)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov0" title="0">if resp.IsError() </span><span class="cov0" title="0">{
                return 0, result.Error
        }</span>

        <span class="cov0" title="0">return result.Data, nil</span>
}

func (client *Client) UpdateInstancePool(publicCloudId int, publicCloudProjectId int, input *kaas.InstancePool) (bool, error) <span class="cov0" title="0">{
        var result helpers.NormalizedApiResponse[bool]

        resp, err := client.resty.R().
                SetPathParam("public_cloud_id", fmt.Sprint(publicCloudId)).
                SetPathParam("public_cloud_project_id", fmt.Sprint(publicCloudProjectId)).
                SetPathParam("kaas_id", fmt.Sprint(input.KaasId)).
                SetPathParam("kaas_instance_pool_id", fmt.Sprint(input.Id)).
                SetBody(input).
                SetResult(&amp;result).
                SetError(&amp;result).
                Patch(EndpointInstancePool)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov0" title="0">if resp.IsError() </span><span class="cov0" title="0">{
                return false, result.Error
        }</span>

        <span class="cov0" title="0">return result.Data, nil</span>
}

func (client *Client) DeleteInstancePool(publicCloudId int, publicCloudProjectId int, kaasId int, instancePoolId int) (bool, error) <span class="cov0" title="0">{
        var result helpers.NormalizedApiResponse[bool]

        resp, err := client.resty.R().
                SetPathParam("public_cloud_id", fmt.Sprint(publicCloudId)).
                SetPathParam("public_cloud_project_id", fmt.Sprint(publicCloudProjectId)).
                SetPathParam("kaas_id", fmt.Sprint(kaasId)).
                SetPathParam("kaas_instance_pool_id", fmt.Sprint(instancePoolId)).
                SetResult(&amp;result).
                SetError(&amp;result).
                Delete(EndpointInstancePool)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov0" title="0">if resp.IsError() </span><span class="cov0" title="0">{
                return false, result.Error
        }</span>

        <span class="cov0" title="0">return result.Data, nil</span>
}

func (client *Client) PatchApiserverParams(input *kaas.Apiserver, publicCloudId int, projectId int, kaasId int) (bool, error) <span class="cov0" title="0">{
        var result helpers.NormalizedApiResponse[bool]
        resp, err := client.resty.R().
                SetPathParam("public_cloud_id", fmt.Sprint(publicCloudId)).
                SetPathParam("public_cloud_project_id", fmt.Sprint(projectId)).
                SetPathParam("kaas_id", fmt.Sprint(kaasId)).
                SetBody(input).
                SetResult(&amp;result).
                SetError(&amp;result).
                Patch(EndpointApiserver)

        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov0" title="0">if resp.IsError() </span><span class="cov0" title="0">{
                return false, result.Error
        }</span>

        <span class="cov0" title="0">return result.Data, nil</span>
}

func (client *Client) GetApiserverParams(publicCloudId int, projectId int, kaasId int) (*kaas.Apiserver, error) <span class="cov0" title="0">{

        var result helpers.NormalizedApiResponse[*kaas.Apiserver]
        resp, err := client.resty.R().
                SetPathParam("public_cloud_id", fmt.Sprint(publicCloudId)).
                SetPathParam("public_cloud_project_id", fmt.Sprint(projectId)).
                SetPathParam("kaas_id", fmt.Sprint(kaasId)).
                SetResult(&amp;result).
                SetError(&amp;result).
                Get(EndpointApiserver)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if resp.IsError() </span><span class="cov0" title="0">{
                return nil, result.Error
        }</span>

        <span class="cov0" title="0">return result.Data, nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package mock

import (
        "bytes"
        "encoding/gob"
        "encoding/json"
        "errors"
        "os"
        "path"
        "terraform-provider-infomaniak/internal/apis/kaas"
        "time"
)

type KaasObject interface {
        Key() string
        *kaas.Kaas | *kaas.InstancePool
}

var (
        mockedApiStatePath = path.Join(os.TempDir(), "terraform-provider-infomaniak-kaas")
        mockedApiState     = make(map[string][]byte)

        ErrKeyNotFound  = errors.New("key not found")
        ErrDuplicateKey = errors.New("duplicate key found")
)

func getFromCache[K KaasObject](key string) (K, error) <span class="cov8" title="86">{
        obj, found := mockedApiState[key]
        if !found </span><span class="cov1" title="1">{
                return nil, ErrKeyNotFound
        }</span>

        <span class="cov8" title="85">var buff = bytes.NewBuffer(obj)
        var result K
        err := gob.NewDecoder(buff).Decode(&amp;result)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="85">if result == nil </span><span class="cov0" title="0">{
                return nil, ErrKeyNotFound
        }</span>

        <span class="cov8" title="85">return result, nil</span>
}

func addToCache[K KaasObject](obj K) error <span class="cov5" title="18">{
        key := obj.Key()
        _, found := mockedApiState[key]
        if found </span><span class="cov0" title="0">{
                return ErrDuplicateKey
        }</span>

        <span class="cov5" title="18">var buff bytes.Buffer
        err := gob.NewEncoder(&amp;buff).Encode(obj)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov5" title="18">mockedApiState[key] = buff.Bytes()
        saveCache()
        return nil</span>
}

func updateCache[K KaasObject](obj K) error <span class="cov0" title="0">{
        key := obj.Key()
        cachedObject, found := mockedApiState[key]
        if !found </span><span class="cov0" title="0">{
                return ErrKeyNotFound
        }</span>

        <span class="cov0" title="0">var buff = bytes.NewBuffer(cachedObject)
        var result K
        err := gob.NewDecoder(buff).Decode(&amp;result)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">var newBuff bytes.Buffer
        err = gob.NewEncoder(&amp;newBuff).Encode(obj)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">mockedApiState[key] = newBuff.Bytes()
        saveCache()
        return nil</span>
}

func removeFromCache[K KaasObject](obj K) error <span class="cov5" title="18">{
        key := obj.Key()
        _, found := mockedApiState[key]
        if !found </span><span class="cov0" title="0">{
                return ErrKeyNotFound
        }</span>

        <span class="cov5" title="18">delete(mockedApiState, key)
        saveCache()
        return nil</span>
}

func init() <span class="cov10" title="295">{
        // Gob register
        gob.Register(&amp;kaas.Kaas{})
        gob.Register(&amp;kaas.InstancePool{})

        // Check cache age
        stat, err := os.Stat(mockedApiStatePath)
        if err == nil </span><span class="cov9" title="286">{
                // DeleteKaas cache if old
                if time.Since(stat.ModTime()) &gt; 24*time.Hour </span><span class="cov0" title="0">{
                        os.Remove(mockedApiStatePath)
                        return
                }</span>
        }

        // Try to get cache
        <span class="cov10" title="295">bdy, err := os.ReadFile(mockedApiStatePath)
        if err == nil </span><span class="cov9" title="286">{
                // Cache found
                err := json.Unmarshal(bdy, &amp;mockedApiState)
                if err != nil </span><span class="cov4" title="9">{
                        os.Remove(mockedApiStatePath)
                }</span>
                <span class="cov9" title="286">return</span>
        }

        // Create Kaas tmp file for caching
        <span class="cov4" title="9">_, err = os.Create(mockedApiStatePath)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
}

func saveCache() <span class="cov6" title="36">{
        data, err := json.Marshal(mockedApiState)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        //nolint:errcheck
        <span class="cov6" title="36">os.WriteFile(mockedApiStatePath, data, 0666)</span>
}

func ResetCache() <span class="cov0" title="0">{
        mockedApiState = make(map[string][]byte)
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package mock

import (
        "fmt"
        "log"
        "regexp"
        "terraform-provider-infomaniak/internal/apis/kaas"
)

// Ensure that our client implements Api
var (
        _               kaas.Api = (*Client)(nil)
        dnsRegexp                = regexp.MustCompile("^[a-z0-9]([-a-z0-9]*[a-z0-9])?$")
        kubeLabelRegexp          = regexp.MustCompile(`^[a-zA-Z0-9\-./]+:\s*[a-zA-Z0-9\-_.]{1,63}$`)
)

type Client struct{}

func New() *Client <span class="cov10" title="263">{
        return &amp;Client{}
}</span>

func (c *Client) GetPacks() ([]*kaas.KaasPack, error) <span class="cov6" title="24">{
        return []*kaas.KaasPack{
                {
                        Id:          1,
                        Name:        "standard",
                        Description: "Standard Cluster",
                },
                {
                        Id:          2,
                        Name:        "pro",
                        Description: "Pro Cluster",
                },
        }, nil
}</span>

func (c *Client) MustGetPackFromId(id int) *kaas.KaasPack <span class="cov5" title="12">{
        packs, _ := c.GetPacks()
        for _, pack := range packs </span><span class="cov5" title="12">{
                if pack.Id == id </span><span class="cov5" title="12">{
                        return pack
                }</span>
        }
        <span class="cov0" title="0">log.Fatalf("pack with id %d not found", id)
        return nil</span>
}

func (c *Client) GetVersions() ([]string, error) <span class="cov0" title="0">{
        return []string{"1.29", "1.30", "1.31"}, nil
}</span>

func (c *Client) GetKaas(publicCloudId int, publicCloudProjectId int, kaasId int) (*kaas.Kaas, error) <span class="cov7" title="66">{
        key := fmt.Sprintf("%d-%d-%d", publicCloudId, publicCloudProjectId, kaasId)
        obj, err := getFromCache[*kaas.Kaas](key)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov7" title="65">obj.Status = "Active"

        return obj, nil</span>
}

func (client *Client) GetKubeconfig(publicCloudId int, publicCloudProjectId int, kaasId int) (string, error) <span class="cov6" title="33">{
        return genKubeconfig(), nil
}</span>

func (c *Client) CreateKaas(input *kaas.Kaas) (int, error) <span class="cov5" title="12">{
        // Checks
        if input.Project.PublicCloudId == 0 </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("kaas is missing public cloud project id")
        }</span>
        <span class="cov5" title="12">if input.Region == "" </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("kaas is missing region")
        }</span>
        <span class="cov5" title="12">if input.PackId == 0 </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("kaas is missing pack id")
        }</span>

        <span class="cov5" title="12">var obj = kaas.Kaas{
                Project:           input.Project,
                Region:            input.Region,
                KubernetesVersion: input.KubernetesVersion,
                PackId:            input.PackId,
                Pack:              c.MustGetPackFromId(input.PackId),
                Name:              input.Name,
        }
        obj.Id = genId()

        return obj.Id, addToCache(&amp;obj)</span>
}

func (c *Client) UpdateKaas(input *kaas.Kaas) (bool, error) <span class="cov0" title="0">{
        // Checks
        if input.Project.PublicCloudId == 0 </span><span class="cov0" title="0">{
                return false, fmt.Errorf("kaas is missing public cloud project id")
        }</span>
        <span class="cov0" title="0">if input.Id == 0 </span><span class="cov0" title="0">{
                return false, fmt.Errorf("kaas is missing kaas id")
        }</span>
        <span class="cov0" title="0">if input.PackId == 0 </span><span class="cov0" title="0">{
                return false, fmt.Errorf("kaas is missing pack id")
        }</span>
        <span class="cov0" title="0">if input.Region != "" </span><span class="cov0" title="0">{
                return false, fmt.Errorf("client cannot update region")
        }</span>

        <span class="cov0" title="0">var obj = kaas.Kaas{
                Id:      input.Id,
                Project: input.Project,

                Name:              input.Name,
                Region:            input.Region,
                PackId:            input.PackId,
                Pack:              c.MustGetPackFromId(input.PackId),
                KubernetesVersion: input.KubernetesVersion,
        }

        return true, updateCache(&amp;obj)</span>
}

func (c *Client) DeleteKaas(publicCloudId int, publicCloudProjectId int, kaasId int) (bool, error) <span class="cov5" title="12">{
        var obj = kaas.Kaas{
                Project: kaas.KaasProject{
                        PublicCloudId: publicCloudId,
                        ProjectId:     publicCloudProjectId,
                },
                Id: kaasId,
        }

        return true, removeFromCache(&amp;obj)
}</span>

func (c *Client) GetInstancePool(publicCloudId int, publicCloudProjectId int, kaasId int, instancePoolId int) (*kaas.InstancePool, error) <span class="cov5" title="20">{
        _, err := c.GetKaas(publicCloudId, publicCloudProjectId, kaasId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov5" title="20">key := fmt.Sprintf("%d-%d", kaasId, instancePoolId)
        obj, err := getFromCache[*kaas.InstancePool](key)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov5" title="20">obj.Status = "Active"

        return obj, nil</span>
}

func (c *Client) CreateInstancePool(publicCloudId int, publicCloudProjectId int, input *kaas.InstancePool) (int, error) <span class="cov4" title="7">{
        // Checks
        if publicCloudId == 0 </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("instance pool is missing public cloud id")
        }</span>
        <span class="cov4" title="7">if publicCloudProjectId == 0 </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("instance pool is missing public cloud project id")
        }</span>
        <span class="cov4" title="7">if input.KaasId == 0 </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("instance pool is missing kaas id")
        }</span>
        <span class="cov4" title="7">if !dnsRegexp.MatchString(input.Name) </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("instance pool name should be a dns name according to RFC 1123")
        }</span>
        <span class="cov4" title="7">if input.FlavorName == "" </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("instance pool is missing flavor name")
        }</span>
        <span class="cov4" title="7">if input.MinInstances &lt; 0 </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("instance pool min instances should be greater than 0")
        }</span>
        // if input.MaxInstances &lt; 0 {
        //         return nil, fmt.Errorf("instance pool max instances should be greater than 0")
        // }
        // if input.MinInstances &gt; input.MaxInstances {
        //         return nil, fmt.Errorf("instance pool min instance should be lesser than (or equal) max")
        // }
        <span class="cov4" title="7">if len(input.Labels) &gt; 0 </span><span class="cov0" title="0">{
                for key, label := range input.Labels </span><span class="cov0" title="0">{
                        keyLabel := key + ": " + label
                        if !kubeLabelRegexp.MatchString(keyLabel) </span><span class="cov0" title="0">{
                                return 0, fmt.Errorf("instance pool label should be a kubernetes label")
                        }</span>
                }
        }

        <span class="cov4" title="7">_, err := c.GetKaas(publicCloudId, publicCloudProjectId, input.KaasId)
        if err != nil </span><span class="cov1" title="1">{
                return 0, err
        }</span>

        <span class="cov3" title="6">var obj = kaas.InstancePool{
                Id:     genId(),
                KaasId: input.KaasId,

                Name:               input.Name,
                FlavorName:         input.FlavorName,
                AvailabilityZone:   input.AvailabilityZone,
                MinInstances:       input.MinInstances,
                MaxInstances:       input.MaxInstances,
                TargetInstances:    input.MinInstances,
                AvailableInstances: input.MinInstances,
                Labels:             input.Labels,
        }

        return obj.Id, addToCache(&amp;obj)</span>
}

func (c *Client) UpdateInstancePool(publicCloudId int, publicCloudProjectId int, input *kaas.InstancePool) (bool, error) <span class="cov0" title="0">{
        // Checks
        if publicCloudId == 0 </span><span class="cov0" title="0">{
                return false, fmt.Errorf("instance pool is missing public cloud id")
        }</span>
        <span class="cov0" title="0">if publicCloudProjectId == 0 </span><span class="cov0" title="0">{
                return false, fmt.Errorf("instance pool is missing public cloud project id")
        }</span>
        <span class="cov0" title="0">if input.KaasId == 0 </span><span class="cov0" title="0">{
                return false, fmt.Errorf("instance pool is missing kaas id")
        }</span>
        <span class="cov0" title="0">if input.Id == 0 </span><span class="cov0" title="0">{
                return false, fmt.Errorf("instance pool is instance pool id")
        }</span>
        <span class="cov0" title="0">if !dnsRegexp.MatchString(input.Name) </span><span class="cov0" title="0">{
                return false, fmt.Errorf("instance pool name should be a dns name according to RFC 1123")
        }</span>
        <span class="cov0" title="0">if input.FlavorName == "" </span><span class="cov0" title="0">{
                return false, fmt.Errorf("instance pool is missing flavor name")
        }</span>
        <span class="cov0" title="0">if input.MinInstances &lt; 0 </span><span class="cov0" title="0">{
                return false, fmt.Errorf("instance pool min instances should be greater than 0")
        }</span>
        // if input.MaxInstances &lt; 0 {
        //         return nil, fmt.Errorf("instance pool max instances should be greater than 0")
        // }
        // if input.MinInstances &gt; input.MaxInstances {
        //         return nil, fmt.Errorf("instance pool min instance should be lesser than (or equal) max")
        // }

        <span class="cov0" title="0">_, err := c.GetKaas(publicCloudId, publicCloudProjectId, input.KaasId)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov0" title="0">_, err = c.GetInstancePool(publicCloudId, publicCloudProjectId, input.KaasId, input.Id)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov0" title="0">var obj = kaas.InstancePool{
                KaasId: input.KaasId,
                Id:     input.Id,

                Name:               input.Name,
                FlavorName:         input.FlavorName,
                AvailabilityZone:   input.AvailabilityZone,
                MinInstances:       input.MinInstances,
                MaxInstances:       input.MinInstances,
                TargetInstances:    input.MinInstances,
                AvailableInstances: input.MinInstances,
        }

        return true, updateCache(&amp;obj)</span>
}

func (c *Client) DeleteInstancePool(publicCloudId int, publicCloudProjectId int, kaasId int, instancePoolId int) (bool, error) <span class="cov3" title="6">{
        _, err := c.GetKaas(publicCloudId, publicCloudProjectId, kaasId)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov3" title="6">var obj = kaas.InstancePool{
                KaasId: kaasId,
                Id:     instancePoolId,
        }

        return true, removeFromCache(&amp;obj)</span>
}

func (c *Client) GetApiserverParams(publicCloudId int, projectId int, kaasId int) (*kaas.Apiserver, error) <span class="cov5" title="21">{
        return nil, nil
}</span>
func (c *Client) PatchApiserverParams(input *kaas.Apiserver, publicCloudId int, projectId int, kaasId int) (bool, error) <span class="cov0" title="0">{
        return true, nil
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package mock

import (
        "bytes"
        cryptorand "crypto/rand"
        "encoding/base64"
        "math/rand/v2"
)

func genId() int <span class="cov8" title="18">{
        return rand.Int()
}</span>

func genKubeconfig() string <span class="cov10" title="33">{
        var b = make([]byte, 1024)
        _, err := cryptorand.Read(b)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov10" title="33">var out bytes.Buffer
        enc := base64.NewEncoder(base64.StdEncoding, &amp;out)
        _, err = enc.Write(b)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov10" title="33">return out.String()</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package kaas

import (
        "encoding/json"
        "fmt"
        "maps"
)

type KaasPack struct {
        Id          int    `json:"kaas_pack_id,omitempty"`
        Name        string `json:"name,omitempty"`
        Description string `json:"description,omitempty"`
}

type Apiserver struct {
        Params                     *ApiServerParams  `json:"apiserver_params"`
        NonSpecificApiServerParams map[string]string `json:"-"`

        OidcCa          *string `json:"oidc_ca"`
        AuditLogWebhook *string `json:"audit-webhook-config"`
        AuditLogPolicy  *string `json:"audit-policy"`
}

var _ json.Marshaler = (*Apiserver)(nil)

// We can delete this once json v2 is out, so we can flatten everything without having to do this
func (a *Apiserver) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{
        paramBytes, err := json.Marshal(a.Params)
        if err != nil </span><span class="cov0" title="0">{
                paramBytes = []byte("{}")
        }</span>
        <span class="cov0" title="0">paramsMap := make(map[string]string)
        json.Unmarshal(paramBytes, &amp;paramsMap)
        nonSpecificMap := a.NonSpecificApiServerParams
        res := make(map[string]string)
        maps.Copy(res, paramsMap)
        maps.Copy(res, nonSpecificMap)
        result, err := json.Marshal(map[string]any{
                "apiserver_params":     res,
                "oidc_ca":              a.OidcCa,
                "audit-policy":         a.AuditLogPolicy,
                "audit-webhook-config": a.AuditLogWebhook,
        })
        return result, err</span>
}

type ApiServerParams struct {
        IssuerUrl      *string `json:"--oidc-issuer-url,omitempty"`
        ClientId       *string `json:"--oidc-client-id,omitempty"`
        UsernameClaim  *string `json:"--oidc-username-claim,omitempty"`
        UsernamePrefix *string `json:"--oidc-username-prefix,omitempty"`
        SigningAlgs    *string `json:"--oidc-signing-algs,omitempty"`
        GroupsClaim    *string `json:"--oidc-groups-claim,omitempty"`
        GroupsPrefix   *string `json:"--oidc-groups-prefix,omitempty"`
        RequiredClaim  *string `json:"--oidc-required-claim,omitempty"`
}

type Kaas struct {
        Name    string      `json:"name,omitempty"`
        Id      int         `json:"kaas_id,omitempty"`
        Project KaasProject `json:"project,omitzero"`
        PackId  int         `json:"kaas_pack_id,omitempty"`
        Pack    *KaasPack   `json:"pack,omitempty"`

        Region            string `json:"region,omitempty"`
        KubernetesVersion string `json:"kubernetes_version,omitempty"`
        Status            string `json:"status,omitempty"`
}

func (kaas *Kaas) Key() string <span class="cov10" title="24">{
        return fmt.Sprintf("%d-%d-%d", kaas.Project.PublicCloudId, kaas.Project.ProjectId, kaas.Id)
}</span>

type KaasProject struct {
        PublicCloudId int `json:"public_cloud_id,omitempty"`
        ProjectId     int `json:"id,omitempty"`
}

type InstancePool struct {
        KaasId int `json:"kaas_id,omitempty"`
        Id     int `json:"instance_pool_id,omitempty"`

        Name             string            `json:"name,omitempty"`
        FlavorName       string            `json:"flavor,omitempty"`
        AvailabilityZone string            `json:"availability_zone,omitempty"`
        MinInstances     int32             `json:"minimum_instances,omitempty"`
        MaxInstances     int32             `json:"maximum_instances,omitempty"`
        Status           string            `json:"status,omitempty"`
        Labels           map[string]string `json:"labels,omitempty"`

        TargetInstances    int32 `json:"target_instances,omitempty"`
        AvailableInstances int32 `json:"available_instances,omitempty"`

        ErrorMessages []string `json:"error_messages,omitempty"`
}

func (instancePool *InstancePool) Key() string <span class="cov8" title="12">{
        return fmt.Sprintf("%d-%d", instancePool.KaasId, instancePool.Id)
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">package provider

import (
        "context"
        "os"
        "terraform-provider-infomaniak/internal/provider/registry"

        "github.com/hashicorp/terraform-plugin-framework/datasource"
        "github.com/hashicorp/terraform-plugin-framework/function"
        "github.com/hashicorp/terraform-plugin-framework/path"
        "github.com/hashicorp/terraform-plugin-framework/provider"
        "github.com/hashicorp/terraform-plugin-framework/provider/schema"
        "github.com/hashicorp/terraform-plugin-framework/providerserver"
        "github.com/hashicorp/terraform-plugin-framework/resource"
        "github.com/hashicorp/terraform-plugin-framework/types"
        "github.com/hashicorp/terraform-plugin-go/tfprotov6"
        "github.com/hashicorp/terraform-plugin-log/tflog"
)

// Environment variables used by the provider
const (
        INFOMANIAK_TOKEN = "INFOMANIAK_TOKEN"
        INFOMANIAK_HOST  = "INFOMANIAK_HOST"
)

// Ensure IkProvider satisfies various kaas interfaces.
var (
        _ provider.Provider              = &amp;IkProvider{}
        _ provider.ProviderWithFunctions = &amp;IkProvider{}

        DefaultHost = "https://api.infomaniak.com"
)

// IkProvider defines the kaas implementation.
type IkProvider struct {
        // version is set to the kaas version on release, "dev" when the
        // kaas is built and ran locally, and "test" when running acceptance
        // testing.
        version string

        ik *IkProviderData
}

// IkProviderData defines the data associated with the provider
type IkProviderData struct {
        Version types.String `tfsdk:"version"`
        Data    *IkProviderModel
}

type IkProviderModel struct {
        Host  types.String `tfsdk:"host"`
        Token types.String `tfsdk:"token"`
}

func (p *IkProvider) Metadata(ctx context.Context, req provider.MetadataRequest, resp *provider.MetadataResponse) <span class="cov9" title="290">{
        resp.TypeName = "infomaniak"
        resp.Version = p.version
}</span>

func (p *IkProvider) Schema(ctx context.Context, req provider.SchemaRequest, resp *provider.SchemaResponse) <span class="cov10" title="295">{
        resp.Schema = schema.Schema{
                Attributes: map[string]schema.Attribute{
                        "host": schema.StringAttribute{
                                Optional:            true,
                                Description:         "The base endpoint for Infomaniak's API (including scheme).",
                                MarkdownDescription: "The base endpoint for Infomaniak's API (including scheme).",
                        },
                        "token": schema.StringAttribute{
                                Required:            os.Getenv(INFOMANIAK_TOKEN) == "",
                                Optional:            os.Getenv(INFOMANIAK_TOKEN) != "",
                                Sensitive:           true,
                                Description:         "The token used for authenticating against Infomaniak's API.",
                                MarkdownDescription: "The token used for authenticating against Infomaniak's API.",
                        },
                },
                Description:         "Infomaniak's provider.",
                MarkdownDescription: "Infomaniak's provider.",
        }
}</span>

func (p *IkProvider) Configure(ctx context.Context, req provider.ConfigureRequest, resp *provider.ConfigureResponse) <span class="cov7" title="78">{
        tflog.Debug(ctx, "Provider configuration started")

        if p.ik != nil </span><span class="cov0" title="0">{
                tflog.Debug(ctx, "Provider already present, skipping configuration")
                resp.DataSourceData = p.ik
                resp.ResourceData = p.ik
                return
        }</span>

        <span class="cov7" title="78">var data IkProviderModel

        resp.Diagnostics.Append(req.Config.Get(ctx, &amp;data)...)

        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov7" title="78">if data.Host.IsUnknown() </span><span class="cov0" title="0">{
                resp.Diagnostics.AddAttributeError(
                        path.Root("host"),
                        "Unknown Infomaniak API Host",
                        "The provider cannot create the Infomaniak API client as there is an unknown configuration value for the Infomaniak API host. "+
                                "Either target apply the source of the value first, set the value statically in the configuration, or use the INFOMANIAK_HOST environment variable.",
                )
        }</span>

        <span class="cov7" title="78">if data.Token.IsUnknown() </span><span class="cov0" title="0">{
                resp.Diagnostics.AddAttributeError(
                        path.Root("token"),
                        "Unknown Infomaniak API Token",
                        "The provider cannot create the Infomaniak API client as there is an unknown configuration value for the Infomaniak API username. "+
                                "Either target apply the source of the value first, set the value statically in the configuration, or use the INFOMANIAK_TOKEN environment variable.",
                )
        }</span>

        <span class="cov7" title="78">if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov7" title="78">host := os.Getenv(INFOMANIAK_HOST)
        token := os.Getenv(INFOMANIAK_TOKEN)

        if host == "" </span><span class="cov7" title="78">{
                if !data.Host.IsNull() </span><span class="cov0" title="0">{
                        host = data.Host.ValueString()
                }</span> else<span class="cov7" title="78"> {
                        host = DefaultHost
                }</span>
        }

        <span class="cov7" title="78">if token == "" &amp;&amp; !data.Token.IsNull() </span><span class="cov7" title="78">{
                token = data.Token.ValueString()
        }</span>

        <span class="cov7" title="78">data.Host = types.StringValue(host)
        data.Token = types.StringValue(token)

        if token == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddAttributeError(
                        path.Root("username"),
                        "Missing Infomaniak API Username",
                        "The provider cannot create the Infomaniak API client as there is a missing or empty value for the Infomaniak API username. "+
                                "Set the username value in the configuration or use the INFOMANIAK_TOKEN environment variable. "+
                                "If either is already set, ensure the value is not empty.",
                )
        }</span>

        <span class="cov7" title="78">if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov7" title="78">p.ik = &amp;IkProviderData{
                Version: types.StringValue(p.version),
                Data:    &amp;data,
        }

        resp.DataSourceData = p.ik
        resp.ResourceData = p.ik</span>
}

func (p *IkProvider) Resources(ctx context.Context) []func() resource.Resource <span class="cov9" title="290">{
        return registry.GetResources()
}</span>

func (p *IkProvider) DataSources(ctx context.Context) []func() datasource.DataSource <span class="cov9" title="158">{
        return registry.GetDataSources()
}</span>

func (p *IkProvider) Functions(ctx context.Context) []func() function.Function <span class="cov8" title="147">{
        return nil
}</span>

func New(version string) func() provider.Provider <span class="cov10" title="295">{
        return func() provider.Provider </span><span class="cov10" title="295">{
                return &amp;IkProvider{
                        version: version,
                }
        }</span>
}

func ProtoV6ProviderFactories() map[string]func() (tfprotov6.ProviderServer, error) <span class="cov0" title="0">{
        return map[string]func() (tfprotov6.ProviderServer, error){
                "infomaniak": providerserver.NewProtocol6WithError(New("test")()),
        }
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">package registry

import (
        "github.com/hashicorp/terraform-plugin-framework/datasource"
        "github.com/hashicorp/terraform-plugin-framework/resource"
)

var resources []func() resource.Resource
var datasources []func() datasource.DataSource

func RegisterResource(F func() resource.Resource) <span class="cov10" title="2065">{
        resources = append(resources, F)
}</span>

func RegisterDataSource(F func() datasource.DataSource) <span class="cov9" title="885">{
        datasources = append(datasources, F)
}</span>

func GetResources() []func() resource.Resource <span class="cov7" title="290">{
        return resources
}</span>

func GetDataSources() []func() datasource.DataSource <span class="cov6" title="158">{
        return datasources
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">package provider

import (
        "fmt"
        "os"
        "terraform-provider-infomaniak/internal/apis"
)

func GetApiClient(providerData any) (*apis.Client, error) <span class="cov10" title="263">{
        data, ok := providerData.(*IkProviderData)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("expected *provider.IkProviderData, got: %T", providerData)
        }</span>

        <span class="cov10" title="263">mocked := os.Getenv("TF_TESTS_MOCKED")
        if data.Version.ValueString() == "dev" &amp;&amp; mocked == "true" </span><span class="cov10" title="263">{
                return apis.NewMockClient(), nil
        }</span>

        <span class="cov0" title="0">client := apis.NewClient(data.Data.Host.ValueString(), data.Data.Token.ValueString(), data.Version.ValueString())

        return client, nil</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package dbaas

import (
        "context"
        "maps"
        "terraform-provider-infomaniak/internal/apis"
        "terraform-provider-infomaniak/internal/apis/dbaas"
        "terraform-provider-infomaniak/internal/provider"
        "terraform-provider-infomaniak/internal/services/scopes"
        "time"

        "github.com/hashicorp/terraform-plugin-framework/path"
        "github.com/hashicorp/terraform-plugin-framework/resource"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
        "github.com/hashicorp/terraform-plugin-framework/types"
)

var (
        _ resource.Resource                = &amp;dbaasBackupResource{}
        _ resource.ResourceWithConfigure   = &amp;dbaasBackupResource{}
        _ resource.ResourceWithImportState = &amp;dbaasBackupResource{}
)

func NewDBaasBackupResource() resource.Resource <span class="cov10" title="502">{
        return &amp;dbaasBackupResource{}
}</span>

type dbaasBackupResource struct {
        client *apis.Client
}

type DBaasBackupModel struct {
        PublicCloudId        types.Int64  `tfsdk:"public_cloud_id"`
        PublicCloudProjectId types.Int64  `tfsdk:"public_cloud_project_id"`
        DBaasId              types.Int64  `tfsdk:"dbaas_id"`
        Id                   types.String `tfsdk:"id"`
}

func (r *dbaasBackupResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) <span class="cov9" title="355">{
        resp.TypeName = req.ProviderTypeName + "_dbaas_backup"
}</span>

// Configure adds the provider configured client to the data source.
func (r *dbaasBackupResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) <span class="cov0" title="0">{
        // Add a nil check when handling ProviderData because Terraform
        // sets that data after it calls the ConfigureProvider RPC.
        if req.ProviderData == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">client, err := provider.GetApiClient(req.ProviderData)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unexpected Resource Configure Type",
                        err.Error(),
                )
                return
        }</span>

        <span class="cov0" title="0">r.client = client</span>
}

func (r *dbaasBackupResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) <span class="cov8" title="147">{
        resp.Schema = schema.Schema{
                Attributes: map[string]schema.Attribute{
                        "id": schema.StringAttribute{
                                Computed:            true,
                                MarkdownDescription: "A computed value representing the unique identifier for the architecture. Mandatory for acceptance testing.",
                                PlanModifiers: []planmodifier.String{
                                        stringplanmodifier.UseStateForUnknown(),
                                },
                        },
                },
                MarkdownDescription: "The dbaas backup resource allows the user to manage a backup for a certain dbaas",
        }

        maps.Copy(resp.Schema.Attributes, scopes.DBaaS.Build())
}</span>

func (r *dbaasBackupResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) <span class="cov0" title="0">{
        var data DBaasBackupModel

        // Read Terraform plan data into the model
        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)

        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // CreateBackup API call logic
        <span class="cov0" title="0">backup, err := r.client.DBaas.CreateBackup(
                int(data.PublicCloudId.ValueInt64()),
                int(data.PublicCloudProjectId.ValueInt64()),
                int(data.DBaasId.ValueInt64()),
        )
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error when creating Backup",
                        err.Error(),
                )
                return
        }</span>

        <span class="cov0" title="0">data.Id = types.StringValue(backup.Id)
        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)

        backup, err = r.waitUntilActive(ctx,
                int(data.PublicCloudId.ValueInt64()),
                int(data.PublicCloudProjectId.ValueInt64()),
                int(data.DBaasId.ValueInt64()),
                backup.Id,
        )
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error when waiting for Backup to be finished",
                        err.Error(),
                )
                return
        }</span>

        <span class="cov0" title="0">if backup == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">data.fill(backup)

        // Save data into Terraform state
        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *dbaasBackupResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) <span class="cov0" title="0">{
        var state DBaasBackupModel

        // Read Terraform plan data into the model
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;state)...)

        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // Read API call logic
        <span class="cov0" title="0">backup, err := r.client.DBaas.GetBackup(
                int(state.PublicCloudId.ValueInt64()),
                int(state.PublicCloudProjectId.ValueInt64()),
                int(state.DBaasId.ValueInt64()),
                state.Id.ValueString(),
        )
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error when reading Backup",
                        err.Error(),
                )
                return
        }</span>

        <span class="cov0" title="0">state.fill(backup)

        // Save updated data into Terraform state
        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;state)...)</span>
}

func (r *dbaasBackupResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) <span class="cov0" title="0">{
        resp.Diagnostics.AddError(
                "Cannot update",
                "This resource cannot be updated.",
        )
}</span>

func (r *dbaasBackupResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) <span class="cov0" title="0">{
        var data DBaasBackupModel

        // Read Terraform prior state data into the model
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;data)...)

        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // DeleteBackup API call logic
        <span class="cov0" title="0">_, err := r.client.DBaas.DeleteBackup(
                int(data.PublicCloudId.ValueInt64()),
                int(data.PublicCloudProjectId.ValueInt64()),
                int(data.DBaasId.ValueInt64()),
                data.Id.ValueString(),
        )
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error when deleting Backup",
                        err.Error(),
                )
                return
        }</span>
}

func (r *dbaasBackupResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) <span class="cov0" title="0">{
        imports, err := parseBackupRestoreImport(req)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unexpected Import Identifier",
                        err.Error(),
                )
                return
        }</span>

        <span class="cov0" title="0">resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("public_cloud_id"), imports.PublicCloudId)...)
        resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("public_cloud_project_id"), imports.PublicCloudProjectId)...)
        resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("dbaas_id"), imports.DbaasId)...)
        resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("id"), imports.Id)...)</span>
}

func (r *dbaasBackupResource) waitUntilActive(ctx context.Context, publicCloudId int, publicCloudProjectId int, dbaasId int, id string) (*dbaas.DBaaSBackup, error) <span class="cov0" title="0">{
        t := time.NewTicker(5 * time.Second)
        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return nil, nil</span>
                case &lt;-t.C:<span class="cov0" title="0">
                        found, err := r.client.DBaas.GetBackup(publicCloudId, publicCloudProjectId, dbaasId, id)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>

                        <span class="cov0" title="0">if ctx.Err() != nil </span><span class="cov0" title="0">{
                                return nil, nil
                        }</span>

                        <span class="cov0" title="0">if found.Status != "Unknown" </span><span class="cov0" title="0">{
                                return found, nil
                        }</span>
                }
        }
}

func (model *DBaasBackupModel) fill(backup *dbaas.DBaaSBackup) <span class="cov0" title="0">{
        model.Id = types.StringValue(backup.Id)
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">package dbaas

import (
        "context"
        "terraform-provider-infomaniak/internal/apis"
        "terraform-provider-infomaniak/internal/provider"

        "github.com/hashicorp/terraform-plugin-framework/datasource"
        "github.com/hashicorp/terraform-plugin-framework/datasource/schema"
        "github.com/hashicorp/terraform-plugin-framework/types"
)

// Ensure the implementation satisfies the expected interfaces.
var (
        _ datasource.DataSource              = &amp;dbaasDataSource{}
        _ datasource.DataSourceWithConfigure = &amp;dbaasDataSource{}
)

type dbaasDataSource struct {
        client *apis.Client
}

// NewDBaasDataSource is a helper function to simplify the provider implementation.
func NewDBaasDataSource() datasource.DataSource <span class="cov10" title="305">{
        return &amp;dbaasDataSource{}
}</span>

// Configure adds the provider configured client to the data source.
func (d *dbaasDataSource) Configure(_ context.Context, req datasource.ConfigureRequest, resp *datasource.ConfigureResponse) <span class="cov0" title="0">{
        // Add a nil check when handling ProviderData because Terraform
        // sets that data after it calls the ConfigureProvider RPC.
        if req.ProviderData == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">client, err := provider.GetApiClient(req.ProviderData)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unexpected Data Source Configure Type",
                        err.Error(),
                )
                return
        }</span>

        <span class="cov0" title="0">d.client = client</span>
}

// Schema defines the schema for the data source.
func (d *dbaasDataSource) Schema(ctx context.Context, _ datasource.SchemaRequest, resp *datasource.SchemaResponse) <span class="cov8" title="147">{
        resp.Schema = schema.Schema{
                Attributes: map[string]schema.Attribute{
                        "public_cloud_id": schema.Int64Attribute{
                                Required:            true,
                                MarkdownDescription: "The id of the public cloud where DBaaS is installed",
                        },
                        "public_cloud_project_id": schema.Int64Attribute{
                                Required:            true,
                                MarkdownDescription: "The id of the public cloud project where DBaaS is installed",
                        },
                        "id": schema.Int64Attribute{
                                Required:            true,
                                MarkdownDescription: "The id of this DBaaS",
                        },
                        "name": schema.StringAttribute{
                                Computed:            true,
                                MarkdownDescription: "The name of the DBaaS project",
                        },
                        "pack_name": schema.StringAttribute{
                                Computed:            true,
                                MarkdownDescription: "The name of the pack associated to the DBaaS project",
                        },
                        "region": schema.StringAttribute{
                                Computed:            true,
                                MarkdownDescription: "The region where the DBaaS project resides in.",
                        },
                        "type": schema.StringAttribute{
                                Computed:            true,
                                MarkdownDescription: "The type of the database associated with the DBaaS project",
                        },
                        "version": schema.StringAttribute{
                                Computed:            true,
                                MarkdownDescription: "The version of the database associated with the DBaaS project",
                        },
                },
                MarkdownDescription: "The dbaas data source allows the user to manage a dbaas project",
        }
}</span>

// Read refreshes the Terraform state with the latest data.
func (d *dbaasDataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) <span class="cov0" title="0">{
        var data DBaasModel

        resp.Diagnostics.Append(req.Config.Get(ctx, &amp;data)...)

        obj, err := d.client.DBaas.GetDBaaS(
                int(data.PublicCloudId.ValueInt64()),
                int(data.PublicCloudProjectId.ValueInt64()),
                int(data.Id.ValueInt64()),
        )
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unable to find DBaaS",
                        err.Error(),
                )
                return
        }</span>

        <span class="cov0" title="0">data.Region = types.StringValue(obj.Region)
        data.Version = types.StringValue(obj.Version)
        data.Type = types.StringValue(obj.Type)

        // Set state
        diags := resp.State.Set(ctx, &amp;data)
        resp.Diagnostics.Append(diags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>
}

// Metadata returns the data source type name.
func (d *dbaasDataSource) Metadata(_ context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) <span class="cov8" title="158">{
        resp.TypeName = req.ProviderTypeName + "_dbaas"
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">package dbaas

import (
        "context"
        "errors"
        "fmt"
        "maps"
        "strconv"
        "strings"
        "terraform-provider-infomaniak/internal/apis"
        "terraform-provider-infomaniak/internal/apis/dbaas"
        "terraform-provider-infomaniak/internal/provider"
        "terraform-provider-infomaniak/internal/services/scopes"
        "time"

        "github.com/hashicorp/terraform-plugin-framework/diag"
        "github.com/hashicorp/terraform-plugin-framework/path"
        "github.com/hashicorp/terraform-plugin-framework/resource"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/int64planmodifier"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
        "github.com/hashicorp/terraform-plugin-framework/types"
)

var (
        _ resource.Resource                = &amp;dbaasResource{}
        _ resource.ResourceWithConfigure   = &amp;dbaasResource{}
        _ resource.ResourceWithImportState = &amp;dbaasResource{}
)

func NewDBaasResource() resource.Resource <span class="cov10" title="502">{
        return &amp;dbaasResource{}
}</span>

type dbaasResource struct {
        client *apis.Client
}

type DBaasModel struct {
        PublicCloudId        types.Int64 `tfsdk:"public_cloud_id"`
        PublicCloudProjectId types.Int64 `tfsdk:"public_cloud_project_id"`
        Id                   types.Int64 `tfsdk:"id"`

        Name     types.String `tfsdk:"name"`
        PackName types.String `tfsdk:"pack_name"`
        Region   types.String `tfsdk:"region"`
        Type     types.String `tfsdk:"type"`
        Version  types.String `tfsdk:"version"`

        Host     types.String `tfsdk:"host"`
        Port     types.String `tfsdk:"port"`
        User     types.String `tfsdk:"user"`
        Password types.String `tfsdk:"password"`
        Ca       types.String `tfsdk:"ca"`
}

func (r *dbaasResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) <span class="cov9" title="355">{
        resp.TypeName = req.ProviderTypeName + "_dbaas"
}</span>

// Configure adds the provider configured client to the data source.
func (r *dbaasResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) <span class="cov0" title="0">{
        // Add a nil check when handling ProviderData because Terraform
        // sets that data after it calls the ConfigureProvider RPC.
        if req.ProviderData == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">client, err := provider.GetApiClient(req.ProviderData)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unexpected Resource Configure Type",
                        err.Error(),
                )
                return
        }</span>

        <span class="cov0" title="0">r.client = client</span>
}

func (r *dbaasResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) <span class="cov8" title="147">{
        resp.Schema = schema.Schema{
                Attributes: map[string]schema.Attribute{
                        "pack_name": schema.StringAttribute{
                                Required:            true,
                                MarkdownDescription: "The name of the pack associated to the DBaaS project",
                                PlanModifiers: []planmodifier.String{
                                        stringplanmodifier.RequiresReplace(),
                                },
                        },
                        "type": schema.StringAttribute{
                                Required:            true,
                                MarkdownDescription: "The type of database associated with the DBaaS being installed",
                                PlanModifiers: []planmodifier.String{
                                        stringplanmodifier.RequiresReplace(),
                                },
                        },
                        "version": schema.StringAttribute{
                                Required:            true,
                                MarkdownDescription: "The version of database associated with the DBaaS being installed",
                                PlanModifiers: []planmodifier.String{
                                        stringplanmodifier.RequiresReplace(),
                                },
                        },
                        "name": schema.StringAttribute{
                                Required:            true,
                                MarkdownDescription: "The name of the DBaaS project",
                                PlanModifiers: []planmodifier.String{
                                        stringplanmodifier.UseStateForUnknown(),
                                },
                        },
                        "id": schema.Int64Attribute{
                                Computed:            true,
                                MarkdownDescription: "A computed value representing the unique identifier for the architecture. Mandatory for acceptance testing.",
                                PlanModifiers: []planmodifier.Int64{
                                        int64planmodifier.UseStateForUnknown(),
                                },
                        },
                        "region": schema.StringAttribute{
                                Required:            true,
                                MarkdownDescription: "The region where the DBaaS will reside.",
                                PlanModifiers: []planmodifier.String{
                                        stringplanmodifier.RequiresReplace(),
                                        stringplanmodifier.UseStateForUnknown(),
                                },
                        },
                        "host": schema.StringAttribute{
                                Computed:            true,
                                MarkdownDescription: "The host to access this database.",
                        },
                        "port": schema.StringAttribute{
                                Computed:            true,
                                MarkdownDescription: "The port to access this database.",
                        },
                        "user": schema.StringAttribute{
                                Computed:            true,
                                MarkdownDescription: "The username to access this database.",
                        },
                        "password": schema.StringAttribute{
                                Computed:            true,
                                Sensitive:           true,
                                MarkdownDescription: "The password to access this database.",
                        },
                        "ca": schema.StringAttribute{
                                Computed:            true,
                                MarkdownDescription: "The Database CA Certificate",
                        },
                },
                MarkdownDescription: "The dbaas resource allows the user to manage a dbaas project",
        }

        maps.Copy(resp.Schema.Attributes, scopes.PublicCloud.Build())
}</span>

func (r *dbaasResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) <span class="cov0" title="0">{
        var data DBaasModel

        // Read Terraform plan data into the model
        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)

        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">chosenPack, err := r.getPackId(data, &amp;resp.Diagnostics)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">input := &amp;dbaas.DBaaS{
                Project: dbaas.DBaaSProject{
                        PublicCloudId: int(data.PublicCloudId.ValueInt64()),
                        ProjectId:     int(data.PublicCloudProjectId.ValueInt64()),
                },
                Region:  data.Region.ValueString(),
                Version: data.Version.ValueString(),
                Type:    data.Type.ValueString(),
                Name:    data.Name.ValueString(),
                PackId:  chosenPack.Id,
        }

        // CreateDBaas API call logic
        dbaasId, err := r.client.DBaas.CreateDBaaS(input)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error when creating DBaaS",
                        err.Error(),
                )
                return
        }</span>

        <span class="cov0" title="0">data.Id = types.Int64Value(int64(dbaasId))
        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)

        dbaasObject, err := r.waitUntilActive(ctx, input, dbaasId)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error when waiting for DBaaS to be Active",
                        err.Error(),
                )
                return
        }</span>

        <span class="cov0" title="0">if dbaasObject == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">connectionInfos, err := r.client.DBaas.GetPassword(
                input.Project.PublicCloudId,
                input.Project.ProjectId,
                dbaasId,
        )
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error when reading DBaaS connection infos",
                        err.Error(),
                )
                return
        }</span>

        <span class="cov0" title="0">data.fill(dbaasObject, connectionInfos)

        // Save data into Terraform state
        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *dbaasResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) <span class="cov0" title="0">{
        var state DBaasModel

        // Read Terraform plan data into the model
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;state)...)

        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // Read API call logic
        <span class="cov0" title="0">dbaasObject, err := r.client.DBaas.GetDBaaS(
                int(state.PublicCloudId.ValueInt64()),
                int(state.PublicCloudProjectId.ValueInt64()),
                int(state.Id.ValueInt64()),
        )
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error when reading DBaaS",
                        err.Error(),
                )
                return
        }</span>

        <span class="cov0" title="0">connectionInfos, err := r.client.DBaas.GetPassword(
                int(state.PublicCloudId.ValueInt64()),
                int(state.PublicCloudProjectId.ValueInt64()),
                int(state.Id.ValueInt64()),
        )
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error when reading DBaaS connection infos",
                        err.Error(),
                )
                return
        }</span>

        <span class="cov0" title="0">state.fill(dbaasObject, connectionInfos)

        // Save updated data into Terraform state
        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;state)...)</span>
}

func (r *dbaasResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) <span class="cov0" title="0">{
        var state DBaasModel
        var data DBaasModel

        // Read Terraform plan data into the model
        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;state)...)

        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">chosenPackState, err := r.getPackId(state, &amp;resp.Diagnostics)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        // Update API call logic
        <span class="cov0" title="0">input := &amp;dbaas.DBaaS{
                Project: dbaas.DBaaSProject{
                        PublicCloudId: int(data.PublicCloudId.ValueInt64()),
                        ProjectId:     int(data.PublicCloudProjectId.ValueInt64()),
                },
                Id:      int(state.Id.ValueInt64()),
                Name:    data.Name.ValueString(),
                PackId:  chosenPackState.Id,
                Region:  state.Region.ValueString(),
                Version: state.Version.ValueString(),
                Type:    state.Type.ValueString(),
        }

        _, err = r.client.DBaas.UpdateDBaaS(input)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error when updating DBaaS",
                        err.Error(),
                )
                return
        }</span>

        <span class="cov0" title="0">dbaasObject, err := r.waitUntilActive(ctx, input, input.Id)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error when getting DBaaS",
                        err.Error(),
                )
                return
        }</span>

        <span class="cov0" title="0">if dbaasObject == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">connectionInfos, err := r.client.DBaas.GetPassword(
                int(state.PublicCloudId.ValueInt64()),
                int(state.PublicCloudProjectId.ValueInt64()),
                int(state.Id.ValueInt64()),
        )
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error when reading DBaaS connection infos",
                        err.Error(),
                )
                return
        }</span>

        <span class="cov0" title="0">state.fill(dbaasObject, connectionInfos)

        // Save updated data into Terraform state
        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *dbaasResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) <span class="cov0" title="0">{
        var data DBaasModel

        // Read Terraform prior state data into the model
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;data)...)

        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // DeleteDBaas API call logic
        <span class="cov0" title="0">_, err := r.client.DBaas.DeleteDBaaS(
                int(data.PublicCloudId.ValueInt64()),
                int(data.PublicCloudProjectId.ValueInt64()),
                int(data.Id.ValueInt64()),
        )
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error when deleting DBaaS",
                        err.Error(),
                )
                return
        }</span>
}

func (r *dbaasResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) <span class="cov0" title="0">{
        idParts := strings.Split(req.ID, ",")

        if len(idParts) != 3 || idParts[0] == "" || idParts[1] == "" || idParts[2] == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unexpected Import Identifier",
                        fmt.Sprintf("Expected import identifier with format: public_cloud_id,public_cloud_project_id,id. Got: %q", req.ID),
                )
                return
        }</span>

        <span class="cov0" title="0">var errorList error

        publicCloudId, err := strconv.ParseInt(idParts[0], 10, 64)
        errorList = errors.Join(errorList, err)
        publicCloudProjectId, err := strconv.ParseInt(idParts[1], 10, 64)
        errorList = errors.Join(errorList, err)
        dbaasId, err := strconv.ParseInt(idParts[2], 10, 64)
        errorList = errors.Join(errorList, err)

        if errorList != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unexpected Import Identifier",
                        fmt.Sprintf("Expected import identifier with format: public_cloud_id,public_cloud_project_id,id. Got: %q", req.ID),
                )
                return
        }</span>

        <span class="cov0" title="0">resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("public_cloud_id"), publicCloudId)...)
        resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("public_cloud_project_id"), publicCloudProjectId)...)
        resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("id"), dbaasId)...)</span>
}

func (r *dbaasResource) getPackId(data DBaasModel, diagnostic *diag.Diagnostics) (*dbaas.DBaaSPack, error) <span class="cov0" title="0">{
        pack, err := r.client.DBaas.FindPack(data.Type.ValueString(), data.PackName.ValueString())
        if err != nil </span><span class="cov0" title="0">{
                diagnostic.AddError(
                        "Could not find DBaaS Pack",
                        err.Error(),
                )
                return nil, err
        }</span>

        <span class="cov0" title="0">return pack, nil</span>
}

func (model *DBaasModel) fill(dbaas *dbaas.DBaaS, connectionInfos *dbaas.DBaaSConnectionInfo) <span class="cov0" title="0">{
        model.Id = types.Int64Value(int64(dbaas.Id))
        model.Region = types.StringValue(dbaas.Region)
        model.Type = types.StringValue(dbaas.Type)
        model.Version = types.StringValue(dbaas.Version)
        model.Name = types.StringValue(dbaas.Name)
        model.PackName = types.StringValue(dbaas.Pack.Name)

        model.Host = types.StringValue(connectionInfos.Host)
        model.Port = types.StringValue(connectionInfos.Port)
        model.User = types.StringValue(connectionInfos.User)
        model.Password = types.StringValue(connectionInfos.Password)
        model.Ca = types.StringValue(connectionInfos.Ca)
}</span>
func (r *dbaasResource) waitUntilActive(ctx context.Context, dbaas *dbaas.DBaaS, id int) (*dbaas.DBaaS, error) <span class="cov0" title="0">{
        t := time.NewTicker(5 * time.Second)
        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return nil, nil</span>
                case &lt;-t.C:<span class="cov0" title="0">
                        found, err := r.client.DBaas.GetDBaaS(dbaas.Project.PublicCloudId, dbaas.Project.ProjectId, id)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>

                        <span class="cov0" title="0">if ctx.Err() != nil </span><span class="cov0" title="0">{
                                return nil, nil
                        }</span>

                        <span class="cov0" title="0">if found.Status == "ready" </span><span class="cov0" title="0">{
                                return found, nil
                        }</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package dbaas

import (
        "context"
        "maps"
        "terraform-provider-infomaniak/internal/apis"
        "terraform-provider-infomaniak/internal/apis/dbaas"
        "terraform-provider-infomaniak/internal/provider"
        "terraform-provider-infomaniak/internal/services/scopes"
        "time"

        "github.com/hashicorp/terraform-plugin-framework/path"
        "github.com/hashicorp/terraform-plugin-framework/resource"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
        "github.com/hashicorp/terraform-plugin-framework/types"
)

var (
        _ resource.Resource                = &amp;dbaasRestoreResource{}
        _ resource.ResourceWithConfigure   = &amp;dbaasRestoreResource{}
        _ resource.ResourceWithImportState = &amp;dbaasRestoreResource{}
)

func NewDBaasRestoreResource() resource.Resource <span class="cov10" title="502">{
        return &amp;dbaasRestoreResource{}
}</span>

type dbaasRestoreResource struct {
        client *apis.Client
}

type DBaasRestoreModel struct {
        PublicCloudId        types.Int64  `tfsdk:"public_cloud_id"`
        PublicCloudProjectId types.Int64  `tfsdk:"public_cloud_project_id"`
        DBaasId              types.Int64  `tfsdk:"dbaas_id"`
        BackupId             types.String `tfsdk:"backup_id"`
        Id                   types.String `tfsdk:"id"`
}

func (r *dbaasRestoreResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) <span class="cov9" title="355">{
        resp.TypeName = req.ProviderTypeName + "_dbaas_restore"
}</span>

// Configure adds the provider configured client to the data source.
func (r *dbaasRestoreResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) <span class="cov0" title="0">{
        // Add a nil check when handling ProviderData because Terraform
        // sets that data after it calls the ConfigureProvider RPC.
        if req.ProviderData == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">client, err := provider.GetApiClient(req.ProviderData)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unexpected Resource Configure Type",
                        err.Error(),
                )
                return
        }</span>

        <span class="cov0" title="0">r.client = client</span>
}

func (r *dbaasRestoreResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) <span class="cov8" title="147">{
        resp.Schema = schema.Schema{
                Attributes: map[string]schema.Attribute{
                        "backup_id": schema.StringAttribute{
                                Required:            true,
                                MarkdownDescription: "The id of the backup",
                                PlanModifiers: []planmodifier.String{
                                        stringplanmodifier.UseStateForUnknown(),
                                },
                        },
                        "id": schema.StringAttribute{
                                Computed:            true,
                                MarkdownDescription: "A computed value representing the unique identifier for the architecture. Mandatory for acceptance testing.",
                                PlanModifiers: []planmodifier.String{
                                        stringplanmodifier.UseStateForUnknown(),
                                },
                        },
                },
                MarkdownDescription: "The dbaas restore resource allows the user to restore a backup for a certain dbaas",
        }

        maps.Copy(resp.Schema.Attributes, scopes.DBaaS.Build())
}</span>

func (r *dbaasRestoreResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) <span class="cov0" title="0">{
        var data DBaasRestoreModel

        // Read Terraform plan data into the model
        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)

        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // CreateBackup API call logic
        <span class="cov0" title="0">restore, err := r.client.DBaas.CreateRestore(
                int(data.PublicCloudId.ValueInt64()),
                int(data.PublicCloudProjectId.ValueInt64()),
                int(data.DBaasId.ValueInt64()),
                data.BackupId.ValueString(),
        )
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error when creating Restore",
                        err.Error(),
                )
                return
        }</span>

        <span class="cov0" title="0">data.Id = types.StringValue(restore.Id)
        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)

        restore, err = r.waitUntilActive(ctx,
                int(data.PublicCloudId.ValueInt64()),
                int(data.PublicCloudProjectId.ValueInt64()),
                int(data.DBaasId.ValueInt64()),
                data.BackupId.ValueString(),
                restore.Id,
        )
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error when waiting for Restore to be finished",
                        err.Error(),
                )
                return
        }</span>

        <span class="cov0" title="0">if restore == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">data.fill(restore)

        // Save data into Terraform state
        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *dbaasRestoreResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) <span class="cov0" title="0">{
        var state DBaasRestoreModel

        // Read Terraform plan data into the model
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;state)...)

        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // Read API call logic
        <span class="cov0" title="0">restore, err := r.client.DBaas.GetRestore(
                int(state.PublicCloudId.ValueInt64()),
                int(state.PublicCloudProjectId.ValueInt64()),
                int(state.DBaasId.ValueInt64()),
                state.Id.ValueString(),
        )
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error when reading Restore",
                        err.Error(),
                )
                return
        }</span>

        <span class="cov0" title="0">state.fill(restore)

        // Save updated data into Terraform state
        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;state)...)</span>
}

func (r *dbaasRestoreResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) <span class="cov0" title="0">{
        resp.Diagnostics.AddError(
                "Cannot update",
                "This resource cannot be updated.",
        )
}</span>

func (r *dbaasRestoreResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {<span class="cov0" title="0">
        // NOP
}</span>

func (r *dbaasRestoreResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) <span class="cov0" title="0">{
        imports, err := parseBackupRestoreImport(req)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unexpected Import Identifier",
                        err.Error(),
                )
                return
        }</span>

        <span class="cov0" title="0">resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("public_cloud_id"), imports.PublicCloudId)...)
        resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("public_cloud_project_id"), imports.PublicCloudProjectId)...)
        resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("dbaas_id"), imports.DbaasId)...)
        resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("id"), imports.Id)...)</span>
}

func (r *dbaasRestoreResource) waitUntilActive(ctx context.Context, publicCloudId int, publicCloudProjectId int, dbaasId int, backupId, id string) (*dbaas.DBaaSRestore, error) <span class="cov0" title="0">{
        t := time.NewTicker(5 * time.Second)
        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return nil, nil</span>
                case &lt;-t.C:<span class="cov0" title="0">
                        found, err := r.client.DBaas.GetRestore(publicCloudId, publicCloudProjectId, dbaasId, id)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>

                        <span class="cov0" title="0">if ctx.Err() != nil </span><span class="cov0" title="0">{
                                return nil, nil
                        }</span>

                        <span class="cov0" title="0">if found.Status != "Unknown" </span><span class="cov0" title="0">{
                                return found, nil
                        }</span>
                }
        }
}

func (model *DBaasRestoreModel) fill(restore *dbaas.DBaaSRestore) <span class="cov0" title="0">{
        model.Id = types.StringValue(restore.Id)
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">package dbaas

import "terraform-provider-infomaniak/internal/provider/registry"

func Register() <span class="cov10" title="295">{
        registry.RegisterResource(NewDBaasResource)
        registry.RegisterResource(NewDBaasBackupResource)
        registry.RegisterResource(NewDBaasRestoreResource)

        registry.RegisterDataSource(NewDBaasDataSource)
}</span>
</pre>
		
		<pre class="file" id="file21" style="display: none">package dbaas

import (
        "errors"
        "fmt"
        "strconv"
        "strings"

        "github.com/hashicorp/terraform-plugin-framework/resource"
)

type ImportIds struct {
        PublicCloudId        int
        PublicCloudProjectId int
        DbaasId              int
        Id                   string
}

func parseBackupRestoreImport(req resource.ImportStateRequest) (*ImportIds, error) <span class="cov0" title="0">{
        idParts := strings.Split(req.ID, ",")

        if len(idParts) != 4 || idParts[0] == "" || idParts[1] == "" || idParts[2] == "" || idParts[3] == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("expected import identifier with format: public_cloud_id,public_cloud_project_id,dbaas_id,id. got: %q", req.ID)
        }</span>

        <span class="cov0" title="0">var errorList error

        publicCloudId, err := strconv.ParseInt(idParts[0], 10, 64)
        errorList = errors.Join(errorList, err)
        publicCloudProjectId, err := strconv.ParseInt(idParts[1], 10, 64)
        errorList = errors.Join(errorList, err)
        dbaasId, err := strconv.ParseInt(idParts[2], 10, 64)
        errorList = errors.Join(errorList, err)
        id := idParts[3]

        if errorList != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("expected import identifier with format: public_cloud_id,public_cloud_project_id,dbaas_id,id. got: %q", req.ID)
        }</span>

        <span class="cov0" title="0">return &amp;ImportIds{
                PublicCloudId:        int(publicCloudId),
                PublicCloudProjectId: int(publicCloudProjectId),
                DbaasId:              int(dbaasId),
                Id:                   id,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package domain

import (
        "fmt"
        "net"
        "strings"
        "terraform-provider-infomaniak/internal/apis/domain"

        "github.com/hashicorp/terraform-plugin-framework/types"
        "github.com/miekg/dns"
)

func (model *RecordModel) ComputeRawTarget() string <span class="cov0" title="0">{
        // don't do anything if it's already set
        if !model.Target.IsUnknown() &amp;&amp; !model.Target.IsNull() </span><span class="cov0" title="0">{
                return model.Target.ValueString()
        }</span>

        <span class="cov0" title="0">var record dns.RR

        switch model.Type.ValueString() </span>{
        case domain.RecordA:<span class="cov0" title="0">
                record = &amp;dns.A{
                        A: net.ParseIP(model.Data.IP.ValueString()),
                }</span>
        case domain.RecordAAAA:<span class="cov0" title="0">
                record = &amp;dns.AAAA{
                        AAAA: net.ParseIP(model.Data.IP.ValueString()),
                }</span>
        case domain.RecordCAA:<span class="cov0" title="0">
                record = &amp;dns.CAA{
                        Flag:  uint8(model.Data.Flags.ValueInt64()),
                        Tag:   model.Data.Tag.ValueString(),
                        Value: model.Data.Value.ValueString(),
                }</span>
        case domain.RecordCNAME:<span class="cov0" title="0">
                record = &amp;dns.CNAME{
                        Target: dns.Fqdn(model.Data.Target.ValueString()),
                }</span>
        case domain.RecordDNAME:<span class="cov0" title="0">
                record = &amp;dns.DNAME{
                        Target: dns.Fqdn(model.Data.Target.ValueString()),
                }</span>
        case domain.RecordDS:<span class="cov0" title="0">
                record = &amp;dns.DS{
                        KeyTag:     uint16(model.Data.KeyTag.ValueInt64()),
                        Algorithm:  uint8(model.Data.Algorithm.ValueInt64()),
                        DigestType: uint8(model.Data.DigestType.ValueInt64()),
                        Digest:     model.Data.Digest.ValueString(),
                }</span>
        case domain.RecordMX:<span class="cov0" title="0">
                record = &amp;dns.MX{
                        Preference: uint16(model.Data.Priority.ValueInt64()),
                        Mx:         dns.Fqdn(model.Data.Target.ValueString()),
                }</span>
        case domain.RecordNS:<span class="cov0" title="0">
                record = &amp;dns.NS{
                        Ns: dns.Fqdn(model.Data.Target.ValueString()),
                }</span>
        case domain.RecordSMIMEA:<span class="cov0" title="0">
                record = &amp;dns.SMIMEA{
                        Usage:        uint8(model.Data.Priority.ValueInt64()),
                        Selector:     uint8(model.Data.Selector.ValueInt64()),
                        MatchingType: uint8(model.Data.MatchingType.ValueInt64()),
                        Certificate:  model.Data.CertAssocData.ValueString(),
                }</span>
        case domain.RecordSRV:<span class="cov0" title="0">
                record = &amp;dns.SRV{
                        Priority: uint16(model.Data.Priority.ValueInt64()),
                        Weight:   uint16(model.Data.Weight.ValueInt64()),
                        Port:     uint16(model.Data.Port.ValueInt64()),
                        Target:   dns.Fqdn(model.Data.Target.ValueString()),
                }</span>
        case domain.RecordSSHFP:<span class="cov0" title="0">
                record = &amp;dns.SSHFP{
                        Algorithm:   uint8(model.Data.FingerprintAlgorithm.ValueInt64()),
                        Type:        uint8(model.Data.FingerprintType.ValueInt64()),
                        FingerPrint: model.Data.Fingerprint.ValueString(),
                }</span>
        case domain.RecordTLSA:<span class="cov0" title="0">
                record = &amp;dns.TLSA{
                        Usage:        uint8(model.Data.Priority.ValueInt64()),
                        Selector:     uint8(model.Data.Selector.ValueInt64()),
                        MatchingType: uint8(model.Data.MatchingType.ValueInt64()),
                        Certificate:  model.Data.CertAssocData.ValueString(),
                }</span>
        case domain.RecordTXT:<span class="cov0" title="0">
                record = &amp;dns.TXT{
                        Txt: []string{model.Data.Value.ValueString()},
                }</span>
        }

        <span class="cov0" title="0">return strings.TrimPrefix(record.String(), record.Header().String())</span>
}

func (model *RecordModel) ParseRawTarget(raw string) error <span class="cov0" title="0">{
        // We need to prepend a fake name to make dns.NewRR happy
        full := fmt.Sprintf("example.com. 3600 IN %s %s", model.Type.ValueString(), raw)

        rr, err := dns.NewRR(full)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to parse DNS record: %w", err)
        }</span>

        <span class="cov0" title="0">switch v := rr.(type) </span>{
        case *dns.A:<span class="cov0" title="0">
                model.Data.IP = types.StringValue(v.A.String())</span>

        case *dns.AAAA:<span class="cov0" title="0">
                model.Data.IP = types.StringValue(v.AAAA.String())</span>

        case *dns.CAA:<span class="cov0" title="0">
                model.Data.Flags = types.Int64Value(int64(v.Flag))
                model.Data.Tag = types.StringValue(v.Tag)
                model.Data.Value = types.StringValue(v.Value)</span>

        case *dns.CNAME:<span class="cov0" title="0">
                model.Data.Target = types.StringValue(strings.TrimSuffix(v.Target, "."))</span>

        case *dns.DNAME:<span class="cov0" title="0">
                model.Data.Target = types.StringValue(strings.TrimSuffix(v.Target, "."))</span>

        case *dns.DS:<span class="cov0" title="0">
                model.Data.KeyTag = types.Int64Value(int64(v.KeyTag))
                model.Data.Algorithm = types.Int64Value(int64(v.Algorithm))
                model.Data.DigestType = types.Int64Value(int64(v.DigestType))
                model.Data.Digest = types.StringValue(v.Digest)</span>

        case *dns.MX:<span class="cov0" title="0">
                model.Data.Priority = types.Int64Value(int64(v.Preference))
                model.Data.Target = types.StringValue(strings.TrimSuffix(v.Mx, "."))</span>

        case *dns.NS:<span class="cov0" title="0">
                model.Data.Target = types.StringValue(strings.TrimSuffix(v.Ns, "."))</span>

        case *dns.PTR:<span class="cov0" title="0">
                model.Data.Target = types.StringValue(strings.TrimSuffix(v.Ptr, "."))</span>

        case *dns.SMIMEA:<span class="cov0" title="0">
                model.Data.Priority = types.Int64Value(int64(v.Usage))
                model.Data.Selector = types.Int64Value(int64(v.Selector))
                model.Data.MatchingType = types.Int64Value(int64(v.MatchingType))
                model.Data.CertAssocData = types.StringValue(v.Certificate)</span>

        case *dns.SRV:<span class="cov0" title="0">
                model.Data.Priority = types.Int64Value(int64(v.Priority))
                model.Data.Weight = types.Int64Value(int64(v.Weight))
                model.Data.Port = types.Int64Value(int64(v.Port))
                model.Data.Target = types.StringValue(strings.TrimSuffix(v.Target, "."))</span>

        case *dns.SSHFP:<span class="cov0" title="0">
                model.Data.FingerprintAlgorithm = types.Int64Value(int64(v.Algorithm))
                model.Data.FingerprintType = types.Int64Value(int64(v.Type))
                model.Data.Fingerprint = types.StringValue(v.FingerPrint)</span>

        case *dns.TLSA:<span class="cov0" title="0">
                model.Data.Priority = types.Int64Value(int64(v.Usage))
                model.Data.Selector = types.Int64Value(int64(v.Selector))
                model.Data.MatchingType = types.Int64Value(int64(v.MatchingType))
                model.Data.CertAssocData = types.StringValue(v.Certificate)</span>

        case *dns.TXT:<span class="cov0" title="0">
                if len(v.Txt) &gt; 0 </span><span class="cov0" title="0">{
                        model.Data.Value = types.StringValue(v.Txt[0])
                }</span>

        default:<span class="cov0" title="0">
                return fmt.Errorf("unsupported record type: %T", rr)</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package domain

import (
        "context"
        "errors"
        "fmt"
        "strconv"
        "strings"
        "terraform-provider-infomaniak/internal/apis"
        "terraform-provider-infomaniak/internal/apis/domain"
        "terraform-provider-infomaniak/internal/provider"

        "github.com/hashicorp/terraform-plugin-framework-validators/objectvalidator"
        "github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
        "github.com/hashicorp/terraform-plugin-framework/path"
        "github.com/hashicorp/terraform-plugin-framework/resource"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/int64default"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/int64planmodifier"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
        "github.com/hashicorp/terraform-plugin-framework/schema/validator"
        "github.com/hashicorp/terraform-plugin-framework/types"
)

var (
        _ resource.Resource                = &amp;recordResource{}
        _ resource.ResourceWithConfigure   = &amp;recordResource{}
        _ resource.ResourceWithImportState = &amp;recordResource{}
        _ resource.ResourceWithModifyPlan  = &amp;recordResource{}
)

func NewRecordResource() resource.Resource <span class="cov10" title="502">{
        return &amp;recordResource{}
}</span>

type recordResource struct {
        client *apis.Client
}

type RecordModel struct {
        ZoneFqdn types.String `tfsdk:"zone_fqdn"`
        Id       types.Int64  `tfsdk:"id"`

        Type           types.String     `tfsdk:"type"`
        Source         types.String     `tfsdk:"source"`
        ComputedTarget types.String     `tfsdk:"computed_target"`
        Target         types.String     `tfsdk:"target"`
        TTL            types.Int64      `tfsdk:"ttl"`
        Description    types.String     `tfsdk:"description"`
        Data           *RecordDataModel `tfsdk:"data"`
}

type RecordDataModel struct {
        IP                   types.String `tfsdk:"ip"`                    // A, AAAA
        Priority             types.Int64  `tfsdk:"priority"`              // MX, SRV
        Target               types.String `tfsdk:"target"`                // MX, SRV, CNAME, NS, PTR
        Weight               types.Int64  `tfsdk:"weight"`                // SRV
        Port                 types.Int64  `tfsdk:"port"`                  // SRV
        KeyTag               types.Int64  `tfsdk:"key_tag"`               // DS
        Algorithm            types.Int64  `tfsdk:"algorithm"`             // DNSKEY, DS, SSHFP, TLSA
        DigestType           types.Int64  `tfsdk:"digest_type"`           // DS, TLSA
        Digest               types.String `tfsdk:"digest"`                // DS, TLSA, SSHFP
        Selector             types.Int64  `tfsdk:"selector"`              // SMIMEA, TLSA
        MatchingType         types.Int64  `tfsdk:"matching_type"`         // SMIMEA, TLSA
        CertAssocData        types.String `tfsdk:"cert_assoc_data"`       // SMIMEA, TLSA
        Flags                types.Int64  `tfsdk:"flags"`                 // CAA, DNSKEY
        Tag                  types.String `tfsdk:"tag"`                   // CAA
        Value                types.String `tfsdk:"value"`                 // CAA, TXT
        Fingerprint          types.String `tfsdk:"fingerprint"`           // SSHFP
        FingerprintType      types.Int64  `tfsdk:"fingerprint_type"`      // SSHFP
        FingerprintAlgorithm types.Int64  `tfsdk:"fingerprint_algorithm"` // SSHFP
}

func (r *recordResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) <span class="cov9" title="355">{
        resp.TypeName = req.ProviderTypeName + "_record"
}</span>

// Configure adds the provider configured client to the data source.
func (r *recordResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) <span class="cov0" title="0">{
        // Add a nil check when handling ProviderData because Terraform
        // sets that data after it calls the ConfigureProvider RPC.
        if req.ProviderData == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">client, err := provider.GetApiClient(req.ProviderData)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unexpected Record Resource Configure Type",
                        err.Error(),
                )
                return
        }</span>

        <span class="cov0" title="0">r.client = client</span>
}

func (r *recordResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) <span class="cov8" title="147">{
        resp.Schema = schema.Schema{
                Attributes: map[string]schema.Attribute{
                        "zone_fqdn": schema.StringAttribute{
                                Required:            true,
                                MarkdownDescription: "The FQDN of the zone where the record should be put in.",
                                PlanModifiers: []planmodifier.String{
                                        stringplanmodifier.RequiresReplace(),
                                },
                        },
                        "source": schema.StringAttribute{
                                Required:            true,
                                MarkdownDescription: "The source of the Record.",
                                PlanModifiers: []planmodifier.String{
                                        stringplanmodifier.RequiresReplace(),
                                        stringplanmodifier.UseStateForUnknown(),
                                },
                        },
                        "type": schema.StringAttribute{
                                Required:            true,
                                MarkdownDescription: "The type of the Record.",
                                Validators: []validator.String{
                                        stringvalidator.OneOf(domain.RecordTypes...),
                                },
                                PlanModifiers: []planmodifier.String{
                                        stringplanmodifier.RequiresReplace(),
                                        stringplanmodifier.UseStateForUnknown(),
                                },
                        },
                        "description": schema.StringAttribute{
                                Optional:            true,
                                MarkdownDescription: "The description of the Record.",
                                PlanModifiers: []planmodifier.String{
                                        stringplanmodifier.UseStateForUnknown(),
                                },
                        },
                        "ttl": schema.Int64Attribute{
                                Optional:            true,
                                Computed:            true,
                                MarkdownDescription: "The TTL of the Record.",
                                Default:             int64default.StaticInt64(3600),
                                PlanModifiers: []planmodifier.Int64{
                                        int64planmodifier.UseStateForUnknown(),
                                },
                        },
                        "computed_target": schema.StringAttribute{
                                Computed:            true,
                                MarkdownDescription: "The computed target of the Record.",
                        },
                        "target": schema.StringAttribute{
                                Optional:            true,
                                MarkdownDescription: "The target of the Record.",
                                Validators: []validator.String{
                                        stringvalidator.ConflictsWith(path.MatchRoot("data")),
                                },
                        },
                        "data": schema.SingleNestedAttribute{
                                Description: "Components of a DNS record.",
                                Optional:    true,
                                Validators: []validator.Object{
                                        objectvalidator.All(
                                                objectvalidator.ConflictsWith(path.MatchRoot("target")),
                                        ),
                                },
                                Attributes: map[string]schema.Attribute{
                                        "ip": schema.StringAttribute{
                                                Optional:            true,
                                                MarkdownDescription: "IP for the record",
                                        },
                                        // For MX, SRV, TLSA, SMIMEA, SSHFP
                                        "priority": schema.Int64Attribute{
                                                Optional:            true,
                                                MarkdownDescription: "The priority/usage/weight of the Record (MX, SRV, TLSA, SMIMEA).",
                                        },
                                        // For SRV
                                        "weight": schema.Int64Attribute{
                                                Optional:            true,
                                                MarkdownDescription: "The weight of the Record (SRV).",
                                        },
                                        "port": schema.Int64Attribute{
                                                Optional:            true,
                                                MarkdownDescription: "The port of the Record (SRV).",
                                        },

                                        // For CAA
                                        "flags": schema.Int64Attribute{
                                                Optional:            true,
                                                MarkdownDescription: "The flags of the Record (CAA).",
                                        },
                                        "tag": schema.StringAttribute{
                                                Optional:            true,
                                                MarkdownDescription: "The tag of the Record (CAA).",
                                        },

                                        // For DNSKEY
                                        "algorithm": schema.Int64Attribute{
                                                Optional:            true,
                                                MarkdownDescription: "The algorithm of the Record (DNSKEY, DS, SSHFP).",
                                        },

                                        // For DS
                                        "key_tag": schema.Int64Attribute{
                                                Optional:            true,
                                                MarkdownDescription: "The Key Tag of the Record (DS).",
                                        },
                                        "digest_type": schema.Int64Attribute{
                                                Optional:            true,
                                                MarkdownDescription: "The digest type of the Record (DS).",
                                        },
                                        "digest": schema.StringAttribute{
                                                Optional:            true,
                                                MarkdownDescription: "The digest of the Record (DS).",
                                        },

                                        // For TLSA / SMIMEA
                                        "selector": schema.Int64Attribute{
                                                Optional:            true,
                                                MarkdownDescription: "The selector of the Record (TLSA, SMIMEA).",
                                        },
                                        "matching_type": schema.Int64Attribute{
                                                Optional:            true,
                                                MarkdownDescription: "The matching type of the Record (TLSA, SMIMEA).",
                                        },
                                        "cert_assoc_data": schema.StringAttribute{
                                                Optional:            true,
                                                MarkdownDescription: "The certificate association data (TLSA, SMIMEA).",
                                        },

                                        // For SSHFP
                                        "fingerprint_algorithm": schema.Int64Attribute{
                                                Optional:            true,
                                                MarkdownDescription: "The algorithm of the Record (DNSKEY, DS, SSHFP).",
                                        },
                                        "fingerprint_type": schema.Int64Attribute{
                                                Optional:            true,
                                                MarkdownDescription: "The fingerprint type of the Record (SSHFP).",
                                        },
                                        "fingerprint": schema.StringAttribute{
                                                Optional:            true,
                                                MarkdownDescription: "The fingerprint of the Record (SSHFP).",
                                        },

                                        "target": schema.StringAttribute{
                                                Optional:            true,
                                                MarkdownDescription: "The target of the Record (MX, CNAME, DNAME, NS, PTR, etc).",
                                        },
                                        // For generic text value (e.g. TXT, CAA value, etc)
                                        "value": schema.StringAttribute{
                                                Optional:            true,
                                                MarkdownDescription: "The value of the Record (TXT, CAA, etc).",
                                        },
                                },
                        },
                        "id": schema.Int64Attribute{
                                Computed:            true,
                                MarkdownDescription: "The id of the Record.",
                                PlanModifiers: []planmodifier.Int64{
                                        int64planmodifier.UseStateForUnknown(),
                                },
                        },
                },
                MarkdownDescription: "The record resource allows the user to manage a record inside a zone of a domain",
        }
}</span>

func (r *recordResource) ModifyPlan(ctx context.Context, req resource.ModifyPlanRequest, resp *resource.ModifyPlanResponse) <span class="cov0" title="0">{
        if req.Plan.Raw.IsNull() </span><span class="cov0" title="0">{
                // Handle destroy plan (optional)
                return
        }</span>

        <span class="cov0" title="0">var plan RecordModel
        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;plan)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">computedTarget := plan.ComputeRawTarget()
        plan.ComputedTarget = types.StringValue(computedTarget)

        // Set the modified plan back
        resp.Diagnostics.Append(resp.Plan.Set(ctx, &amp;plan)...)</span>
}

func (r *recordResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) <span class="cov0" title="0">{
        var data RecordModel

        // Read Terraform plan data into the model
        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)

        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">rawTarget := data.ComputeRawTarget()

        record, err := r.client.Domain.CreateRecord(
                data.ZoneFqdn.ValueString(),
                data.Type.ValueString(),
                data.Source.ValueString(),
                rawTarget,
                data.TTL.ValueInt64(),
        )
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error when creating Record",
                        err.Error(),
                )
                return
        }</span>

        <span class="cov0" title="0">data.Id = types.Int64Value(int64(record.ID))
        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *recordResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) <span class="cov0" title="0">{
        var state RecordModel

        // Read Terraform plan data into the model
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;state)...)

        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // Read API call logic
        <span class="cov0" title="0">record, err := r.client.Domain.GetRecord(state.ZoneFqdn.ValueString(), state.Id.ValueInt64())
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error when reading Record",
                        err.Error(),
                )
                return
        }</span>

        <span class="cov0" title="0">state.Id = types.Int64Value(int64(record.ID))
        state.TTL = types.Int64Value(int64(record.TTL))
        state.Source = types.StringValue(record.Source)
        state.Type = types.StringValue(record.Type)

        // If we have neither of them, we fill them with the API
        // However in this state (import), we can't know which field is planned by the user
        if state.Target.IsNull() &amp;&amp; state.Data == nil </span><span class="cov0" title="0">{
                state.Target = types.StringValue(record.Target)
                state.Data = &amp;RecordDataModel{}
                state.ParseRawTarget(record.Target)
        }</span>

        // Save updated data into Terraform state
        <span class="cov0" title="0">resp.Diagnostics.Append(resp.State.Set(ctx, &amp;state)...)</span>
}

func (r *recordResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) <span class="cov0" title="0">{
        var state RecordModel
        var data RecordModel

        // Read Terraform plan data into the model
        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;state)...)

        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">rawTarget := data.ComputeRawTarget()

        record, err := r.client.Domain.UpdateRecord(
                data.ZoneFqdn.ValueString(),
                state.Id.ValueInt64(),
                data.Type.ValueString(),
                data.Source.ValueString(),
                rawTarget,
                data.TTL.ValueInt64(),
        )
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error when updating Record",
                        err.Error(),
                )
                return
        }</span>

        <span class="cov0" title="0">data.Id = types.Int64Value(int64(record.ID))
        // Save updated data into Terraform state
        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *recordResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) <span class="cov0" title="0">{
        var state RecordModel
        var data RecordModel

        // Read Terraform prior state data into the model
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;data)...)
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;state)...)

        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">_, err := r.client.Domain.DeleteRecord(
                data.ZoneFqdn.ValueString(),
                state.Id.ValueInt64(),
        )
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error when deleting Record",
                        err.Error(),
                )
                return
        }</span>
}

func (r *recordResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) <span class="cov0" title="0">{
        idParts := strings.Split(req.ID, ",")

        if len(idParts) != 2 || idParts[0] == "" || idParts[1] == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unexpected Import Identifier",
                        fmt.Sprintf("Expected import identifier with format: zone_fqdn,id. Got: %q", req.ID),
                )
                return
        }</span>

        <span class="cov0" title="0">var errorList error

        zoneFQDN := idParts[0]
        recordId, err := strconv.ParseInt(idParts[1], 10, 64)
        errorList = errors.Join(errorList, err)

        if errorList != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unexpected Import Identifier",
                        fmt.Sprintf("Expected import identifier with format: zone_fqdn,id. Got: %q", req.ID),
                )
                return
        }</span>

        <span class="cov0" title="0">resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("zone_fqdn"), zoneFQDN)...)
        resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("id"), recordId)...)</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package domain

import "terraform-provider-infomaniak/internal/provider/registry"

func Register() <span class="cov10" title="295">{
        registry.RegisterResource(NewZoneResource)
        registry.RegisterResource(NewRecordResource)
}</span>
</pre>
		
		<pre class="file" id="file25" style="display: none">package domain

import (
        "context"
        "terraform-provider-infomaniak/internal/apis"
        "terraform-provider-infomaniak/internal/provider"

        "github.com/hashicorp/terraform-plugin-framework/path"
        "github.com/hashicorp/terraform-plugin-framework/resource"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/int64planmodifier"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
        "github.com/hashicorp/terraform-plugin-framework/types"
)

var (
        _ resource.Resource                = &amp;zoneResource{}
        _ resource.ResourceWithConfigure   = &amp;zoneResource{}
        _ resource.ResourceWithImportState = &amp;zoneResource{}
)

func NewZoneResource() resource.Resource <span class="cov10" title="502">{
        return &amp;zoneResource{}
}</span>

type zoneResource struct {
        client *apis.Client
}

type ZoneModel struct {
        Fqdn types.String `tfsdk:"fqdn"`
        Id   types.Int64  `tfsdk:"id"`
}

func (r *zoneResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) <span class="cov9" title="355">{
        resp.TypeName = req.ProviderTypeName + "_zone"
}</span>

// Configure adds the provider configured client to the data source.
func (r *zoneResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) <span class="cov0" title="0">{
        // Add a nil check when handling ProviderData because Terraform
        // sets that data after it calls the ConfigureProvider RPC.
        if req.ProviderData == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">client, err := provider.GetApiClient(req.ProviderData)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unexpected Zone Resource Configure Type",
                        err.Error(),
                )
                return
        }</span>

        <span class="cov0" title="0">r.client = client</span>
}

func (r *zoneResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) <span class="cov8" title="147">{
        resp.Schema = schema.Schema{
                Attributes: map[string]schema.Attribute{
                        "fqdn": schema.StringAttribute{
                                Required:            true,
                                MarkdownDescription: "The fqdn of the zone",
                                PlanModifiers: []planmodifier.String{
                                        stringplanmodifier.RequiresReplace(),
                                },
                        },
                        "id": schema.Int64Attribute{
                                Computed:            true,
                                MarkdownDescription: "A computed value representing the unique identifier for the architecture. Mandatory for acceptance testing.",
                                PlanModifiers: []planmodifier.Int64{
                                        int64planmodifier.UseStateForUnknown(),
                                },
                        },
                },
                MarkdownDescription: "The Zone resource allows the user to manage a zone for a domain project",
        }
}</span>

func (r *zoneResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) <span class="cov0" title="0">{
        var data ZoneModel

        // Read Terraform plan data into the model
        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)

        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // CreateZone API call logic
        <span class="cov0" title="0">zone, err := r.client.Domain.CreateZone(data.Fqdn.ValueString())
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error when creating Zone",
                        err.Error(),
                )
                return
        }</span>

        <span class="cov0" title="0">data.Id = types.Int64Value(int64(zone.ID))
        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *zoneResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) <span class="cov0" title="0">{
        var state ZoneModel

        // Read Terraform plan data into the model
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;state)...)

        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // Read API call logic
        <span class="cov0" title="0">zone, err := r.client.Domain.GetZone(state.Fqdn.ValueString())
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error when reading Zone",
                        err.Error(),
                )
                return
        }</span>

        <span class="cov0" title="0">state.Id = types.Int64Value(int64(zone.ID))
        state.Fqdn = types.StringValue(zone.FQDN)

        // Save updated data into Terraform state
        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;state)...)</span>
}

func (r *zoneResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) <span class="cov0" title="0">{
        var state ZoneModel
        var data ZoneModel

        // Read Terraform plan data into the model
        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;state)...)

        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // Save updated data into Terraform state
        <span class="cov0" title="0">resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *zoneResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) <span class="cov0" title="0">{
        var data ZoneModel

        // Read Terraform prior state data into the model
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;data)...)

        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // DeleteZone API call logic
        <span class="cov0" title="0">_, err := r.client.Domain.DeleteZone(data.Fqdn.ValueString())
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error when deleting Zone",
                        err.Error(),
                )
                return
        }</span>
}

func (r *zoneResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) <span class="cov0" title="0">{
        resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("fqdn"), req.ID)...)
}</span>
</pre>
		
		<pre class="file" id="file26" style="display: none">package kaas

import (
        "context"
        "terraform-provider-infomaniak/internal/apis"
        "terraform-provider-infomaniak/internal/provider"

        "github.com/hashicorp/terraform-plugin-framework/datasource"
        "github.com/hashicorp/terraform-plugin-framework/datasource/schema"
        "github.com/hashicorp/terraform-plugin-framework/types"
)

// Ensure the implementation satisfies the expected interfaces.
var (
        _ datasource.DataSource              = &amp;kaasDataSource{}
        _ datasource.DataSourceWithConfigure = &amp;kaasDataSource{}
)

type kaasDataSource struct {
        client *apis.Client
}

// NewKaasDataSource is a helper function to simplify the provider implementation.
func NewKaasDataSource() datasource.DataSource <span class="cov10" title="305">{
        return &amp;kaasDataSource{}
}</span>

// Configure adds the provider configured client to the data source.
func (d *kaasDataSource) Configure(_ context.Context, req datasource.ConfigureRequest, resp *datasource.ConfigureResponse) <span class="cov0" title="0">{
        // Add a nil check when handling ProviderData because Terraform
        // sets that data after it calls the ConfigureProvider RPC.
        if req.ProviderData == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">client, err := provider.GetApiClient(req.ProviderData)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unexpected Data Source Configure Type",
                        err.Error(),
                )
                return
        }</span>

        <span class="cov0" title="0">d.client = client</span>
}

// Schema defines the schema for the data source.
func (d *kaasDataSource) Schema(ctx context.Context, _ datasource.SchemaRequest, resp *datasource.SchemaResponse) <span class="cov8" title="147">{
        resp.Schema = schema.Schema{
                Attributes: map[string]schema.Attribute{
                        "public_cloud_id": schema.Int64Attribute{
                                Required:            true,
                                Description:         "The id of the public cloud where KaaS is installed",
                                MarkdownDescription: "The id of the public cloud where KaaS is installed",
                        },
                        "public_cloud_project_id": schema.Int64Attribute{
                                Required:            true,
                                Description:         "The id of the public cloud project where KaaS is installed",
                                MarkdownDescription: "The id of the public cloud project where KaaS is installed",
                        },
                        "id": schema.Int64Attribute{
                                Required:            true,
                                Description:         "The id of this KaaS",
                                MarkdownDescription: "The id of this KaaS",
                        },
                        "name": schema.StringAttribute{
                                Computed:            true,
                                Description:         "The name of the KaaS project",
                                MarkdownDescription: "The name of the KaaS project",
                        },
                        "pack_name": schema.StringAttribute{
                                Computed:            true,
                                Description:         "The name of the pack associated to the KaaS project",
                                MarkdownDescription: "The name of the pack associated to the KaaS project",
                        },
                        "region": schema.StringAttribute{
                                Computed:            true,
                                Description:         "The region where the KaaS project resides in.",
                                MarkdownDescription: "The region where the KaaS project resides in.",
                        },
                        "kubeconfig": schema.StringAttribute{
                                Computed:            true,
                                Sensitive:           true,
                                Description:         "The kubeconfig generated to access to KaaS project",
                                MarkdownDescription: "The kubeconfig generated to access to KaaS project",
                        },
                        "kubernetes_version": schema.StringAttribute{
                                Computed:            true,
                                Description:         "The version of Kubernetes associated with the KaaS project",
                                MarkdownDescription: "The version of Kubernetes associated with the KaaS project",
                        },
                        "apiserver": schema.SingleNestedAttribute{
                                Description:         "Kubernetes Apiserver editable params",
                                MarkdownDescription: "Kubernetes Apiserver editable params",
                                Attributes: map[string]schema.Attribute{
                                        "params": schema.MapAttribute{
                                                ElementType:         types.StringType,
                                                Optional:            true,
                                                Description:         "Map of Kubernetes Apiserver params in case the terraform provider does not already abstracts them",
                                                MarkdownDescription: "Map of Kubernetes Apiserver params in case the terraform provider does not already abstracts them",
                                        },
                                        "audit": schema.SingleNestedAttribute{
                                                MarkdownDescription: "Kubernetes audit logs specification files",
                                                Computed:            true,
                                                Attributes: map[string]schema.Attribute{
                                                        "webhook_config": schema.StringAttribute{
                                                                MarkdownDescription: "YAML manifest for audit webhook config",
                                                                Computed:            true,
                                                        },
                                                        "policy": schema.StringAttribute{
                                                                MarkdownDescription: "YAML manifest for audit policy",
                                                                Computed:            true,
                                                        },
                                                },
                                        },
                                        "oidc": schema.SingleNestedAttribute{
                                                Description:         "OIDC specific Apiserver params",
                                                MarkdownDescription: "OIDC specific Apiserver params",
                                                Computed:            true,
                                                Attributes: map[string]schema.Attribute{
                                                        "ca": schema.StringAttribute{
                                                                Computed:            true,
                                                                Description:         "OIDC Ca Certificate",
                                                                MarkdownDescription: "OIDC Ca Certificate",
                                                        },
                                                        "groups_claim": schema.StringAttribute{
                                                                Computed:            true,
                                                                MarkdownDescription: "OIDC groups claim",
                                                        },
                                                        "groups_prefix": schema.StringAttribute{
                                                                Computed:            true,
                                                                MarkdownDescription: "OIDC groups prefix",
                                                        },
                                                        "issuer_url": schema.StringAttribute{
                                                                Computed:            true,
                                                                Description:         "OIDC issuer URL",
                                                                MarkdownDescription: "OIDC issuer URL",
                                                        },
                                                        "client_id": schema.StringAttribute{
                                                                Computed:            true,
                                                                Description:         "OIDC client identifier",
                                                                MarkdownDescription: "OIDC client identifier",
                                                        },
                                                        "username_claim": schema.StringAttribute{
                                                                Optional:            true,
                                                                Description:         "OIDC username claim",
                                                                MarkdownDescription: "OIDC username claim",
                                                        },
                                                        "username_prefix": schema.StringAttribute{
                                                                Computed:            true,
                                                                Description:         "OIDC username prefix",
                                                                MarkdownDescription: "OIDC username prefix",
                                                        },
                                                        "required_claim": schema.StringAttribute{
                                                                Computed: true,
                                                                MarkdownDescription: "A key=value pair that describes a required claim in the ID Token.",
                                                        },
                                                        "signing_algs": schema.StringAttribute{
                                                                Computed:            true,
                                                                Description:         "OIDC signing algorithm. Kubernetes will default it to RS256",
                                                                MarkdownDescription: "OIDC signing algorithm. Kubernetes will default it to RS256",
                                                        },
                                                },
                                        },
                                },
                                Optional: true,
                        },
                },
                MarkdownDescription: "The kaas data source allows the user to manage a kaas project",
        }
}</span>

// Read refreshes the Terraform state with the latest data.
func (d *kaasDataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) <span class="cov0" title="0">{
        var data KaasModel

        resp.Diagnostics.Append(req.Config.Get(ctx, &amp;data)...)

        obj, err := d.client.Kaas.GetKaas(
                int(data.PublicCloudId.ValueInt64()),
                int(data.PublicCloudProjectId.ValueInt64()),
                int(data.Id.ValueInt64()),
        )
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unable to find KaaS",
                        err.Error(),
                )
                return
        }</span>

        <span class="cov0" title="0">kubeconfig, err := d.client.Kaas.GetKubeconfig(
                int(data.PublicCloudId.ValueInt64()),
                int(data.PublicCloudProjectId.ValueInt64()),
                int(data.Id.ValueInt64()),
        )
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unable to get kubeconfig from KaaS",
                        err.Error(),
                )
                return
        }</span>

        <span class="cov0" title="0">data.Kubeconfig = types.StringValue(kubeconfig)
        data.Region = types.StringValue(obj.Region)
        data.KubernetesVersion = types.StringValue(obj.KubernetesVersion)

        apiserverParams, err := d.client.Kaas.GetApiserverParams(
                int(data.PublicCloudId.ValueInt64()),
                int(data.PublicCloudProjectId.ValueInt64()),
                int(data.Id.ValueInt64()),
        )
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unable to get Oidc from KaaS",
                        err.Error(),
                )
                return
        }</span>

        <span class="cov0" title="0">if apiserverParams != nil </span><span class="cov0" title="0">{
                data.fillApiserverState(ctx, apiserverParams)
        }</span>

        // Set state
        <span class="cov0" title="0">diags := resp.State.Set(ctx, &amp;data)
        resp.Diagnostics.Append(diags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>
}

// Metadata returns the data source type name.
func (d *kaasDataSource) Metadata(_ context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) <span class="cov8" title="158">{
        resp.TypeName = req.ProviderTypeName + "_kaas"
}</span>
</pre>
		
		<pre class="file" id="file27" style="display: none">package kaas

import (
        "context"
        "terraform-provider-infomaniak/internal/apis"
        "terraform-provider-infomaniak/internal/provider"

        "github.com/hashicorp/terraform-plugin-framework/datasource"
        "github.com/hashicorp/terraform-plugin-framework/datasource/schema"
        "github.com/hashicorp/terraform-plugin-framework/types"
)

// Ensure the implementation satisfies the expected interfaces.
var (
        _ datasource.DataSource              = &amp;kaasInstancePoolDataSource{}
        _ datasource.DataSourceWithConfigure = &amp;kaasInstancePoolDataSource{}
)

type kaasInstancePoolDataSource struct {
        client *apis.Client
}

// NewKaasInstancePoolDataSource is a helper function to simplify the provider implementation.
func NewKaasInstancePoolDataSource() datasource.DataSource <span class="cov10" title="330">{
        return &amp;kaasInstancePoolDataSource{}
}</span>

// Configure adds the provider configured client to the data source.
func (d *kaasInstancePoolDataSource) Configure(_ context.Context, req datasource.ConfigureRequest, resp *datasource.ConfigureResponse) <span class="cov5" title="14">{
        // Add a nil check when handling ProviderData because Terraform
        // sets that data after it calls the ConfigureProvider RPC.
        if req.ProviderData == nil </span><span class="cov4" title="8">{
                return
        }</span>

        <span class="cov3" title="6">client, err := provider.GetApiClient(req.ProviderData)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unexpected Data Source Configure Type",
                        err.Error(),
                )
                return
        }</span>

        <span class="cov3" title="6">d.client = client</span>
}

// Schema defines the schema for the data source.
func (d *kaasInstancePoolDataSource) Schema(ctx context.Context, _ datasource.SchemaRequest, resp *datasource.SchemaResponse) <span class="cov8" title="158">{
        resp.Schema = schema.Schema{
                Attributes: map[string]schema.Attribute{
                        "public_cloud_id": schema.Int64Attribute{
                                Required:    true,
                                Description: "The id of the public cloud project where KaaS is installed",
                        },
                        "public_cloud_project_id": schema.Int64Attribute{
                                Required:    true,
                                Description: "The id of the public cloud project where KaaS is installed",
                        },
                        "kaas_id": schema.Int64Attribute{
                                Required:    true,
                                Description: "The id of the kaas project.",
                        },
                        "id": schema.Int64Attribute{
                                Required:    true,
                                Description: "A computed value representing the unique identifier for the architecture. Mandatory for acceptance testing.",
                        },
                        "name": schema.StringAttribute{
                                Computed:    true,
                                Description: "The name of this instance pool",
                        },
                        "availability_zone": schema.StringAttribute{
                                Computed:            true,
                                Description:         "The availability zone for the instances in the pool",
                                MarkdownDescription: "The availability zone for the instances in the pool",
                        },
                        "flavor_name": schema.StringAttribute{
                                Computed:    true,
                                Description: "The flavor name of the instance in this instance pool",
                        },
                        "min_instances": schema.Int32Attribute{
                                Computed:    true,
                                Description: "The minimum amount of instances in the instance pool",
                        },
                        "max_instances": schema.Int32Attribute{
                                Computed:    true,
                                Description: "The maximum amount of instances in the instance pool",
                        },
                        "labels": schema.MapAttribute{
                                ElementType: types.StringType,
                                Computed:    true,
                                Description: "Kubernetes node labels",
                        },
                },
                MarkdownDescription: "The KaaS Instance Pool data source retrieves information about a KaaS instance pool.",
        }
}</span>

// Read refreshes the Terraform state with the latest data.
func (d *kaasInstancePoolDataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) <span class="cov2" title="3">{
        var data KaasInstancePoolModel

        resp.Diagnostics.Append(req.Config.Get(ctx, &amp;data)...)

        obj, err := d.client.Kaas.GetInstancePool(
                int(data.PublicCloudId.ValueInt64()),
                int(data.PublicCloudProjectId.ValueInt64()),
                int(data.KaasId.ValueInt64()),
                int(data.Id.ValueInt64()),
        )
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unable to find KaaS instance pool",
                        err.Error(),
                )
                return
        }</span>

        <span class="cov2" title="3">data.Id = types.Int64Value(int64(obj.Id))
        data.Name = types.StringValue(obj.Name)
        data.FlavorName = types.StringValue(obj.FlavorName)
        data.MinInstances = types.Int32Value(obj.MinInstances)
        data.MaxInstances = types.Int32Value(obj.MaxInstances)
        labels, diags := types.MapValueFrom(ctx, types.StringType, obj.Labels)
        resp.Diagnostics.Append(diags...)
        data.Labels = labels

        // Set state
        diags = resp.State.Set(ctx, &amp;data)
        resp.Diagnostics.Append(diags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>
}

// Metadata returns the data source type name.
func (d *kaasInstancePoolDataSource) Metadata(_ context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) <span class="cov8" title="158">{
        resp.TypeName = req.ProviderTypeName + "_kaas_instance_pool"
}</span>
</pre>
		
		<pre class="file" id="file28" style="display: none">package kaas

import (
        "context"
        "errors"
        "fmt"
        "strconv"
        "strings"
        "terraform-provider-infomaniak/internal/apis"
        "terraform-provider-infomaniak/internal/apis/kaas"
        "terraform-provider-infomaniak/internal/provider"
        "time"

        "github.com/hashicorp/terraform-plugin-framework/resource/schema/mapplanmodifier"

        "github.com/hashicorp/terraform-plugin-framework/path"
        "github.com/hashicorp/terraform-plugin-framework/resource"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/int32planmodifier"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/int64planmodifier"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
        "github.com/hashicorp/terraform-plugin-framework/types"
)

var (
        _ resource.Resource              = &amp;kaasInstancePoolResource{}
        _ resource.ResourceWithConfigure = &amp;kaasInstancePoolResource{}
)

func NewKaasInstancePoolResource() resource.Resource <span class="cov10" title="724">{
        return &amp;kaasInstancePoolResource{}
}</span>

type kaasInstancePoolResource struct {
        client *apis.Client
}

type KaasInstancePoolModel struct {
        PublicCloudId        types.Int64 `tfsdk:"public_cloud_id"`
        PublicCloudProjectId types.Int64 `tfsdk:"public_cloud_project_id"`
        KaasId               types.Int64 `tfsdk:"kaas_id"`
        Id                   types.Int64 `tfsdk:"id"`

        Name             types.String `tfsdk:"name"`
        AvailabilityZone types.String `tfsdk:"availability_zone"`
        FlavorName       types.String `tfsdk:"flavor_name"`
        MinInstances     types.Int32  `tfsdk:"min_instances"`
        MaxInstances     types.Int32  `tfsdk:"max_instances"`
        Labels           types.Map    `tfsdk:"labels"`
}

func (r *kaasInstancePoolResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) <span class="cov9" title="355">{
        resp.TypeName = req.ProviderTypeName + "_kaas_instance_pool"
}</span>

// Configure adds the provider configured client to the data source.
func (r *kaasInstancePoolResource) Configure(_ context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) <span class="cov7" title="123">{
        // Add a nil check when handling ProviderData because Terraform
        // sets that data after it calls the ConfigureProvider RPC.
        if req.ProviderData == nil </span><span class="cov5" title="34">{
                return
        }</span>

        <span class="cov7" title="89">client, err := provider.GetApiClient(req.ProviderData)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unexpected Resource Configure Type",
                        err.Error(),
                )
                return
        }</span>

        <span class="cov7" title="89">r.client = client</span>
}

func (r *kaasInstancePoolResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) <span class="cov8" title="219">{
        resp.Schema = schema.Schema{
                Attributes: map[string]schema.Attribute{
                        "public_cloud_id": schema.Int64Attribute{
                                Required:            true,
                                Description:         "The id of the public cloud where KaaS is installed",
                                MarkdownDescription: "The id of the public cloud where KaaS is installed",
                                PlanModifiers: []planmodifier.Int64{
                                        int64planmodifier.RequiresReplace(),
                                },
                        },
                        "public_cloud_project_id": schema.Int64Attribute{
                                Required:            true,
                                Description:         "The id of the public cloud project where KaaS is installed",
                                MarkdownDescription: "The id of the public cloud project where KaaS is installed",
                                PlanModifiers: []planmodifier.Int64{
                                        int64planmodifier.RequiresReplace(),
                                },
                        },
                        "kaas_id": schema.Int64Attribute{
                                Required:            true,
                                Description:         "The id of the kaas project.",
                                MarkdownDescription: "The id of the kaas project.",
                                PlanModifiers: []planmodifier.Int64{
                                        int64planmodifier.RequiresReplace(),
                                },
                        },
                        "id": schema.Int64Attribute{
                                Computed:            true,
                                Description:         "A computed value representing the unique identifier for the architecture. Mandatory for acceptance testing.",
                                MarkdownDescription: "A computed value representing the unique identifier for the architecture. Mandatory for acceptance testing.",
                                PlanModifiers: []planmodifier.Int64{
                                        int64planmodifier.UseStateForUnknown(),
                                },
                        },
                        "name": schema.StringAttribute{
                                Required:            true,
                                Description:         "The name of the instance pool",
                                MarkdownDescription: "The name of the instance pool",
                                PlanModifiers: []planmodifier.String{
                                        stringplanmodifier.UseStateForUnknown(),
                                },
                        },
                        "availability_zone": schema.StringAttribute{
                                Required:            true,
                                Description:         "The availability zone for the instances in the pool",
                                MarkdownDescription: "The availability zone for the instances in the pool",
                                PlanModifiers: []planmodifier.String{
                                        stringplanmodifier.RequiresReplace(),
                                },
                        },
                        "flavor_name": schema.StringAttribute{
                                Required:            true,
                                Description:         "The flavor name for the instances in the pool",
                                MarkdownDescription: "The flavor name for the instances in the pool",
                                PlanModifiers: []planmodifier.String{
                                        stringplanmodifier.RequiresReplace(),
                                },
                        },
                        "min_instances": schema.Int32Attribute{
                                Required:            true,
                                Description:         "The minimum amount of instances in this instance pool",
                                MarkdownDescription: "The minimum amount of instances in this instance pool",
                                PlanModifiers: []planmodifier.Int32{
                                        int32planmodifier.UseStateForUnknown(),
                                },
                        },
                        "max_instances": schema.Int32Attribute{
                                Required:            true,
                                Description:         "The maximum amount of instances in this instance pool",
                                MarkdownDescription: "The maximum amount of instances in this instance pool",
                                PlanModifiers: []planmodifier.Int32{
                                        int32planmodifier.UseStateForUnknown(),
                                },
                        },
                        "labels": schema.MapAttribute{
                                ElementType: types.StringType,
                                Optional:    true,
                                PlanModifiers: []planmodifier.Map{
                                        mapplanmodifier.UseStateForUnknown(),
                                        mapplanmodifier.RequiresReplace(),
                                },
                                Description:         "Kubernetes labels to apply to the instances. The label must have a prefix of node-role.kubernetes.io or belong to the domains node-restriction.kubernetes.io or custom.kaas.infomaniak.cloud.",
                                MarkdownDescription: "Kubernetes labels to apply to the instances. The label must have a prefix of node-role.kubernetes.io or belong to the domains node-restriction.kubernetes.io or custom.kaas.infomaniak.cloud.",
                        },
                },
                MarkdownDescription: "The kaas instance pool resource is used to manage instance pools inside a kaas project",
        }
}</span>

func (r *kaasInstancePoolResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) <span class="cov3" title="7">{
        var data KaasInstancePoolModel

        // Read Terraform plan data into the model
        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)

        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov3" title="7">input := &amp;kaas.InstancePool{
                KaasId:           int(data.KaasId.ValueInt64()),
                Name:             data.Name.ValueString(),
                AvailabilityZone: data.AvailabilityZone.ValueString(),
                FlavorName:       data.FlavorName.ValueString(),
                MinInstances:     data.MinInstances.ValueInt32(),
                MaxInstances:     data.MaxInstances.ValueInt32(),
                Labels:           r.getLabelsValues(data),
        }

        // CreateKaas API call logic
        instancePoolId, err := r.client.Kaas.CreateInstancePool(
                int(data.PublicCloudId.ValueInt64()),
                int(data.PublicCloudProjectId.ValueInt64()),
                input,
        )
        if err != nil </span><span class="cov1" title="1">{
                resp.Diagnostics.AddError(
                        "Error when creating KaaS instance pool",
                        err.Error(),
                )
                return
        }</span>

        <span class="cov3" title="6">data.Id = types.Int64Value(int64(instancePoolId))
        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)

        isScalingDown := false
        instancePoolObject, err := r.waitUntilActive(ctx, data, instancePoolId, isScalingDown)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error when waiting for KaaS Instance Pool to be Active",
                        err.Error(),
                )
                return
        }</span>

        <span class="cov3" title="6">if instancePoolObject == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov3" title="6">data.fill(instancePoolObject)

        // Save data into Terraform state
        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *kaasInstancePoolResource) getLabelsValues(data KaasInstancePoolModel) map[string]string <span class="cov3" title="7">{
        labels := make(map[string]string)

        if !data.Labels.IsNull() &amp;&amp; !data.Labels.IsUnknown() </span><span class="cov0" title="0">{
                for key, val := range data.Labels.Elements() </span><span class="cov0" title="0">{
                        if strVal, ok := val.(types.String); ok &amp;&amp; !strVal.IsNull() &amp;&amp; !strVal.IsUnknown() </span><span class="cov0" title="0">{
                                labels[key] = strVal.ValueString()
                        }</span>
                }
        }

        <span class="cov3" title="7">return labels</span>
}

func (r *kaasInstancePoolResource) waitUntilActive(ctx context.Context, data KaasInstancePoolModel, id int, scalingDown bool) (*kaas.InstancePool, error) <span class="cov3" title="6">{
        scaleDownFailedQuotaCount := 0
        scaleDownFailedQuotaAllowedRetrys := 5
        ticker := time.NewTicker(5 * time.Second)
        for </span><span class="cov3" title="6">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return nil, nil</span>
                case &lt;-ticker.C:<span class="cov3" title="6">
                        found, err := r.client.Kaas.GetInstancePool(
                                int(data.PublicCloudId.ValueInt64()),
                                int(data.PublicCloudProjectId.ValueInt64()),
                                int(data.KaasId.ValueInt64()),
                                id,
                        )
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>

                        <span class="cov3" title="6">if len(found.ErrorMessages) &gt; 0 </span><span class="cov0" title="0">{
                                // Special case when we hit quota failure but we are scaling down. OpenStack can take some time to update so we let him do his work
                                if (found.Status == "ScalingDown" || scalingDown) &amp;&amp; scaleDownFailedQuotaCount &lt;= scaleDownFailedQuotaAllowedRetrys </span><span class="cov0" title="0">{
                                        scaleDownFailedQuotaCount++
                                        continue</span>
                                }
                                <span class="cov0" title="0">return nil, errors.New(strings.Join(found.ErrorMessages, ","))</span>
                        }

                        // We need the instance pool to be active, have the same state as us, be scaled properly and be in bound of the autoscaling
                        <span class="cov3" title="6">isActive := found.Status == "Active"
                        isEquivalent := found.MinInstances == data.MinInstances.ValueInt32()
                        isScaledProperly := found.AvailableInstances == found.TargetInstances
                        isInBound := found.MinInstances &lt;= found.TargetInstances &amp;&amp; found.TargetInstances &lt;= found.MaxInstances
                        if isActive &amp;&amp; isEquivalent &amp;&amp; isScaledProperly &amp;&amp; isInBound </span><span class="cov3" title="6">{
                                return found, nil
                        }</span>
                }
        }
}

func (r *kaasInstancePoolResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) <span class="cov4" title="11">{
        var data KaasInstancePoolModel

        // Read Terraform prior state data into the model
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;data)...)

        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // Read API call logic
        <span class="cov4" title="11">obj, err := r.client.Kaas.GetInstancePool(
                int(data.PublicCloudId.ValueInt64()),
                int(data.PublicCloudProjectId.ValueInt64()),
                int(data.KaasId.ValueInt64()),
                int(data.Id.ValueInt64()),
        )
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error when reading KaaS Instance Pool",
                        err.Error(),
                )
                return
        }</span>

        <span class="cov4" title="11">if len(obj.ErrorMessages) &gt; 0 </span><span class="cov0" title="0">{
                resp.Diagnostics.AddWarning(
                        "KaaS was in error state:",
                        strings.Join(obj.ErrorMessages, ","),
                )
        }</span>

        <span class="cov4" title="11">data.fill(obj)

        // Save updated data into Terraform state
        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *kaasInstancePoolResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) <span class="cov0" title="0">{
        var state KaasInstancePoolModel
        var data KaasInstancePoolModel

        // Read Terraform plan data into the model
        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;state)...)

        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // Update API call logic
        <span class="cov0" title="0">input := &amp;kaas.InstancePool{
                KaasId: int(data.KaasId.ValueInt64()),
                Id:     int(state.Id.ValueInt64()),

                Name:         data.Name.ValueString(),
                FlavorName:   data.FlavorName.ValueString(),
                MinInstances: data.MinInstances.ValueInt32(),
                MaxInstances: data.MaxInstances.ValueInt32(),
                Labels:       r.getLabelsValues(data),
        }

        _, err := r.client.Kaas.UpdateInstancePool(
                int(data.PublicCloudId.ValueInt64()),
                int(data.PublicCloudProjectId.ValueInt64()),
                input,
        )
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error when updating KaaS Instance Pool",
                        err.Error(),
                )
                return
        }</span>

        <span class="cov0" title="0">scalingDown := data.MaxInstances.ValueInt32() &lt; state.MaxInstances.ValueInt32()
        instancePoolObject, err := r.waitUntilActive(ctx, data, int(state.Id.ValueInt64()), scalingDown)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error when waiting for KaaS Instance Pool to be Active",
                        err.Error(),
                )
                return
        }</span>

        <span class="cov0" title="0">if instancePoolObject == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">data.fill(instancePoolObject)

        // Save updated data into Terraform state
        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *kaasInstancePoolResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) <span class="cov3" title="6">{
        var data KaasInstancePoolModel

        // Read Terraform prior state data into the model
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;data)...)

        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // DeleteKaas API call logic
        <span class="cov3" title="6">_, err := r.client.Kaas.DeleteInstancePool(
                int(data.PublicCloudId.ValueInt64()),
                int(data.PublicCloudProjectId.ValueInt64()),
                int(data.KaasId.ValueInt64()),
                int(data.Id.ValueInt64()),
        )
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error when deleting KaaS",
                        err.Error(),
                )
                return
        }</span>
}

func (r *kaasInstancePoolResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) <span class="cov1" title="1">{
        idParts := strings.Split(req.ID, ",")

        if len(idParts) != 4 || idParts[0] == "" || idParts[1] == "" || idParts[2] == "" || idParts[3] == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unexpected Import Identifier",
                        fmt.Sprintf("Expected import identifier with format: public_cloud_id,public_cloud_project_id,kaas_id,id. Got: %q", req.ID),
                )
                return
        }</span>

        <span class="cov1" title="1">var errorList error

        publicCloudId, err := strconv.ParseInt(idParts[0], 10, 64)
        errorList = errors.Join(errorList, err)
        publicCloudProjectId, err := strconv.ParseInt(idParts[1], 10, 64)
        errorList = errors.Join(errorList, err)
        kaasId, err := strconv.ParseInt(idParts[2], 10, 64)
        errorList = errors.Join(errorList, err)
        instancePoolId, err := strconv.ParseInt(idParts[3], 10, 64)
        errorList = errors.Join(errorList, err)

        if errorList != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unexpected Import Identifier",
                        fmt.Sprintf("Expected import identifier with format: public_cloud_id,public_cloud_project_id,kaas_id,id. Got: %q", req.ID),
                )
                return
        }</span>

        <span class="cov1" title="1">resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("public_cloud_id"), publicCloudId)...)
        resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("public_cloud_project_id"), publicCloudProjectId)...)
        resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("kaas_id"), kaasId)...)
        resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("id"), instancePoolId)...)</span>
}

func (model *KaasInstancePoolModel) fill(instancePool *kaas.InstancePool) <span class="cov4" title="17">{
        model.Id = types.Int64Value(int64(instancePool.Id))
        model.Name = types.StringValue(instancePool.Name)
        model.FlavorName = types.StringValue(instancePool.FlavorName)
        model.MinInstances = types.Int32Value(instancePool.MinInstances)
        model.MaxInstances = types.Int32Value(instancePool.MaxInstances)
        model.AvailabilityZone = types.StringValue(instancePool.AvailabilityZone)
}</span>
</pre>
		
		<pre class="file" id="file29" style="display: none">package kaas

import (
        "context"
        "errors"
        "fmt"
        "strconv"
        "strings"
        "terraform-provider-infomaniak/internal/apis"
        "terraform-provider-infomaniak/internal/apis/kaas"
        "terraform-provider-infomaniak/internal/provider"
        "time"

        "github.com/hashicorp/terraform-plugin-framework/diag"
        "github.com/hashicorp/terraform-plugin-framework/path"
        "github.com/hashicorp/terraform-plugin-framework/resource"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/int64planmodifier"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/mapplanmodifier"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/objectplanmodifier"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"

        "github.com/hashicorp/terraform-plugin-framework/types"
)

var (
        _ resource.Resource                = &amp;kaasResource{}
        _ resource.ResourceWithConfigure   = &amp;kaasResource{}
        _ resource.ResourceWithImportState = &amp;kaasResource{}
)

func NewKaasResource() resource.Resource <span class="cov10" title="933">{
        return &amp;kaasResource{}
}</span>

type kaasResource struct {
        client *apis.Client
}

type KaasModel struct {
        PublicCloudId        types.Int64 `tfsdk:"public_cloud_id"`
        PublicCloudProjectId types.Int64 `tfsdk:"public_cloud_project_id"`
        Id                   types.Int64 `tfsdk:"id"`

        Name              types.String    `tfsdk:"name"`
        PackName          types.String    `tfsdk:"pack_name"`
        Region            types.String    `tfsdk:"region"`
        Kubeconfig        types.String    `tfsdk:"kubeconfig"`
        KubernetesVersion types.String    `tfsdk:"kubernetes_version"`
        Apiserver         *ApiserverModel `tfsdk:"apiserver"`
}

func (m *KaasModel) SetDefaultValues(ctx context.Context) <span class="cov0" title="0">{
        if m.Apiserver == nil </span><span class="cov0" title="0">{
                defaultParams, _ := types.MapValueFrom(ctx, types.StringType, map[string]string{})
                m.Apiserver = &amp;ApiserverModel{
                        Params: defaultParams,
                }
        }</span>
        <span class="cov0" title="0">if m.Apiserver.Audit == nil </span><span class="cov0" title="0">{
                m.Apiserver.Audit = &amp;Audit{}
        }</span>
        <span class="cov0" title="0">if m.Apiserver.Oidc == nil </span><span class="cov0" title="0">{
                m.Apiserver.Oidc = &amp;OidcModel{}
        }</span>
}

type ApiserverModel struct {
        Params types.Map  `tfsdk:"params"`
        Oidc   *OidcModel `tfsdk:"oidc"`
        Audit  *Audit     `tfsdk:"audit"`
}

type OidcModel struct {
        IssuerUrl      types.String `tfsdk:"issuer_url"`
        ClientId       types.String `tfsdk:"client_id"`
        UsernameClaim  types.String `tfsdk:"username_claim"`
        UsernamePrefix types.String `tfsdk:"username_prefix"`
        SigningAlgs    types.String `tfsdk:"signing_algs"`
        GroupsClaim    types.String `tfsdk:"groups_claim"`
        GroupsPrefix   types.String `tfsdk:"groups_prefix"`
        RequiredClaim  types.String `tfsdk:"required_claim"`
        Ca             types.String `tfsdk:"ca"`
}

type Audit struct {
        WebhookConfig types.String `tfsdk:"webhook_config"`
        Policy        types.String `tfsdk:"policy"`
}

func (r *kaasResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) <span class="cov8" title="355">{
        resp.TypeName = req.ProviderTypeName + "_kaas"
}</span>

// Configure adds the provider configured client to the data source.
func (r *kaasResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) <span class="cov8" title="235">{
        // Add a nil check when handling ProviderData because Terraform
        // sets that data after it calls the ConfigureProvider RPC.
        if req.ProviderData == nil </span><span class="cov6" title="67">{
                return
        }</span>

        <span class="cov7" title="168">client, err := provider.GetApiClient(req.ProviderData)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unexpected Resource Configure Type",
                        err.Error(),
                )
                return
        }</span>

        <span class="cov7" title="168">r.client = client</span>
}

func (r *kaasResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) <span class="cov8" title="288">{
        resp.Schema = schema.Schema{
                Attributes: map[string]schema.Attribute{
                        "public_cloud_id": schema.Int64Attribute{
                                Required:            true,
                                Description:         "The id of the public cloud where KaaS is installed",
                                MarkdownDescription: "The id of the public cloud where KaaS is installed",
                                PlanModifiers: []planmodifier.Int64{
                                        int64planmodifier.RequiresReplace(),
                                },
                        },
                        "public_cloud_project_id": schema.Int64Attribute{
                                Required:            true,
                                Description:         "The id of the public cloud project where KaaS is installed",
                                MarkdownDescription: "The id of the public cloud project where KaaS is installed",
                                PlanModifiers: []planmodifier.Int64{
                                        int64planmodifier.RequiresReplace(),
                                },
                        },
                        "pack_name": schema.StringAttribute{
                                Required:            true,
                                Description:         "The name of the pack associated to the KaaS project",
                                MarkdownDescription: "The name of the pack associated to the KaaS project",
                                PlanModifiers: []planmodifier.String{
                                        stringplanmodifier.RequiresReplace(),
                                },
                        },
                        "kubernetes_version": schema.StringAttribute{
                                Required:            true,
                                Description:         "The version of Kubernetes associated with the KaaS being installed",
                                MarkdownDescription: "The version of Kubernetes associated with the KaaS being installed",
                                PlanModifiers: []planmodifier.String{
                                        stringplanmodifier.UseStateForUnknown(),
                                },
                        },
                        "name": schema.StringAttribute{
                                Required:            true,
                                Description:         "The name of the KaaS project",
                                MarkdownDescription: "The name of the KaaS project",
                                PlanModifiers: []planmodifier.String{
                                        stringplanmodifier.UseStateForUnknown(),
                                },
                        },
                        "id": schema.Int64Attribute{
                                Computed:            true,
                                Description:         "A computed value representing the unique identifier for the architecture. Mandatory for acceptance testing.",
                                MarkdownDescription: "A computed value representing the unique identifier for the architecture. Mandatory for acceptance testing.",
                                PlanModifiers: []planmodifier.Int64{
                                        int64planmodifier.UseStateForUnknown(),
                                },
                        },
                        "region": schema.StringAttribute{
                                Required:            true,
                                Description:         "The region where the KaaS will reside.",
                                MarkdownDescription: "The region where the KaaS will reside.",
                                PlanModifiers: []planmodifier.String{
                                        stringplanmodifier.RequiresReplace(),
                                        stringplanmodifier.UseStateForUnknown(),
                                },
                        },
                        "kubeconfig": schema.StringAttribute{
                                Computed:            true,
                                Sensitive:           true,
                                Description:         "The kubeconfig generated to access to KaaS project",
                                MarkdownDescription: "The kubeconfig generated to access to KaaS project",
                        },
                        "apiserver": schema.SingleNestedAttribute{
                                MarkdownDescription: "Kubernetes Apiserver editable params",
                                Attributes: map[string]schema.Attribute{
                                        "params": schema.MapAttribute{
                                                Optional:            true,
                                                ElementType:         types.StringType,
                                                MarkdownDescription: "Map of Kubernetes Apiserver params in case the terraform provider does not already abstracts them",
                                                PlanModifiers: []planmodifier.Map{
                                                        mapplanmodifier.UseStateForUnknown(),
                                                },
                                        },
                                        "audit": schema.SingleNestedAttribute{
                                                MarkdownDescription: "Kubernetes audit logs specification files",
                                                Optional:            true,
                                                PlanModifiers: []planmodifier.Object{
                                                        objectplanmodifier.UseStateForUnknown(),
                                                },
                                                Attributes: map[string]schema.Attribute{
                                                        "webhook_config": schema.StringAttribute{
                                                                MarkdownDescription: "YAML manifest for audit webhook config",
                                                                Optional:            true,
                                                                PlanModifiers: []planmodifier.String{
                                                                        stringplanmodifier.UseStateForUnknown(),
                                                                },
                                                        },
                                                        "policy": schema.StringAttribute{
                                                                MarkdownDescription: "YAML manifest for audit policy",
                                                                Optional:            true,
                                                                PlanModifiers: []planmodifier.String{
                                                                        stringplanmodifier.UseStateForUnknown(),
                                                                },
                                                        },
                                                },
                                        },
                                        "oidc": schema.SingleNestedAttribute{
                                                MarkdownDescription: "OIDC specific Apiserver params",
                                                Optional:            true,
                                                Attributes: map[string]schema.Attribute{
                                                        "ca": schema.StringAttribute{
                                                                Optional: true,
                                                                PlanModifiers: []planmodifier.String{
                                                                        stringplanmodifier.UseStateForUnknown(),
                                                                },
                                                                MarkdownDescription: "OIDC Ca Certificate",
                                                        },
                                                        "groups_claim": schema.StringAttribute{
                                                                Optional: true,
                                                                PlanModifiers: []planmodifier.String{
                                                                        stringplanmodifier.UseStateForUnknown(),
                                                                },
                                                                MarkdownDescription: "OIDC groups claim",
                                                        },
                                                        "groups_prefix": schema.StringAttribute{
                                                                Optional: true,
                                                                PlanModifiers: []planmodifier.String{
                                                                        stringplanmodifier.UseStateForUnknown(),
                                                                },
                                                                MarkdownDescription: "OIDC groups prefix",
                                                        },
                                                        "issuer_url": schema.StringAttribute{
                                                                Optional: true,
                                                                PlanModifiers: []planmodifier.String{
                                                                        stringplanmodifier.UseStateForUnknown(),
                                                                },
                                                                MarkdownDescription: "OIDC issuer URL",
                                                        },
                                                        "client_id": schema.StringAttribute{
                                                                Optional: true,
                                                                PlanModifiers: []planmodifier.String{
                                                                        stringplanmodifier.UseStateForUnknown(),
                                                                },
                                                                MarkdownDescription: "OIDC client identifier",
                                                        },
                                                        "username_claim": schema.StringAttribute{
                                                                Optional: true,
                                                                PlanModifiers: []planmodifier.String{
                                                                        stringplanmodifier.UseStateForUnknown(),
                                                                },
                                                                MarkdownDescription: "OIDC username claim",
                                                        },
                                                        "username_prefix": schema.StringAttribute{
                                                                Optional: true,
                                                                PlanModifiers: []planmodifier.String{
                                                                        stringplanmodifier.UseStateForUnknown(),
                                                                },
                                                                MarkdownDescription: "OIDC username prefix",
                                                        },
                                                        "required_claim": schema.StringAttribute{
                                                                Optional: true,
                                                                PlanModifiers: []planmodifier.String{
                                                                        stringplanmodifier.UseStateForUnknown(),
                                                                },
                                                                MarkdownDescription: "A key=value pair that describes a required claim in the ID Token. If set, the claim is verified to be present in the ID Token with a matching value. Repeat this flag to specify multiple claims.",
                                                        },
                                                        "signing_algs": schema.StringAttribute{
                                                                Optional: true,
                                                                PlanModifiers: []planmodifier.String{
                                                                        stringplanmodifier.UseStateForUnknown(),
                                                                },
                                                                MarkdownDescription: "OIDC signing algorithm. Kubernetes will default it to RS256",
                                                        },
                                                },
                                        },
                                },
                                Optional: true,
                        },
                },
                MarkdownDescription: "The kaas resource allows the user to manage a kaas project",
        }
}</span>

func (r *kaasResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) <span class="cov4" title="12">{
        var data KaasModel

        // Read Terraform plan data into the model
        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov4" title="12">chosenPack, err := r.getPackId(data, &amp;resp.Diagnostics)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov4" title="12">input := &amp;kaas.Kaas{
                Project: kaas.KaasProject{
                        PublicCloudId: int(data.PublicCloudId.ValueInt64()),
                        ProjectId:     int(data.PublicCloudProjectId.ValueInt64()),
                },
                Region:            data.Region.ValueString(),
                KubernetesVersion: data.KubernetesVersion.ValueString(),
                Name:              data.Name.ValueString(),
                PackId:            chosenPack.Id,
        }

        // CreateKaas API call logic
        kaasId, err := r.client.Kaas.CreateKaas(input)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error when creating KaaS",
                        err.Error(),
                )
                return
        }</span>

        <span class="cov4" title="12">data.Id = types.Int64Value(int64(kaasId))
        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)

        kaasObject, err := r.waitUntilActive(ctx, input, kaasId)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error when waiting for KaaS to be Active",
                        err.Error(),
                )
                return
        }</span>

        <span class="cov4" title="12">if kaasObject == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov4" title="12">err = r.fetchAndSetKubeconfig(&amp;data, kaasObject)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddWarning("could not fetch and set kubeconfig", err.Error())
        }</span>

        <span class="cov4" title="12">data.fill(kaasObject)

        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)

        if data.Apiserver != nil </span><span class="cov0" title="0">{
                apiserverParamsInput := r.buildApiserverParamsInput(data)
                created, err := r.client.Kaas.PatchApiserverParams(apiserverParamsInput, input.Project.PublicCloudId, input.Project.ProjectId, kaasId)
                if !created || err != nil </span><span class="cov0" title="0">{
                        resp.Diagnostics.AddError(
                                "Error when creating Oidc",
                                err.Error(),
                        )
                        return
                }</span>

                <span class="cov0" title="0">data.fillApiserverState(ctx, apiserverParamsInput)</span>
        }

        // Save data into Terraform state
        <span class="cov4" title="12">resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (state *KaasModel) fillApiserverState(ctx context.Context, apiserverParams *kaas.Apiserver) <span class="cov0" title="0">{
        if state.shouldUpdateApiserver() </span><span class="cov0" title="0">{
                state.SetDefaultValues(ctx)
                state.updateAuditConfig(apiserverParams)
                state.updateOIDCConfig(apiserverParams)
                if state.canSetApiserverToNil() </span><span class="cov0" title="0">{
                        state.Apiserver = nil
                }</span>
        }
}

func (state *KaasModel) shouldUpdateApiserver() bool <span class="cov0" title="0">{
        apiserver := state.Apiserver
        return apiserver != nil &amp;&amp; (apiserver.Audit != nil || apiserver.Oidc != nil || !apiserver.Params.IsNull())
}</span>

func (state *KaasModel) updateAuditConfig(apiserverParams *kaas.Apiserver) <span class="cov0" title="0">{
        if apiserverParams.AuditLogPolicy == nil &amp;&amp; apiserverParams.AuditLogWebhook == nil </span><span class="cov0" title="0">{
                state.Apiserver.Audit = nil
        }</span> else<span class="cov0" title="0"> {
                state.Apiserver.Audit.Policy = types.StringPointerValue(apiserverParams.AuditLogPolicy)
                state.Apiserver.Audit.WebhookConfig = types.StringPointerValue(apiserverParams.AuditLogWebhook)
        }</span>
}

func (state *KaasModel) updateOIDCConfig(apiserverParams *kaas.Apiserver) <span class="cov0" title="0">{
        if apiserverParams.Params != nil </span><span class="cov0" title="0">{
                params := apiserverParams.Params
                state.Apiserver.Oidc = &amp;OidcModel{
                        ClientId:       types.StringPointerValue(params.ClientId),
                        IssuerUrl:      types.StringPointerValue(params.IssuerUrl),
                        UsernameClaim:  types.StringPointerValue(params.UsernameClaim),
                        UsernamePrefix: types.StringPointerValue(params.UsernamePrefix),
                        SigningAlgs:    types.StringPointerValue(params.SigningAlgs),
                        GroupsClaim:    types.StringPointerValue(params.GroupsClaim),
                        GroupsPrefix:   types.StringPointerValue(params.GroupsPrefix),
                        RequiredClaim:  types.StringPointerValue(params.RequiredClaim),
                        Ca:             types.StringPointerValue(apiserverParams.OidcCa),
                }
        }</span> else<span class="cov0" title="0"> {
                state.Apiserver.Oidc = nil
                state.Apiserver.Params = types.MapNull(types.StringType)
        }</span>
}

func (state *KaasModel) canSetApiserverToNil() bool <span class="cov0" title="0">{
        apiserver := state.Apiserver
        return apiserver.Audit == nil &amp;&amp; apiserver.Oidc == nil &amp;&amp; apiserver.Params.IsNull()
}</span>

func (r *kaasResource) waitUntilActive(ctx context.Context, kaas *kaas.Kaas, id int) (*kaas.Kaas, error) <span class="cov4" title="12">{
        for </span><span class="cov4" title="12">{
                found, err := r.client.Kaas.GetKaas(kaas.Project.PublicCloudId, kaas.Project.ProjectId, id)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov4" title="12">if ctx.Err() != nil </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>

                <span class="cov4" title="12">if found.Status == "Active" </span><span class="cov4" title="12">{
                        return found, nil
                }</span>

                <span class="cov0" title="0">time.Sleep(5 * time.Second)</span>
        }
}

func (r *kaasResource) getApiserverParamsValues(data KaasModel) map[string]string <span class="cov0" title="0">{
        params := make(map[string]string)
        if !data.Apiserver.Params.IsNull() &amp;&amp; !data.Apiserver.Params.IsUnknown() </span><span class="cov0" title="0">{
                for key, val := range data.Apiserver.Params.Elements() </span><span class="cov0" title="0">{
                        if strVal, ok := val.(types.String); ok &amp;&amp; !strVal.IsNull() &amp;&amp; !strVal.IsUnknown() </span><span class="cov0" title="0">{
                                params[key] = strVal.ValueString()
                        }</span>
                }
        }

        <span class="cov0" title="0">return params</span>
}

func (r *kaasResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) <span class="cov5" title="21">{
        var state KaasModel

        // Read Terraform plan data into the model
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;state)...)

        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // Read API call logic
        <span class="cov5" title="21">kaasObject, err := r.client.Kaas.GetKaas(
                int(state.PublicCloudId.ValueInt64()),
                int(state.PublicCloudProjectId.ValueInt64()),
                int(state.Id.ValueInt64()),
        )
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error when reading KaaS",
                        err.Error(),
                )
                return
        }</span>

        <span class="cov5" title="21">state.fill(kaasObject)

        err = r.fetchAndSetKubeconfig(&amp;state, kaasObject)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddWarning("could not fetch and set kubeconfig", err.Error())
        }</span>

        <span class="cov5" title="21">apiserverParams, err := r.client.Kaas.GetApiserverParams(int(state.PublicCloudId.ValueInt64()), int(state.PublicCloudProjectId.ValueInt64()), kaasObject.Id)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddWarning(
                        "Could not get Oidc",
                        err.Error(),
                )
        }</span>

        <span class="cov5" title="21">if apiserverParams != nil </span><span class="cov0" title="0">{
                state.fillApiserverState(ctx, apiserverParams)
        }</span>

        // Save updated data into Terraform state
        <span class="cov5" title="21">resp.Diagnostics.Append(resp.State.Set(ctx, &amp;state)...)</span>
}

func (r *kaasResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) <span class="cov0" title="0">{
        var state KaasModel
        var data KaasModel

        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;state)...)

        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">chosenPackState, err := r.getPackId(state, &amp;resp.Diagnostics)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">input := r.prepareUpdateInput(state, data, chosenPackState.Id)

        if _, err := r.client.Kaas.UpdateKaas(input); err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError("Error when updating KaaS", err.Error())
                return
        }</span>

        <span class="cov0" title="0">kaasObject, err := r.waitUntilActive(ctx, input, input.Id)
        if err != nil || kaasObject == nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError("Error waiting for KaaS activation", err.Error())
                return
        }</span>

        <span class="cov0" title="0">err = r.fetchAndSetKubeconfig(&amp;data, kaasObject)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddWarning("could not fetch and set kubeconfig", err.Error())
        }</span>

        <span class="cov0" title="0">data.fill(kaasObject)

        if data.Apiserver != nil </span><span class="cov0" title="0">{
                r.handleApiserverConfig(ctx, &amp;data, input, resp)
        }</span>

        <span class="cov0" title="0">resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *kaasResource) prepareUpdateInput(state, data KaasModel, packID int) *kaas.Kaas <span class="cov0" title="0">{
        input := &amp;kaas.Kaas{
                Project: kaas.KaasProject{
                        PublicCloudId: int(data.PublicCloudId.ValueInt64()),
                        ProjectId:     int(data.PublicCloudProjectId.ValueInt64()),
                },
                Id:                int(state.Id.ValueInt64()),
                Name:              data.Name.ValueString(),
                PackId:            packID,
                Region:            state.Region.ValueString(),
                KubernetesVersion: data.KubernetesVersion.ValueString(),
        }

        if state.KubernetesVersion.ValueString() == data.KubernetesVersion.ValueString() </span><span class="cov0" title="0">{
                input.KubernetesVersion = ""
        }</span>

        <span class="cov0" title="0">return input</span>
}

func (r *kaasResource) fetchAndSetKubeconfig(data *KaasModel, input *kaas.Kaas) error <span class="cov5" title="33">{
        kubeconfig, err := r.client.Kaas.GetKubeconfig(
                input.Project.PublicCloudId,
                input.Project.ProjectId,
                input.Id,
        )
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("could not get kubeconfig: %w", err)
        }</span>
        <span class="cov5" title="33">data.Kubeconfig = types.StringValue(kubeconfig)
        return nil</span>
}

func (r *kaasResource) handleApiserverConfig(ctx context.Context, data *KaasModel, input *kaas.Kaas, resp *resource.UpdateResponse) <span class="cov0" title="0">{
        apiserverParamsInput := r.buildApiserverParamsInput(*data)
        patched, err := r.client.Kaas.PatchApiserverParams(apiserverParamsInput, input.Project.PublicCloudId, input.Project.ProjectId, input.Id)
        if !patched || err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError("Error when patching Apiserver params", err.Error())
                return
        }</span>
        <span class="cov0" title="0">data.fillApiserverState(ctx, apiserverParamsInput)</span>
}

func (r *kaasResource) buildApiserverParamsInput(data KaasModel) *kaas.Apiserver <span class="cov0" title="0">{
        apiserverParamsInput := &amp;kaas.Apiserver{
                NonSpecificApiServerParams: r.getApiserverParamsValues(data),
        }
        if data.Apiserver.Audit != nil </span><span class="cov0" title="0">{
                apiserverParamsInput.AuditLogPolicy = data.Apiserver.Audit.Policy.ValueStringPointer()
                apiserverParamsInput.AuditLogWebhook = data.Apiserver.Audit.WebhookConfig.ValueStringPointer()
        }</span>
        <span class="cov0" title="0">if data.Apiserver.Oidc != nil </span><span class="cov0" title="0">{
                apiserverParamsInput.OidcCa = data.Apiserver.Oidc.Ca.ValueStringPointer()
                apiserverParamsInput.Params = &amp;kaas.ApiServerParams{
                        IssuerUrl:      data.Apiserver.Oidc.IssuerUrl.ValueStringPointer(),
                        ClientId:       data.Apiserver.Oidc.ClientId.ValueStringPointer(),
                        UsernameClaim:  data.Apiserver.Oidc.UsernameClaim.ValueStringPointer(),
                        UsernamePrefix: data.Apiserver.Oidc.UsernamePrefix.ValueStringPointer(),
                        SigningAlgs:    data.Apiserver.Oidc.SigningAlgs.ValueStringPointer(),
                        GroupsClaim:    data.Apiserver.Oidc.GroupsClaim.ValueStringPointer(),
                        GroupsPrefix:   data.Apiserver.Oidc.GroupsPrefix.ValueStringPointer(),
                        RequiredClaim:  data.Apiserver.Oidc.RequiredClaim.ValueStringPointer(),
                }
        }</span>
        <span class="cov0" title="0">return apiserverParamsInput</span>
}

func (r *kaasResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) <span class="cov4" title="12">{
        var data KaasModel

        // Read Terraform prior state data into the model
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;data)...)

        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // DeleteKaas API call logic
        <span class="cov4" title="12">_, err := r.client.Kaas.DeleteKaas(
                int(data.PublicCloudId.ValueInt64()),
                int(data.PublicCloudProjectId.ValueInt64()),
                int(data.Id.ValueInt64()),
        )
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error when deleting KaaS",
                        err.Error(),
                )
                return
        }</span>
}

func (r *kaasResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) <span class="cov1" title="1">{
        idParts := strings.Split(req.ID, ",")

        if len(idParts) != 3 || idParts[0] == "" || idParts[1] == "" || idParts[2] == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unexpected Import Identifier",
                        fmt.Sprintf("Expected import identifier with format: public_cloud_id,public_cloud_project_id,id. Got: %q", req.ID),
                )
                return
        }</span>

        <span class="cov1" title="1">var errorList error

        publicCloudId, err := strconv.ParseInt(idParts[0], 10, 64)
        errorList = errors.Join(errorList, err)
        publicCloudProjectId, err := strconv.ParseInt(idParts[1], 10, 64)
        errorList = errors.Join(errorList, err)
        kaasId, err := strconv.ParseInt(idParts[2], 10, 64)
        errorList = errors.Join(errorList, err)

        if errorList != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unexpected Import Identifier",
                        fmt.Sprintf("Expected import identifier with format: public_cloud_id,public_cloud_project_id,id. Got: %q", req.ID),
                )
                return
        }</span>

        <span class="cov1" title="1">resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("public_cloud_id"), publicCloudId)...)
        resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("public_cloud_project_id"), publicCloudProjectId)...)
        resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("id"), kaasId)...)</span>
}

func (r *kaasResource) getPackId(data KaasModel, diagnostic *diag.Diagnostics) (*kaas.KaasPack, error) <span class="cov4" title="12">{
        packs, err := r.client.Kaas.GetPacks()
        if err != nil </span><span class="cov0" title="0">{
                diagnostic.AddError(
                        "Could not get KaaS Packs",
                        err.Error(),
                )
                return nil, err
        }</span>

        <span class="cov4" title="12">var chosenPack *kaas.KaasPack
        for _, pack := range packs </span><span class="cov4" title="12">{
                if pack.Name == data.PackName.ValueString() </span><span class="cov4" title="12">{
                        chosenPack = pack
                        break</span>
                }
        }

        <span class="cov4" title="12">if chosenPack == nil </span><span class="cov0" title="0">{
                var packNames []string
                for _, pack := range packs </span><span class="cov0" title="0">{
                        packNames = append(packNames, pack.Name)
                }</span>

                <span class="cov0" title="0">diagnostic.AddError(
                        "Unknown KaaS Pack",
                        fmt.Sprintf("pack_name must be one of : %v", packNames),
                )
                return nil, fmt.Errorf("pack name has not been found")</span>
        }

        <span class="cov4" title="12">return chosenPack, nil</span>
}

func (model *KaasModel) fill(kaas *kaas.Kaas) <span class="cov5" title="33">{
        model.Id = types.Int64Value(int64(kaas.Id))
        model.Region = types.StringValue(kaas.Region)
        model.KubernetesVersion = types.StringValue(kaas.KubernetesVersion)
        model.Name = types.StringValue(kaas.Name)
        model.PackName = types.StringValue(kaas.Pack.Name)
}</span>
</pre>
		
		<pre class="file" id="file30" style="display: none">package kaas

import "terraform-provider-infomaniak/internal/provider/registry"

func Register() <span class="cov10" title="295">{
        registry.RegisterResource(NewKaasResource)
        registry.RegisterResource(NewKaasInstancePoolResource)

        registry.RegisterDataSource(NewKaasDataSource)
        registry.RegisterDataSource(NewKaasInstancePoolDataSource)
}</span>
</pre>
		
		<pre class="file" id="file31" style="display: none">package scopes

import (
        "maps"

        "github.com/hashicorp/terraform-plugin-framework/resource/schema"
)

type Scope struct {
        Attributes map[string]schema.Attribute
}

func New(attributes map[string]schema.Attribute) Scope <span class="cov9" title="295">{
        return Scope{
                Attributes: attributes,
        }
}</span>

func (s *Scope) Subscope(attributes map[string]schema.Attribute) Scope <span class="cov10" title="590">{
        var out = make(map[string]schema.Attribute)
        maps.Copy(out, s.Attributes)
        maps.Copy(out, attributes)

        return Scope{
                Attributes: out,
        }
}</span>

func (s *Scope) Build() map[string]schema.Attribute <span class="cov9" title="441">{
        return s.Attributes
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
