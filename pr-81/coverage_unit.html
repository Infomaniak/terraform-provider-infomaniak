
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>apis: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">terraform-provider-infomaniak/internal/apis/client.go (0.0%)</option>
				
				<option value="file1">terraform-provider-infomaniak/internal/apis/dbaas/implementation/client.go (4.3%)</option>
				
				<option value="file2">terraform-provider-infomaniak/internal/apis/dbaas/models.go (0.0%)</option>
				
				<option value="file3">terraform-provider-infomaniak/internal/apis/domain/implementation/client.go (0.0%)</option>
				
				<option value="file4">terraform-provider-infomaniak/internal/apis/domain/models.go (0.0%)</option>
				
				<option value="file5">terraform-provider-infomaniak/internal/apis/helpers/types.go (100.0%)</option>
				
				<option value="file6">terraform-provider-infomaniak/internal/apis/helpers/user_agent.go (0.0%)</option>
				
				<option value="file7">terraform-provider-infomaniak/internal/apis/kaas/implementation/client.go (20.2%)</option>
				
				<option value="file8">terraform-provider-infomaniak/internal/apis/kaas/mock/cache.go (0.0%)</option>
				
				<option value="file9">terraform-provider-infomaniak/internal/apis/kaas/mock/client.go (0.0%)</option>
				
				<option value="file10">terraform-provider-infomaniak/internal/apis/kaas/mock/gen.go (0.0%)</option>
				
				<option value="file11">terraform-provider-infomaniak/internal/apis/kaas/models.go (0.0%)</option>
				
				<option value="file12">terraform-provider-infomaniak/internal/dynamic/dynamic.go (0.0%)</option>
				
				<option value="file13">terraform-provider-infomaniak/internal/dynamic/validator.go (0.0%)</option>
				
				<option value="file14">terraform-provider-infomaniak/internal/provider/provider.go (0.0%)</option>
				
				<option value="file15">terraform-provider-infomaniak/internal/provider/registry/registry.go (0.0%)</option>
				
				<option value="file16">terraform-provider-infomaniak/internal/provider/utils.go (0.0%)</option>
				
				<option value="file17">terraform-provider-infomaniak/internal/services/dbaas/dbaas_backup_schedule_resource.go (0.0%)</option>
				
				<option value="file18">terraform-provider-infomaniak/internal/services/dbaas/dbaas_backup_schedule_resource_schema.go (0.0%)</option>
				
				<option value="file19">terraform-provider-infomaniak/internal/services/dbaas/dbaas_constants_data_source.go (0.0%)</option>
				
				<option value="file20">terraform-provider-infomaniak/internal/services/dbaas/dbaas_constants_data_source_schema.go (0.0%)</option>
				
				<option value="file21">terraform-provider-infomaniak/internal/services/dbaas/dbaas_data_source.go (0.0%)</option>
				
				<option value="file22">terraform-provider-infomaniak/internal/services/dbaas/dbaas_data_source_schema.go (0.0%)</option>
				
				<option value="file23">terraform-provider-infomaniak/internal/services/dbaas/dbaas_migration/state_upgrade_0_to_1.go (0.0%)</option>
				
				<option value="file24">terraform-provider-infomaniak/internal/services/dbaas/dbaas_pack_data_source.go (0.0%)</option>
				
				<option value="file25">terraform-provider-infomaniak/internal/services/dbaas/dbaas_pack_data_source_schema.go (0.0%)</option>
				
				<option value="file26">terraform-provider-infomaniak/internal/services/dbaas/dbaas_resource.go (0.0%)</option>
				
				<option value="file27">terraform-provider-infomaniak/internal/services/dbaas/dbaas_resource_schema.go (0.0%)</option>
				
				<option value="file28">terraform-provider-infomaniak/internal/services/dbaas/register.go (100.0%)</option>
				
				<option value="file29">terraform-provider-infomaniak/internal/services/dbaas/utils.go (0.0%)</option>
				
				<option value="file30">terraform-provider-infomaniak/internal/services/domain/record_raw_target_compute.go (0.0%)</option>
				
				<option value="file31">terraform-provider-infomaniak/internal/services/domain/record_resource.go (0.0%)</option>
				
				<option value="file32">terraform-provider-infomaniak/internal/services/domain/record_resource_schema.go (0.0%)</option>
				
				<option value="file33">terraform-provider-infomaniak/internal/services/domain/register.go (0.0%)</option>
				
				<option value="file34">terraform-provider-infomaniak/internal/services/domain/zone_resource.go (0.0%)</option>
				
				<option value="file35">terraform-provider-infomaniak/internal/services/domain/zone_resource_schema.go (0.0%)</option>
				
				<option value="file36">terraform-provider-infomaniak/internal/services/kaas/kaas_data_source.go (0.0%)</option>
				
				<option value="file37">terraform-provider-infomaniak/internal/services/kaas/kaas_data_source_schema.go (0.0%)</option>
				
				<option value="file38">terraform-provider-infomaniak/internal/services/kaas/kaas_instance_pool_data_source.go (0.0%)</option>
				
				<option value="file39">terraform-provider-infomaniak/internal/services/kaas/kaas_instance_pool_data_source_schema.go (0.0%)</option>
				
				<option value="file40">terraform-provider-infomaniak/internal/services/kaas/kaas_instance_pool_resource.go (0.0%)</option>
				
				<option value="file41">terraform-provider-infomaniak/internal/services/kaas/kaas_instance_pool_resource_schema.go (0.0%)</option>
				
				<option value="file42">terraform-provider-infomaniak/internal/services/kaas/kaas_resource.go (0.0%)</option>
				
				<option value="file43">terraform-provider-infomaniak/internal/services/kaas/kaas_resource_schema.go (0.0%)</option>
				
				<option value="file44">terraform-provider-infomaniak/internal/services/kaas/register.go (100.0%)</option>
				
				<option value="file45">terraform-provider-infomaniak/internal/test/testing.go (0.0%)</option>
				
				<option value="file46">terraform-provider-infomaniak/internal/utils/utils.go (65.2%)</option>
				
				<option value="file47">terraform-provider-infomaniak/main.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package apis

import (
        "terraform-provider-infomaniak/internal/apis/dbaas"
        implem_dbaas "terraform-provider-infomaniak/internal/apis/dbaas/implementation"
        "terraform-provider-infomaniak/internal/apis/domain"
        "terraform-provider-infomaniak/internal/apis/kaas"

        implem_kaas "terraform-provider-infomaniak/internal/apis/kaas/implementation"
        mock_kaas "terraform-provider-infomaniak/internal/apis/kaas/mock"

        implem_domain "terraform-provider-infomaniak/internal/apis/domain/implementation"
)

type Client struct {
        Kaas   kaas.Api
        Domain domain.Api
        DBaas  dbaas.Api
}

// NewMockClient defines the mock client for Infomaniak's API,
// It is used for testing or dryrunning
func NewMockClient() *Client <span class="cov0" title="0">{
        return &amp;Client{
                Kaas: mock_kaas.New(),
        }
}</span>

// NewClient defines the client for Infomaniak's API
func NewClient(baseUri, token, version string) *Client <span class="cov0" title="0">{
        return &amp;Client{
                Kaas:   implem_kaas.New(baseUri, token, version),
                DBaas:  implem_dbaas.New(baseUri, token, version),
                Domain: implem_domain.New(baseUri, token, version),
        }
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package implementation

import (
        "fmt"
        "strconv"
        "strings"
        "terraform-provider-infomaniak/internal/apis/dbaas"
        "terraform-provider-infomaniak/internal/apis/helpers"

        "resty.dev/v3"
)

// Ensure that our client implements Api
var (
        _ dbaas.Api = (*Client)(nil)
)

type Client struct {
        resty *resty.Client
}

func New(baseUri, token, version string) *Client <span class="cov8" title="1">{
        return &amp;Client{
                resty: resty.New().
                        SetBaseURL(baseUri).
                        SetAuthToken(token).
                        SetHeader("User-Agent", helpers.GetUserAgent(version)),
        }
}</span>

func (client *Client) FindPack(dbType string, name string) (*dbaas.DBaaSPack, error) <span class="cov0" title="0">{
        var result helpers.NormalizedApiResponse[[]*dbaas.DBaaSPack]

        resp, err := client.resty.R().
                SetResult(&amp;result).
                SetError(&amp;result).
                SetQueryParam("filter[type]", dbType).
                SetQueryParam("filter[names][]", name).
                Get(EndpointPacks)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if resp.IsError() </span><span class="cov0" title="0">{
                return nil, result.Error
        }</span>

        <span class="cov0" title="0">data := result.Data
        if len(data) != 1 || data[0].Name != name </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("pack not found")
        }</span>

        <span class="cov0" title="0">return data[0], nil</span>
}

func (client *Client) GetDBaaS(publicCloudId int64, publicCloudProjectId int64, dbaasId int64) (*dbaas.DBaaS, error) <span class="cov8" title="1">{
        var result helpers.NormalizedApiResponse[*dbaas.DBaaS]

        resp, err := client.resty.R().
                SetPathParam("public_cloud_id", fmt.Sprint(publicCloudId)).
                SetPathParam("public_cloud_project_id", fmt.Sprint(publicCloudProjectId)).
                SetPathParam("dbaas_id", fmt.Sprint(dbaasId)).
                SetQueryParam("with", "packs,projects,tags,connection").
                SetResult(&amp;result).
                SetError(&amp;result).
                Get(EndpointDatabase)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if resp.IsError() </span><span class="cov0" title="0">{
                return nil, result.Error
        }</span>

        <span class="cov8" title="1">return result.Data, nil</span>
}

func (client *Client) CreateDBaaS(input *dbaas.DBaaS) (*dbaas.DBaaSCreateInfo, error) <span class="cov0" title="0">{
        var result helpers.NormalizedApiResponse[*dbaas.DBaaSCreateInfo]

        resp, err := client.resty.R().
                SetPathParam("public_cloud_id", fmt.Sprint(input.Project.PublicCloudId)).
                SetPathParam("public_cloud_project_id", fmt.Sprint(input.Project.ProjectId)).
                SetBody(input).
                SetResult(&amp;result).
                SetError(&amp;result).
                Post(EndpointDatabases)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if resp.IsError() </span><span class="cov0" title="0">{
                return nil, result.Error
        }</span>

        <span class="cov0" title="0">return result.Data, nil</span>
}

func (client *Client) UpdateDBaaS(input *dbaas.DBaaS) (bool, error) <span class="cov0" title="0">{
        var result helpers.NormalizedApiResponse[bool]

        resp, err := client.resty.R().
                SetPathParam("public_cloud_id", fmt.Sprint(input.Project.PublicCloudId)).
                SetPathParam("public_cloud_project_id", fmt.Sprint(input.Project.ProjectId)).
                SetPathParam("dbaas_id", fmt.Sprint(input.Id)).
                SetBody(input).
                SetResult(&amp;result).
                SetError(&amp;result).
                Patch(EndpointDatabase)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov0" title="0">if resp.IsError() </span><span class="cov0" title="0">{
                return false, result.Error
        }</span>

        <span class="cov0" title="0">return result.Data, nil</span>
}

func (client *Client) DeleteDBaaS(publicCloudId int64, publicCloudProjectId int64, dbaasId int64) (bool, error) <span class="cov0" title="0">{
        var result helpers.NormalizedApiResponse[bool]

        resp, err := client.resty.R().
                SetPathParam("public_cloud_id", fmt.Sprint(publicCloudId)).
                SetPathParam("public_cloud_project_id", fmt.Sprint(publicCloudProjectId)).
                SetPathParam("dbaas_id", fmt.Sprint(dbaasId)).
                SetResult(&amp;result).
                SetError(&amp;result).
                Delete(EndpointDatabase)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov0" title="0">if resp.IsError() </span><span class="cov0" title="0">{
                return false, result.Error
        }</span>

        <span class="cov0" title="0">return result.Data, nil</span>
}

func (client *Client) PatchIpFilters(publicCloudId int64, publicCloudProjectId int64, dbaasId int64, filters dbaas.AllowedCIDRs) (bool, error) <span class="cov0" title="0">{
        var result helpers.NormalizedApiResponse[bool]

        resp, err := client.resty.R().
                SetPathParam("public_cloud_id", fmt.Sprint(publicCloudId)).
                SetPathParam("public_cloud_project_id", fmt.Sprint(publicCloudProjectId)).
                SetPathParam("dbaas_id", fmt.Sprint(dbaasId)).
                SetBody(filters).
                SetResult(&amp;result).
                SetError(&amp;result).
                Put(EndpointDatabaseIpFilter)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov0" title="0">if resp.IsError() </span><span class="cov0" title="0">{
                return false, result.Error
        }</span>

        <span class="cov0" title="0">return result.Data, nil</span>
}

func (client *Client) PutConfiguration(publicCloudId int64, publicCloudProjectId int64, dbaasId int64, configuration map[string]any) (bool, error) <span class="cov0" title="0">{
        var result helpers.NormalizedApiResponse[bool]

        resp, err := client.resty.R().
                SetPathParam("public_cloud_id", fmt.Sprint(publicCloudId)).
                SetPathParam("public_cloud_project_id", fmt.Sprint(publicCloudProjectId)).
                SetPathParam("dbaas_id", fmt.Sprint(dbaasId)).
                SetBody(configuration).
                SetResult(&amp;result).
                SetError(&amp;result).
                Put(EndpointDatabaseConfiguration)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov0" title="0">if resp.IsError() </span><span class="cov0" title="0">{
                return false, result.Error
        }</span>

        <span class="cov0" title="0">return result.Data, nil</span>
}

func (client *Client) GetConfiguration(publicCloudId int64, publicCloudProjectId int64, dbaasId int64) (map[string]any, error) <span class="cov0" title="0">{
        var result helpers.NormalizedApiResponse[map[string]any]

        resp, err := client.resty.R().
                SetPathParam("public_cloud_id", fmt.Sprint(publicCloudId)).
                SetPathParam("public_cloud_project_id", fmt.Sprint(publicCloudProjectId)).
                SetPathParam("dbaas_id", fmt.Sprint(dbaasId)).
                SetResult(&amp;result).
                SetError(&amp;result).
                Get(EndpointDatabaseConfiguration)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if resp.IsError() </span><span class="cov0" title="0">{
                return nil, result.Error
        }</span>

        <span class="cov0" title="0">return result.Data, nil</span>
}

func (client *Client) GetIpFilters(publicCloudId int64, publicCloudProjectId int64, dbaasId int64) ([]string, error) <span class="cov0" title="0">{
        var result helpers.NormalizedApiResponse[[]string]

        resp, err := client.resty.R().
                SetPathParam("public_cloud_id", fmt.Sprint(publicCloudId)).
                SetPathParam("public_cloud_project_id", fmt.Sprint(publicCloudProjectId)).
                SetPathParam("dbaas_id", fmt.Sprint(dbaasId)).
                SetResult(&amp;result).
                SetError(&amp;result).
                Get(EndpointDatabaseIpFilter)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if resp.IsError() </span><span class="cov0" title="0">{
                return nil, result.Error
        }</span>

        <span class="cov0" title="0">return result.Data, nil</span>
}

func (client *Client) CreateDBaasScheduleBackup(publicCloudId int64, publicCloudProjectId int64, dbaasId int64, backupSchedules *dbaas.DBaasBackupSchedule) (int64, error) <span class="cov0" title="0">{
        var result helpers.NormalizedApiResponse[int64]

        resp, err := client.resty.R().
                SetPathParam("public_cloud_id", fmt.Sprint(publicCloudId)).
                SetPathParam("public_cloud_project_id", fmt.Sprint(publicCloudProjectId)).
                SetPathParam("dbaas_id", fmt.Sprint(dbaasId)).
                SetBody(backupSchedules).
                SetResult(&amp;result).
                SetError(&amp;result).
                Post(EndpointDatabaseBackupSchedules)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov0" title="0">if resp.IsError() </span><span class="cov0" title="0">{
                return 0, result.Error
        }</span>

        <span class="cov0" title="0">return result.Data, nil</span>
}

func (client *Client) UpdateDBaasScheduleBackup(publicCloudId int64, publicCloudProjectId int64, dbaasId int64, id int64, backupSchedules *dbaas.DBaasBackupSchedule) (bool, error) <span class="cov0" title="0">{
        var result helpers.NormalizedApiResponse[bool]

        resp, err := client.resty.R().
                SetPathParam("public_cloud_id", fmt.Sprint(publicCloudId)).
                SetPathParam("public_cloud_project_id", fmt.Sprint(publicCloudProjectId)).
                SetPathParam("dbaas_id", fmt.Sprint(dbaasId)).
                SetPathParam("schedule_id", fmt.Sprint(id)).
                SetBody(backupSchedules).
                SetResult(&amp;result).
                SetError(&amp;result).
                Patch(EndpointDatabaseBackupSchedule)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov0" title="0">if resp.IsError() </span><span class="cov0" title="0">{
                return false, result.Error
        }</span>

        <span class="cov0" title="0">return result.Data, nil</span>
}

func (client *Client) GetDBaasScheduleBackup(publicCloudId int64, publicCloudProjectId int64, dbaasId int64, id int64) (*dbaas.DBaasBackupSchedule, error) <span class="cov0" title="0">{
        var result helpers.NormalizedApiResponse[*dbaas.DBaasBackupSchedule]

        resp, err := client.resty.R().
                SetPathParam("public_cloud_id", fmt.Sprint(publicCloudId)).
                SetPathParam("public_cloud_project_id", fmt.Sprint(publicCloudProjectId)).
                SetPathParam("dbaas_id", fmt.Sprint(dbaasId)).
                SetPathParam("schedule_id", fmt.Sprint(id)).
                SetResult(&amp;result).
                SetError(&amp;result).
                Get(EndpointDatabaseBackupSchedule)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if resp.IsError() </span><span class="cov0" title="0">{
                return nil, result.Error
        }</span>

        <span class="cov0" title="0">return result.Data, nil</span>
}

func (client *Client) DeleteDBaasScheduleBackup(publicCloudId int64, publicCloudProjectId int64, dbaasId int64, id int64) (bool, error) <span class="cov0" title="0">{
        var result helpers.NormalizedApiResponse[bool]

        resp, err := client.resty.R().
                SetPathParam("public_cloud_id", fmt.Sprint(publicCloudId)).
                SetPathParam("public_cloud_project_id", fmt.Sprint(publicCloudProjectId)).
                SetPathParam("dbaas_id", fmt.Sprint(dbaasId)).
                SetPathParam("schedule_id", fmt.Sprint(id)).
                SetResult(&amp;result).
                SetError(&amp;result).
                Delete(EndpointDatabaseBackupSchedule)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov0" title="0">if resp.IsError() </span><span class="cov0" title="0">{
                return false, result.Error
        }</span>

        <span class="cov0" title="0">return result.Data, nil</span>
}

func (client *Client) GetDbaasRegions() ([]string, error) <span class="cov0" title="0">{
        var result helpers.NormalizedApiResponse[[]string]

        resp, err := client.resty.R().
                SetResult(&amp;result).
                SetError(&amp;result).
                Get(EndpointDbaasDataRegion)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if resp.IsError() </span><span class="cov0" title="0">{
                return nil, result.Error
        }</span>

        <span class="cov0" title="0">return result.Data, nil</span>
}

func (client *Client) GetDbaasTypes() ([]*dbaas.DbaasType, error) <span class="cov0" title="0">{
        var result helpers.NormalizedApiResponse[[]*dbaas.DbaasType]

        resp, err := client.resty.R().
                SetResult(&amp;result).
                SetError(&amp;result).
                Get(EndpointDbaasDataTypes)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if resp.IsError() </span><span class="cov0" title="0">{
                return nil, result.Error
        }</span>

        <span class="cov0" title="0">return result.Data, nil</span>
}

func (client *Client) GetDbaasPack(params dbaas.PackFilter) (*dbaas.Pack, error) <span class="cov0" title="0">{
        var result helpers.NormalizedApiResponse[[]*dbaas.Pack]

        builder := client.resty.R().
                SetResult(&amp;result).
                SetError(&amp;result).
                SetQueryParam("filter[type]", params.DbType)

        if params.Name != nil </span><span class="cov0" title="0">{
                builder = builder.SetQueryParam("filter[names][]", *params.Name)
        }</span>

        <span class="cov0" title="0">if params.Group != nil </span><span class="cov0" title="0">{
                builder = builder.SetQueryParam("filter[groups][]", *params.Group)
        }</span>

        <span class="cov0" title="0">if params.Instances != nil </span><span class="cov0" title="0">{
                builder = builder.SetQueryParam("filter[instances]", strconv.FormatInt(*params.Instances, 10))
        }</span>

        <span class="cov0" title="0">if params.Cpu != nil </span><span class="cov0" title="0">{
                builder = builder.SetQueryParam("filter[cpu]", strconv.FormatInt(*params.Cpu, 10))
        }</span>

        <span class="cov0" title="0">if params.Ram != nil </span><span class="cov0" title="0">{
                builder = builder.SetQueryParam("filter[ram]", strconv.FormatInt(*params.Ram, 10))
        }</span>

        <span class="cov0" title="0">if params.Storage != nil </span><span class="cov0" title="0">{
                builder = builder.SetQueryParam("filter[storage]", strconv.FormatInt(*params.Storage, 10))
        }</span>

        <span class="cov0" title="0">resp, err := builder.Get(EndpointPacks)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if resp.IsError() </span><span class="cov0" title="0">{
                return nil, result.Error
        }</span>

        <span class="cov0" title="0">data := result.Data
        if len(data) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("pack not found")
        }</span>

        <span class="cov0" title="0">if len(data) != 1 </span><span class="cov0" title="0">{
                packs := strings.Builder{}
                for _, pack := range data </span><span class="cov0" title="0">{
                        packs.WriteString(pack.Name)
                        packs.WriteString(", ")
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("multiple packs found, please refine your search\nfound packs: %s", packs.String())</span>
        }

        <span class="cov0" title="0">return data[0], nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package dbaas

import (
        "encoding/json"
        "fmt"
        "reflect"
        "strings"
)

type DBaaSPack struct {
        Id   int64  `json:"id,omitempty"`
        Name string `json:"name,omitempty"`
}

type DbaasType struct {
        Name     string   `json:"name,omitempty"`
        Versions []string `json:"versions,omitempty"`
}

type PackFilter struct {
        DbType    string
        Group     *string
        Name      *string
        Instances *int64
        Cpu       *int64
        Ram       *int64
        Storage   *int64
}

type Pack struct {
        ID        int64  `json:"id,omitempty"`
        Type      string `json:"type,omitempty"`
        Group     string `json:"group,omitempty"`
        Name      string `json:"name,omitempty"`
        Instances int64  `json:"instances,omitempty"`
        CPU       int64  `json:"cpu,omitempty"`
        RAM       int64  `json:"ram,omitempty"`
        Storage   int64  `json:"storage,omitempty"`
        Rates     Rates  `json:"rates"`
}

type Rates struct {
        CHF Pricing `json:"CHF"`
        EUR Pricing `json:"EUR"`
}

type Pricing struct {
        HourExclTax float64 `json:"hour_excl_tax,omitempty"`
        HourInclTax float64 `json:"hour_incl_tax,omitempty"`
}

type StringMap map[string]string

func (sm *StringMap) UnmarshalJSON(data []byte) error <span class="cov0" title="0">{
        var raw map[string]any
        if err := json.Unmarshal(data, &amp;raw); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">*sm = make(StringMap)
        for key, value := range raw </span><span class="cov0" title="0">{
                switch v := value.(type) </span>{
                case string:<span class="cov0" title="0">
                        (*sm)[key] = v</span>
                case int, int8, int16, int32, int64, uint, uint8, uint16, uint32, uint64, float32, float64:<span class="cov0" title="0">
                        (*sm)[key] = fmt.Sprint(v)</span>
                default:<span class="cov0" title="0">
                        return fmt.Errorf("unsupported type for key %v: (%v) %v", key, reflect.TypeOf(v), v)</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}

type DBaaS struct {
        Id         int64                `json:"id,omitempty"`
        Project    DBaaSProject         `json:"project,omitzero"`
        PackId     int64                `json:"pack_id,omitempty"`
        Pack       *DBaaSPack           `json:"pack,omitempty"`
        Connection *DBaaSConnectionInfo `json:"connection,omitempty"`

        Type                 string `json:"type,omitempty"`
        Version              string `json:"version,omitempty"`
        Name                 string `json:"name,omitempty"`
        KubernetesIdentifier string `json:"kube_identifier,omitempty"`
        Region               string `json:"region,omitempty"`
        Status               string `json:"status,omitempty"`

        Settings StringMap
}

type AllowedCIDRs struct {
        IpFilters []string `json:"ip_filters"`
}

// avoid crashes when the backend returns [] instead of null when connection is not yet avaialble
func (d *DBaaS) UnmarshalJSON(data []byte) error <span class="cov0" title="0">{
        type Alias DBaaS
        aux := &amp;struct {
                Connection json.RawMessage `json:"connection,omitempty"`
                *Alias
        }{
                Alias: (*Alias)(d),
        }

        if err := json.Unmarshal(data, &amp;aux); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if len(aux.Connection) &gt; 0 </span><span class="cov0" title="0">{
                if strings.TrimSpace(string(aux.Connection)) == "[]" </span><span class="cov0" title="0">{
                        d.Connection = nil
                }</span> else<span class="cov0" title="0"> {
                        d.Connection = &amp;DBaaSConnectionInfo{}
                        if err := json.Unmarshal(aux.Connection, d.Connection); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}

type DBaasBackupSchedule struct {
        Id            *int64  `json:"id,omitempty"`
        Name          *string `json:"name,omitempty"`
        ScheduledAt   *string `json:"scheduled_at,omitempty"`
        Retention     *int64  `json:"retention,omitempty"`
        IsPitrEnabled *bool   `json:"is_pitr_enabled,omitempty"`
}

type DBaaSCreateInfo struct {
        Id             int64  `json:"id"`
        RootPassword   string `json:"admin_password"`
        KubeIdentifier string `json:"kube_identifier"`
}

type DBaaSConnectionInfo struct {
        Host     string `json:"host"`
        Port     string `json:"port"`
        User     string `json:"user"`
        Password string `json:"password"`
        Ca       string `json:"ca"`
}

type DBaaSBackup struct {
        Id          string `json:"id,omitempty"`
        Location    string `json:"location,omitempty"`
        CreatedAt   uint64 `json:"created_at,omitempty"`
        CompletedAt uint64 `json:"completed_at,omitempty"`
        Status      string `json:"status,omitempty"`
}

type DBaaSRestore struct {
        Id           string           `json:"id,omitempty"`
        BackupSource string           `json:"backup_source,omitempty"`
        CreatedAt    uint64           `json:"created_at,omitempty"`
        Status       string           `json:"status,omitempty"`
        NewService   *DBaaSCreateInfo `json:"new_service,omitempty"`
}

func (dbaas *DBaaS) Key() string <span class="cov0" title="0">{
        return fmt.Sprintf("%d-%d-%d", dbaas.Project.PublicCloudId, dbaas.Project.ProjectId, dbaas.Id)
}</span>

type DBaaSProject struct {
        PublicCloudId int64 `json:"public_cloud_id,omitempty"`
        ProjectId     int64 `json:"id,omitempty"`
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package implementation

import (
        "fmt"
        "strings"
        "terraform-provider-infomaniak/internal/apis/domain"
        "terraform-provider-infomaniak/internal/apis/helpers"

        "resty.dev/v3"
)

// Ensure that our client implements Api
var (
        _ domain.Api = (*Client)(nil)
)

type Client struct {
        resty *resty.Client
}

func New(baseUri, token, version string) *Client <span class="cov0" title="0">{
        return &amp;Client{
                resty: resty.New().
                        SetBaseURL(baseUri).
                        SetAuthToken(token).
                        SetHeader("User-Agent", helpers.GetUserAgent(version)),
        }
}</span>

func (client *Client) GetZone(fqdn string) (*domain.Zone, error) <span class="cov0" title="0">{
        var result helpers.NormalizedApiResponse[*domain.Zone]

        resp, err := client.resty.R().
                SetPathParam("fqdn", fmt.Sprint(fqdn)).
                SetQueryParam("with", "records,idn").
                SetResult(&amp;result).
                SetError(&amp;result).
                Get(EndpointZone)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if resp.IsError() </span><span class="cov0" title="0">{
                return nil, result.Error
        }</span>

        <span class="cov0" title="0">return result.Data, nil</span>
}

func (client *Client) CreateZone(fqdn string) (*domain.Zone, error) <span class="cov0" title="0">{
        var result helpers.NormalizedApiResponse[*domain.Zone]

        resp, err := client.resty.R().
                SetPathParam("fqdn", fmt.Sprint(fqdn)).
                SetQueryParam("with", "records,idn").
                SetResult(&amp;result).
                SetError(&amp;result).
                Post(EndpointZone)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if resp.IsError() </span><span class="cov0" title="0">{
                return nil, result.Error
        }</span>

        <span class="cov0" title="0">return result.Data, nil</span>
}

func (client *Client) DeleteZone(fqdn string) (bool, error) <span class="cov0" title="0">{
        var result helpers.NormalizedApiResponse[bool]

        resp, err := client.resty.R().
                SetPathParam("fqdn", fmt.Sprint(fqdn)).
                SetResult(&amp;result).
                SetError(&amp;result).
                Delete(EndpointZone)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov0" title="0">if resp.IsError() </span><span class="cov0" title="0">{
                return false, result.Error
        }</span>

        <span class="cov0" title="0">return result.Data, nil</span>
}

func (client *Client) GetRecord(zoneFqdn string, id int64) (*domain.Record, error) <span class="cov0" title="0">{
        var result helpers.NormalizedApiResponse[*domain.Record]

        resp, err := client.resty.R().
                SetPathParam("zone_fqdn", strings.TrimSuffix(zoneFqdn, ".")).
                SetPathParam("id", fmt.Sprint(id)).
                SetQueryParam("with", "idn,records_description").
                SetResult(&amp;result).
                SetError(&amp;result).
                Get(EndpointRecord)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if resp.IsError() </span><span class="cov0" title="0">{
                return nil, result.Error
        }</span>

        <span class="cov0" title="0">return result.Data, nil</span>
}

type CreateRecordRequest struct {
        Type   string `json:"type"`
        Source string `json:"source"`
        Target string `json:"target"`
        TTL    int64  `json:"ttl"`
}

func (client *Client) CreateRecord(zoneFqdn, recordType, source, target string, ttl int64) (*domain.Record, error) <span class="cov0" title="0">{
        var result helpers.NormalizedApiResponse[*domain.Record]

        var input = CreateRecordRequest{
                Type:   recordType,
                Source: source,
                Target: target,
                TTL:    ttl,
        }

        resp, err := client.resty.R().
                SetPathParam("zone_fqdn", strings.TrimSuffix(zoneFqdn, ".")).
                SetQueryParam("with", "idn,records_description").
                SetResult(&amp;result).
                SetBody(input).
                SetError(&amp;result).
                Post(EndpointRecords)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if resp.IsError() </span><span class="cov0" title="0">{
                return nil, result.Error
        }</span>

        <span class="cov0" title="0">return result.Data, nil</span>
}

func (client *Client) UpdateRecord(zoneFqdn string, id int64, recordType, source, target string, ttl int64) (*domain.Record, error) <span class="cov0" title="0">{
        var result helpers.NormalizedApiResponse[*domain.Record]

        var input = CreateRecordRequest{
                Type:   recordType,
                Source: source,
                Target: target,
                TTL:    ttl,
        }

        resp, err := client.resty.R().
                SetPathParam("zone_fqdn", strings.TrimSuffix(zoneFqdn, ".")).
                SetPathParam("id", fmt.Sprint(id)).
                SetQueryParam("with", "idn,records_description").
                SetResult(&amp;result).
                SetBody(input).
                SetError(&amp;result).
                Put(EndpointRecord)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if resp.IsError() </span><span class="cov0" title="0">{
                return nil, result.Error
        }</span>

        <span class="cov0" title="0">return result.Data, nil</span>
}

func (client *Client) DeleteRecord(zoneFqdn string, id int64) (bool, error) <span class="cov0" title="0">{
        var result helpers.NormalizedApiResponse[bool]

        resp, err := client.resty.R().
                SetPathParam("zone_fqdn", strings.TrimSuffix(zoneFqdn, ".")).
                SetPathParam("id", fmt.Sprint(id)).
                SetResult(&amp;result).
                SetError(&amp;result).
                Delete(EndpointRecord)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov0" title="0">if resp.IsError() </span><span class="cov0" title="0">{
                return false, result.Error
        }</span>

        <span class="cov0" title="0">return result.Data, nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package domain

import "slices"

type Zone struct {
        ID             int64      `json:"id,omitempty"`
        FQDN           string     `json:"fqdn,omitempty"`
        DNSSEC         ZoneDNSSEC `json:"dnssec,omitempty"`
        Nameservers    []string   `json:"nameservers,omitempty"`
        Records        []Record   `json:"records,omitempty"`
        ClusterRecords []Record   `json:"cluster_records,omitempty"`
}

type ZoneDNSSEC struct {
        IsEnabled bool `json:"is_enabled,omitempty"`
}

type RecordType = string

var (
        RecordA      RecordType = "A"
        RecordAAAA   RecordType = "AAAA"
        RecordCAA    RecordType = "CAA"
        RecordCNAME  RecordType = "CNAME"
        RecordDNAME  RecordType = "DNAME"
        RecordDS     RecordType = "DS"
        RecordMX     RecordType = "MX"
        RecordNS     RecordType = "NS"
        RecordSMIMEA RecordType = "SMIMEA"
        RecordSRV    RecordType = "SRV"
        RecordSSHFP  RecordType = "SSHFP"
        RecordTLSA   RecordType = "TLSA"
        RecordTXT    RecordType = "TXT"
)

var RecordTypes = []RecordType{RecordA, RecordAAAA, RecordCAA, RecordCNAME, RecordDNAME, RecordNS, RecordDS, RecordMX, RecordSMIMEA, RecordSRV, RecordSSHFP, RecordTLSA, RecordTXT}

func IsValidRecordType(t RecordType) bool <span class="cov0" title="0">{
        return slices.Contains(RecordTypes, t)
}</span>

type Record struct {
        ID        int64      `json:"id,omitempty"`
        Source    string     `json:"source,omitempty"`
        SourceIDN *string    `json:"source_idn,omitempty"`
        Type      RecordType `json:"type,omitempty"`
        TTL       int64      `json:"ttl,omitempty"`
        Target    string     `json:"target,omitempty"`
        DynDNSID  int64      `json:"dyndns_id,omitempty"`
        // Description string     `json:"description,omitempty"`
}

type (
        recordTypeA      struct{ string }
        recordTypeAAAA   struct{ string }
        recordTypeCAA    struct{ string }
        recordTypeCNAME  struct{ string }
        recordTypeDNAME  struct{ string }
        recordTypeDS     struct{ string }
        recordTypeMX     struct{ string }
        recordTypeNS     struct{ string }
        recordTypeSMIMEA struct{ string }
        recordTypeSRV    struct{ string }
        recordTypeSSHFP  struct{ string }
        recordTypeTLSA   struct{ string }
        recordTypeTXT    struct{ string }
)

var (
        RecordTypeA      = recordTypeA{"A"}
        RecordTypeAAAA   = recordTypeAAAA{"AAAA"}
        RecordTypeCAA    = recordTypeCAA{"CAA"}
        RecordTypeCNAME  = recordTypeCNAME{"CNAME"}
        RecordTypeDNAME  = recordTypeDNAME{"DNAME"}
        RecordTypeDS     = recordTypeDS{"DS"}
        RecordTypeMX     = recordTypeMX{"MX"}
        RecordTypeNS     = recordTypeNS{"NS"}
        RecordTypeSMIMEA = recordTypeSMIMEA{"SMIMEA"}
        RecordTypeSRV    = recordTypeSRV{"SRV"}
        RecordTypeSSHFP  = recordTypeSSHFP{"SSHFP"}
        RecordTypeTLSA   = recordTypeTLSA{"TLSA"}
        RecordTypeTXT    = recordTypeTXT{"TXT"}
)

type RecordConstraint interface {
        recordTypeA | recordTypeAAAA | recordTypeCAA | recordTypeCNAME | recordTypeDNAME | recordTypeDS | recordTypeMX | recordTypeSMIMEA | recordTypeSRV | recordTypeSSHFP | recordTypeTLSA | recordTypeTXT | recordTypeNS
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package helpers

import (
        "fmt"
        "strings"
)

type NormalizedApiResponse[K any] struct {
        Result string    `json:"result"`
        Data   K         `json:"data"`
        Error  *ApiError `json:"error"`
}

type ApiError struct {
        Description string          `json:"description"`
        Errors      []*ApiError     `json:"errors"`
        Context     ApiErrorContext `json:"context"`
}

type ApiErrorContext struct {
        Attribute string `json:"attribute"`
        Values    []any  `json:"values"`
}

func (apiError *ApiError) Error() string <span class="cov8" title="1">{
        var builder strings.Builder

        builder.WriteString(apiError.Description)

        if len(apiError.Context.Values) &gt; 0 </span><span class="cov8" title="1">{
                builder.WriteString(fmt.Sprintf(" (possible values: %v)", apiError.Context.Values))
        }</span>

        <span class="cov8" title="1">if len(apiError.Errors) &gt; 0 </span><span class="cov8" title="1">{
                builder.WriteString(":\n")
        }</span>

        <span class="cov8" title="1">for _, err := range apiError.Errors </span><span class="cov8" title="1">{
                tabulated := "  " + strings.ReplaceAll(err.Error(), "\n", "\n  ")
                builder.WriteString(tabulated + "\n")
        }</span>

        <span class="cov8" title="1">return strings.TrimSuffix(builder.String(), "\n")</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package helpers

import "fmt"

const (
        userAgentFormat = "terraform-provider-infomaniak/%s (resty; +https://github.com/Infomaniak/terraform-provider-infomaniak)"
)

func GetUserAgent(version string) string <span class="cov0" title="0">{
        return fmt.Sprintf(userAgentFormat, version)
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package implementation

import (
        "fmt"
        "terraform-provider-infomaniak/internal/apis/helpers"
        "terraform-provider-infomaniak/internal/apis/kaas"

        "resty.dev/v3"
)

// Ensure that our client implements Api
var (
        _ kaas.Api = (*Client)(nil)
)

type Client struct {
        resty *resty.Client
}

func New(baseUri, token, version string) *Client <span class="cov8" title="1">{
        return &amp;Client{
                resty: resty.New().
                        SetBaseURL(baseUri).
                        SetAuthToken(token).
                        SetHeader("User-Agent", helpers.GetUserAgent(version)),
        }
}</span>

func (client *Client) GetPacks() ([]*kaas.KaasPack, error) <span class="cov0" title="0">{
        var result helpers.NormalizedApiResponse[[]*kaas.KaasPack]

        resp, err := client.resty.R().
                SetResult(&amp;result).
                SetError(&amp;result).
                Get(EndpointPacks)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if resp.IsError() </span><span class="cov0" title="0">{
                return nil, result.Error
        }</span>

        <span class="cov0" title="0">return result.Data, nil</span>
}

func (client *Client) GetVersions() ([]string, error) <span class="cov0" title="0">{
        var result helpers.NormalizedApiResponse[[]string]

        resp, err := client.resty.R().
                SetResult(&amp;result).
                SetError(&amp;result).
                Get(EndpointVersions)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if resp.IsError() </span><span class="cov0" title="0">{
                return nil, result.Error
        }</span>

        <span class="cov0" title="0">return result.Data, nil</span>
}

func (client *Client) GetKaas(publicCloudId int64, publicCloudProjectId int64, kaasId int64) (*kaas.Kaas, error) <span class="cov8" title="1">{
        var result helpers.NormalizedApiResponse[*kaas.Kaas]

        resp, err := client.resty.R().
                SetPathParam("public_cloud_id", fmt.Sprint(publicCloudId)).
                SetPathParam("public_cloud_project_id", fmt.Sprint(publicCloudProjectId)).
                SetPathParam("kaas_id", fmt.Sprint(kaasId)).
                SetQueryParam("with", "packs,projects,instances,tags").
                SetResult(&amp;result).
                SetError(&amp;result).
                Get(EndpointKaas)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if resp.IsError() </span><span class="cov0" title="0">{
                return nil, result.Error
        }</span>

        <span class="cov8" title="1">return result.Data, nil</span>
}

func (client *Client) GetKubeconfig(publicCloudId int64, publicCloudProjectId int64, kaasId int64) (string, error) <span class="cov0" title="0">{
        var result helpers.NormalizedApiResponse[string]

        resp, err := client.resty.R().
                SetPathParam("public_cloud_id", fmt.Sprint(publicCloudId)).
                SetPathParam("public_cloud_project_id", fmt.Sprint(publicCloudProjectId)).
                SetPathParam("kaas_id", fmt.Sprint(kaasId)).
                SetResult(&amp;result).
                SetError(&amp;result).
                Get(EndpointKaasKubeconfig)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">if resp.IsError() </span><span class="cov0" title="0">{
                return "", result.Error
        }</span>

        <span class="cov0" title="0">return result.Data, nil</span>
}

func (client *Client) CreateKaas(input *kaas.Kaas) (int64, error) <span class="cov8" title="1">{
        var result helpers.NormalizedApiResponse[int64]

        resp, err := client.resty.R().
                SetPathParam("public_cloud_id", fmt.Sprint(input.Project.PublicCloudId)).
                SetPathParam("public_cloud_project_id", fmt.Sprint(input.Project.ProjectId)).
                SetBody(input).
                SetResult(&amp;result).
                SetError(&amp;result).
                Post(EndpointKaases)
        if err != nil </span><span class="cov8" title="1">{
                return 0, err
        }</span>

        <span class="cov8" title="1">if resp.IsError() </span><span class="cov0" title="0">{
                return 0, result.Error
        }</span>

        <span class="cov8" title="1">return result.Data, nil</span>
}

func (client *Client) UpdateKaas(input *kaas.Kaas) (bool, error) <span class="cov0" title="0">{
        var result helpers.NormalizedApiResponse[bool]

        resp, err := client.resty.R().
                SetPathParam("public_cloud_id", fmt.Sprint(input.Project.PublicCloudId)).
                SetPathParam("public_cloud_project_id", fmt.Sprint(input.Project.ProjectId)).
                SetPathParam("kaas_id", fmt.Sprint(input.Id)).
                SetBody(input).
                SetResult(&amp;result).
                SetError(&amp;result).
                Patch(EndpointKaas)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov0" title="0">if resp.IsError() </span><span class="cov0" title="0">{
                return false, result.Error
        }</span>

        <span class="cov0" title="0">return result.Data, nil</span>
}

func (client *Client) DeleteKaas(publicCloudId int64, publicCloudProjectId int64, kaasId int64) (bool, error) <span class="cov0" title="0">{
        var result helpers.NormalizedApiResponse[bool]

        resp, err := client.resty.R().
                SetPathParam("public_cloud_id", fmt.Sprint(publicCloudId)).
                SetPathParam("public_cloud_project_id", fmt.Sprint(publicCloudProjectId)).
                SetPathParam("kaas_id", fmt.Sprint(kaasId)).
                SetResult(&amp;result).
                SetError(&amp;result).
                Delete(EndpointKaas)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov0" title="0">if resp.IsError() </span><span class="cov0" title="0">{
                return false, result.Error
        }</span>

        <span class="cov0" title="0">return result.Data, nil</span>
}

func (client *Client) GetInstancePool(publicCloudId int64, publicCloudProjectId int64, kaasId int64, instancePoolId int64) (*kaas.InstancePool, error) <span class="cov8" title="1">{
        var result helpers.NormalizedApiResponse[*kaas.InstancePool]

        resp, err := client.resty.R().
                SetPathParam("public_cloud_id", fmt.Sprint(publicCloudId)).
                SetPathParam("public_cloud_project_id", fmt.Sprint(publicCloudProjectId)).
                SetPathParam("kaas_id", fmt.Sprint(kaasId)).
                SetPathParam("kaas_instance_pool_id", fmt.Sprint(instancePoolId)).
                SetResult(&amp;result).
                SetError(&amp;result).
                Get(EndpointInstancePool)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if resp.IsError() </span><span class="cov0" title="0">{
                return nil, result.Error
        }</span>

        // Default Max = Min
        <span class="cov8" title="1">if result.Data.MaxInstances == 0 </span><span class="cov8" title="1">{
                result.Data.MaxInstances = result.Data.MinInstances
        }</span>

        <span class="cov8" title="1">return result.Data, nil</span>
}

func (client *Client) CreateInstancePool(publicCloudId int64, publicCloudProjectId int64, input *kaas.InstancePool) (int64, error) <span class="cov0" title="0">{
        var result helpers.NormalizedApiResponse[int64]

        resp, err := client.resty.R().
                SetPathParam("public_cloud_id", fmt.Sprint(publicCloudId)).
                SetPathParam("public_cloud_project_id", fmt.Sprint(publicCloudProjectId)).
                SetPathParam("kaas_id", fmt.Sprint(input.KaasId)).
                SetBody(input).
                SetResult(&amp;result).
                SetError(&amp;result).
                Post(EndpointInstancePools)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov0" title="0">if resp.IsError() </span><span class="cov0" title="0">{
                return 0, result.Error
        }</span>

        <span class="cov0" title="0">return result.Data, nil</span>
}

func (client *Client) UpdateInstancePool(publicCloudId int64, publicCloudProjectId int64, input *kaas.InstancePool) (bool, error) <span class="cov0" title="0">{
        var result helpers.NormalizedApiResponse[bool]

        resp, err := client.resty.R().
                SetPathParam("public_cloud_id", fmt.Sprint(publicCloudId)).
                SetPathParam("public_cloud_project_id", fmt.Sprint(publicCloudProjectId)).
                SetPathParam("kaas_id", fmt.Sprint(input.KaasId)).
                SetPathParam("kaas_instance_pool_id", fmt.Sprint(input.Id)).
                SetBody(input).
                SetResult(&amp;result).
                SetError(&amp;result).
                Patch(EndpointInstancePool)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov0" title="0">if resp.IsError() </span><span class="cov0" title="0">{
                return false, result.Error
        }</span>

        <span class="cov0" title="0">return result.Data, nil</span>
}

func (client *Client) DeleteInstancePool(publicCloudId int64, publicCloudProjectId int64, kaasId int64, instancePoolId int64) (bool, error) <span class="cov0" title="0">{
        var result helpers.NormalizedApiResponse[bool]

        resp, err := client.resty.R().
                SetPathParam("public_cloud_id", fmt.Sprint(publicCloudId)).
                SetPathParam("public_cloud_project_id", fmt.Sprint(publicCloudProjectId)).
                SetPathParam("kaas_id", fmt.Sprint(kaasId)).
                SetPathParam("kaas_instance_pool_id", fmt.Sprint(instancePoolId)).
                SetResult(&amp;result).
                SetError(&amp;result).
                Delete(EndpointInstancePool)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov0" title="0">if resp.IsError() </span><span class="cov0" title="0">{
                return false, result.Error
        }</span>

        <span class="cov0" title="0">return result.Data, nil</span>
}

func (client *Client) PatchApiserverParams(input *kaas.Apiserver, publicCloudId int64, projectId int64, kaasId int64) (bool, error) <span class="cov0" title="0">{
        var result helpers.NormalizedApiResponse[bool]
        resp, err := client.resty.R().
                SetPathParam("public_cloud_id", fmt.Sprint(publicCloudId)).
                SetPathParam("public_cloud_project_id", fmt.Sprint(projectId)).
                SetPathParam("kaas_id", fmt.Sprint(kaasId)).
                SetBody(input).
                SetResult(&amp;result).
                SetError(&amp;result).
                Patch(EndpointApiserver)

        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov0" title="0">if resp.IsError() </span><span class="cov0" title="0">{
                return false, result.Error
        }</span>

        <span class="cov0" title="0">return result.Data, nil</span>
}

func (client *Client) GetApiserverParams(publicCloudId int64, projectId int64, kaasId int64) (*kaas.Apiserver, error) <span class="cov0" title="0">{

        var result helpers.NormalizedApiResponse[*kaas.Apiserver]
        resp, err := client.resty.R().
                SetPathParam("public_cloud_id", fmt.Sprint(publicCloudId)).
                SetPathParam("public_cloud_project_id", fmt.Sprint(projectId)).
                SetPathParam("kaas_id", fmt.Sprint(kaasId)).
                SetResult(&amp;result).
                SetError(&amp;result).
                Get(EndpointApiserver)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if resp.IsError() </span><span class="cov0" title="0">{
                return nil, result.Error
        }</span>

        <span class="cov0" title="0">return result.Data, nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package mock

import (
        "bytes"
        "encoding/gob"
        "encoding/json"
        "errors"
        "os"
        "path"
        "terraform-provider-infomaniak/internal/apis/kaas"
        "time"
)

type KaasObject interface {
        Key() string
        *kaas.Kaas | *kaas.InstancePool
}

var (
        mockedApiStatePath = path.Join(os.TempDir(), "terraform-provider-infomaniak-kaas")
        mockedApiState     = make(map[string][]byte)

        ErrKeyNotFound  = errors.New("key not found")
        ErrDuplicateKey = errors.New("duplicate key found")
)

func getFromCache[K KaasObject](key string) (K, error) <span class="cov0" title="0">{
        obj, found := mockedApiState[key]
        if !found </span><span class="cov0" title="0">{
                return nil, ErrKeyNotFound
        }</span>

        <span class="cov0" title="0">var buff = bytes.NewBuffer(obj)
        var result K
        err := gob.NewDecoder(buff).Decode(&amp;result)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if result == nil </span><span class="cov0" title="0">{
                return nil, ErrKeyNotFound
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

func addToCache[K KaasObject](obj K) error <span class="cov0" title="0">{
        key := obj.Key()
        _, found := mockedApiState[key]
        if found </span><span class="cov0" title="0">{
                return ErrDuplicateKey
        }</span>

        <span class="cov0" title="0">var buff bytes.Buffer
        err := gob.NewEncoder(&amp;buff).Encode(obj)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">mockedApiState[key] = buff.Bytes()
        saveCache()
        return nil</span>
}

func updateCache[K KaasObject](obj K) error <span class="cov0" title="0">{
        key := obj.Key()
        cachedObject, found := mockedApiState[key]
        if !found </span><span class="cov0" title="0">{
                return ErrKeyNotFound
        }</span>

        <span class="cov0" title="0">var buff = bytes.NewBuffer(cachedObject)
        var result K
        err := gob.NewDecoder(buff).Decode(&amp;result)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">var newBuff bytes.Buffer
        err = gob.NewEncoder(&amp;newBuff).Encode(obj)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">mockedApiState[key] = newBuff.Bytes()
        saveCache()
        return nil</span>
}

func removeFromCache[K KaasObject](obj K) error <span class="cov0" title="0">{
        key := obj.Key()
        _, found := mockedApiState[key]
        if !found </span><span class="cov0" title="0">{
                return ErrKeyNotFound
        }</span>

        <span class="cov0" title="0">delete(mockedApiState, key)
        saveCache()
        return nil</span>
}

func init() <span class="cov0" title="0">{
        // Gob register
        gob.Register(&amp;kaas.Kaas{})
        gob.Register(&amp;kaas.InstancePool{})

        // Check cache age
        stat, err := os.Stat(mockedApiStatePath)
        if err == nil </span><span class="cov0" title="0">{
                // DeleteKaas cache if old
                if time.Since(stat.ModTime()) &gt; 24*time.Hour </span><span class="cov0" title="0">{
                        os.Remove(mockedApiStatePath)
                        return
                }</span>
        }

        // Try to get cache
        <span class="cov0" title="0">bdy, err := os.ReadFile(mockedApiStatePath)
        if err == nil </span><span class="cov0" title="0">{
                // Cache found
                err := json.Unmarshal(bdy, &amp;mockedApiState)
                if err != nil </span><span class="cov0" title="0">{
                        os.Remove(mockedApiStatePath)
                }</span>
                <span class="cov0" title="0">return</span>
        }

        // Create Kaas tmp file for caching
        <span class="cov0" title="0">_, err = os.Create(mockedApiStatePath)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
}

func saveCache() <span class="cov0" title="0">{
        data, err := json.Marshal(mockedApiState)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        //nolint:errcheck
        <span class="cov0" title="0">os.WriteFile(mockedApiStatePath, data, 0666)</span>
}

func ResetCache() <span class="cov0" title="0">{
        mockedApiState = make(map[string][]byte)
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package mock

import (
        "fmt"
        "log"
        "regexp"
        "terraform-provider-infomaniak/internal/apis/kaas"
)

// Ensure that our client implements Api
var (
        _               kaas.Api = (*Client)(nil)
        dnsRegexp                = regexp.MustCompile("^[a-z0-9]([-a-z0-9]*[a-z0-9])?$")
        kubeLabelRegexp          = regexp.MustCompile(`^[a-zA-Z0-9\-./]+:\s*[a-zA-Z0-9\-_.]{1,63}$`)
)

type Client struct{}

func New() *Client <span class="cov0" title="0">{
        return &amp;Client{}
}</span>

func (c *Client) GetPacks() ([]*kaas.KaasPack, error) <span class="cov0" title="0">{
        return []*kaas.KaasPack{
                {
                        Id:          1,
                        Name:        "standard",
                        Description: "Standard Cluster",
                },
                {
                        Id:          2,
                        Name:        "pro",
                        Description: "Pro Cluster",
                },
        }, nil
}</span>

func (c *Client) MustGetPackFromId(id int64) *kaas.KaasPack <span class="cov0" title="0">{
        packs, _ := c.GetPacks()
        for _, pack := range packs </span><span class="cov0" title="0">{
                if pack.Id == id </span><span class="cov0" title="0">{
                        return pack
                }</span>
        }
        <span class="cov0" title="0">log.Fatalf("pack with id %d not found", id)
        return nil</span>
}

func (c *Client) GetVersions() ([]string, error) <span class="cov0" title="0">{
        return []string{"1.29", "1.30", "1.31"}, nil
}</span>

func (c *Client) GetKaas(publicCloudId int64, publicCloudProjectId int64, kaasId int64) (*kaas.Kaas, error) <span class="cov0" title="0">{
        key := fmt.Sprintf("%d-%d-%d", publicCloudId, publicCloudProjectId, kaasId)
        obj, err := getFromCache[*kaas.Kaas](key)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">obj.Status = "Active"

        return obj, nil</span>
}

func (client *Client) GetKubeconfig(publicCloudId int64, publicCloudProjectId int64, kaasId int64) (string, error) <span class="cov0" title="0">{
        return genKubeconfig(), nil
}</span>

func (c *Client) CreateKaas(input *kaas.Kaas) (int64, error) <span class="cov0" title="0">{
        // Checks
        if input.Project.PublicCloudId == 0 </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("kaas is missing public cloud project id")
        }</span>
        <span class="cov0" title="0">if input.Region == "" </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("kaas is missing region")
        }</span>
        <span class="cov0" title="0">if input.PackId == 0 </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("kaas is missing pack id")
        }</span>

        <span class="cov0" title="0">var obj = kaas.Kaas{
                Project:           input.Project,
                Region:            input.Region,
                KubernetesVersion: input.KubernetesVersion,
                PackId:            input.PackId,
                Pack:              c.MustGetPackFromId(input.PackId),
                Name:              input.Name,
        }
        obj.Id = genId()

        return obj.Id, addToCache(&amp;obj)</span>
}

func (c *Client) UpdateKaas(input *kaas.Kaas) (bool, error) <span class="cov0" title="0">{
        // Checks
        if input.Project.PublicCloudId == 0 </span><span class="cov0" title="0">{
                return false, fmt.Errorf("kaas is missing public cloud project id")
        }</span>
        <span class="cov0" title="0">if input.Id == 0 </span><span class="cov0" title="0">{
                return false, fmt.Errorf("kaas is missing kaas id")
        }</span>
        <span class="cov0" title="0">if input.PackId == 0 </span><span class="cov0" title="0">{
                return false, fmt.Errorf("kaas is missing pack id")
        }</span>
        <span class="cov0" title="0">if input.Region != "" </span><span class="cov0" title="0">{
                return false, fmt.Errorf("client cannot update region")
        }</span>

        <span class="cov0" title="0">var obj = kaas.Kaas{
                Id:      input.Id,
                Project: input.Project,

                Name:              input.Name,
                Region:            input.Region,
                PackId:            input.PackId,
                Pack:              c.MustGetPackFromId(input.PackId),
                KubernetesVersion: input.KubernetesVersion,
        }

        return true, updateCache(&amp;obj)</span>
}

func (c *Client) DeleteKaas(publicCloudId int64, publicCloudProjectId int64, kaasId int64) (bool, error) <span class="cov0" title="0">{
        var obj = kaas.Kaas{
                Project: kaas.KaasProject{
                        PublicCloudId: publicCloudId,
                        ProjectId:     publicCloudProjectId,
                },
                Id: kaasId,
        }

        return true, removeFromCache(&amp;obj)
}</span>

func (c *Client) GetInstancePool(publicCloudId int64, publicCloudProjectId int64, kaasId int64, instancePoolId int64) (*kaas.InstancePool, error) <span class="cov0" title="0">{
        _, err := c.GetKaas(publicCloudId, publicCloudProjectId, kaasId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">key := fmt.Sprintf("%d-%d", kaasId, instancePoolId)
        obj, err := getFromCache[*kaas.InstancePool](key)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">obj.Status = "Active"

        return obj, nil</span>
}

func (c *Client) CreateInstancePool(publicCloudId int64, publicCloudProjectId int64, input *kaas.InstancePool) (int64, error) <span class="cov0" title="0">{
        // Checks
        if publicCloudId == 0 </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("instance pool is missing public cloud id")
        }</span>
        <span class="cov0" title="0">if publicCloudProjectId == 0 </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("instance pool is missing public cloud project id")
        }</span>
        <span class="cov0" title="0">if input.KaasId == 0 </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("instance pool is missing kaas id")
        }</span>
        <span class="cov0" title="0">if !dnsRegexp.MatchString(input.Name) </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("instance pool name should be a dns name according to RFC 1123")
        }</span>
        <span class="cov0" title="0">if input.FlavorName == "" </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("instance pool is missing flavor name")
        }</span>
        <span class="cov0" title="0">if input.MinInstances &lt; 0 </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("instance pool min instances should be greater than 0")
        }</span>
        // if input.MaxInstances &lt; 0 {
        //         return nil, fmt.Errorf("instance pool max instances should be greater than 0")
        // }
        // if input.MinInstances &gt; input.MaxInstances {
        //         return nil, fmt.Errorf("instance pool min instance should be lesser than (or equal) max")
        // }
        <span class="cov0" title="0">if len(input.Labels) &gt; 0 </span><span class="cov0" title="0">{
                for key, label := range input.Labels </span><span class="cov0" title="0">{
                        keyLabel := key + ": " + label
                        if !kubeLabelRegexp.MatchString(keyLabel) </span><span class="cov0" title="0">{
                                return 0, fmt.Errorf("instance pool label should be a kubernetes label")
                        }</span>
                }
        }

        <span class="cov0" title="0">_, err := c.GetKaas(publicCloudId, publicCloudProjectId, input.KaasId)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov0" title="0">var obj = kaas.InstancePool{
                Id:     genId(),
                KaasId: input.KaasId,

                Name:               input.Name,
                FlavorName:         input.FlavorName,
                AvailabilityZone:   input.AvailabilityZone,
                MinInstances:       input.MinInstances,
                MaxInstances:       input.MaxInstances,
                TargetInstances:    input.MinInstances,
                AvailableInstances: input.MinInstances,
                Labels:             input.Labels,
        }

        return obj.Id, addToCache(&amp;obj)</span>
}

func (c *Client) UpdateInstancePool(publicCloudId int64, publicCloudProjectId int64, input *kaas.InstancePool) (bool, error) <span class="cov0" title="0">{
        // Checks
        if publicCloudId == 0 </span><span class="cov0" title="0">{
                return false, fmt.Errorf("instance pool is missing public cloud id")
        }</span>
        <span class="cov0" title="0">if publicCloudProjectId == 0 </span><span class="cov0" title="0">{
                return false, fmt.Errorf("instance pool is missing public cloud project id")
        }</span>
        <span class="cov0" title="0">if input.KaasId == 0 </span><span class="cov0" title="0">{
                return false, fmt.Errorf("instance pool is missing kaas id")
        }</span>
        <span class="cov0" title="0">if input.Id == 0 </span><span class="cov0" title="0">{
                return false, fmt.Errorf("instance pool is instance pool id")
        }</span>
        <span class="cov0" title="0">if !dnsRegexp.MatchString(input.Name) </span><span class="cov0" title="0">{
                return false, fmt.Errorf("instance pool name should be a dns name according to RFC 1123")
        }</span>
        <span class="cov0" title="0">if input.FlavorName == "" </span><span class="cov0" title="0">{
                return false, fmt.Errorf("instance pool is missing flavor name")
        }</span>
        <span class="cov0" title="0">if input.MinInstances &lt; 0 </span><span class="cov0" title="0">{
                return false, fmt.Errorf("instance pool min instances should be greater than 0")
        }</span>
        // if input.MaxInstances &lt; 0 {
        //         return nil, fmt.Errorf("instance pool max instances should be greater than 0")
        // }
        // if input.MinInstances &gt; input.MaxInstances {
        //         return nil, fmt.Errorf("instance pool min instance should be lesser than (or equal) max")
        // }

        <span class="cov0" title="0">_, err := c.GetKaas(publicCloudId, publicCloudProjectId, input.KaasId)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov0" title="0">_, err = c.GetInstancePool(publicCloudId, publicCloudProjectId, input.KaasId, input.Id)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov0" title="0">var obj = kaas.InstancePool{
                KaasId: input.KaasId,
                Id:     input.Id,

                Name:               input.Name,
                FlavorName:         input.FlavorName,
                AvailabilityZone:   input.AvailabilityZone,
                MinInstances:       input.MinInstances,
                MaxInstances:       input.MinInstances,
                TargetInstances:    input.MinInstances,
                AvailableInstances: input.MinInstances,
        }

        return true, updateCache(&amp;obj)</span>
}

func (c *Client) DeleteInstancePool(publicCloudId int64, publicCloudProjectId int64, kaasId int64, instancePoolId int64) (bool, error) <span class="cov0" title="0">{
        _, err := c.GetKaas(publicCloudId, publicCloudProjectId, kaasId)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov0" title="0">var obj = kaas.InstancePool{
                KaasId: kaasId,
                Id:     instancePoolId,
        }

        return true, removeFromCache(&amp;obj)</span>
}

func (c *Client) GetApiserverParams(publicCloudId int64, projectId int64, kaasId int64) (*kaas.Apiserver, error) <span class="cov0" title="0">{
        return nil, nil
}</span>
func (c *Client) PatchApiserverParams(input *kaas.Apiserver, publicCloudId int64, projectId int64, kaasId int64) (bool, error) <span class="cov0" title="0">{
        return true, nil
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package mock

import (
        "bytes"
        cryptorand "crypto/rand"
        "encoding/base64"
        "math/rand/v2"
)

func genId() int64 <span class="cov0" title="0">{
        return rand.Int64()
}</span>

func genKubeconfig() string <span class="cov0" title="0">{
        var b = make([]byte, 1024)
        _, err := cryptorand.Read(b)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov0" title="0">var out bytes.Buffer
        enc := base64.NewEncoder(base64.StdEncoding, &amp;out)
        _, err = enc.Write(b)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov0" title="0">return out.String()</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package kaas

import (
        "encoding/json"
        "fmt"
        "maps"
)

type KaasPack struct {
        Id          int64  `json:"kaas_pack_id,omitempty"`
        Name        string `json:"name,omitempty"`
        Description string `json:"description,omitempty"`
}

type Apiserver struct {
        Params                     *ApiServerParams  `json:"apiserver_params"`
        NonSpecificApiServerParams map[string]string `json:"-"`

        OidcCa          *string `json:"oidc_ca"`
        AuditLogWebhook *string `json:"audit-webhook-config"`
        AuditLogPolicy  *string `json:"audit-policy"`
}

var _ json.Marshaler = (*Apiserver)(nil)

// We can delete this once json v2 is out, so we can flatten everything without having to do this
func (a *Apiserver) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{
        paramBytes, err := json.Marshal(a.Params)
        if err != nil </span><span class="cov0" title="0">{
                paramBytes = []byte("{}")
        }</span>
        <span class="cov0" title="0">paramsMap := make(map[string]string)
        json.Unmarshal(paramBytes, &amp;paramsMap)
        nonSpecificMap := a.NonSpecificApiServerParams
        res := make(map[string]string)
        maps.Copy(res, paramsMap)
        maps.Copy(res, nonSpecificMap)
        result, err := json.Marshal(map[string]any{
                "apiserver_params":     res,
                "oidc_ca":              a.OidcCa,
                "audit-policy":         a.AuditLogPolicy,
                "audit-webhook-config": a.AuditLogWebhook,
        })
        return result, err</span>
}

type ApiServerParams struct {
        IssuerUrl      *string `json:"--oidc-issuer-url,omitempty"`
        ClientId       *string `json:"--oidc-client-id,omitempty"`
        UsernameClaim  *string `json:"--oidc-username-claim,omitempty"`
        UsernamePrefix *string `json:"--oidc-username-prefix,omitempty"`
        SigningAlgs    *string `json:"--oidc-signing-algs,omitempty"`
        GroupsClaim    *string `json:"--oidc-groups-claim,omitempty"`
        GroupsPrefix   *string `json:"--oidc-groups-prefix,omitempty"`
        RequiredClaim  *string `json:"--oidc-required-claim,omitempty"`
}

type Kaas struct {
        Name    string      `json:"name,omitempty"`
        Id      int64       `json:"kaas_id,omitempty"`
        Project KaasProject `json:"project,omitzero"`
        PackId  int64       `json:"kaas_pack_id,omitempty"`
        Pack    *KaasPack   `json:"pack,omitempty"`

        Region            string `json:"region,omitempty"`
        KubernetesVersion string `json:"kubernetes_version,omitempty"`
        Status            string `json:"status,omitempty"`
}

func (kaas *Kaas) Key() string <span class="cov0" title="0">{
        return fmt.Sprintf("%d-%d-%d", kaas.Project.PublicCloudId, kaas.Project.ProjectId, kaas.Id)
}</span>

type KaasProject struct {
        PublicCloudId int64 `json:"public_cloud_id,omitempty"`
        ProjectId     int64 `json:"id,omitempty"`
}

type InstancePool struct {
        KaasId int64 `json:"kaas_id,omitempty"`
        Id     int64 `json:"instance_pool_id,omitempty"`

        Name             string            `json:"name,omitempty"`
        FlavorName       string            `json:"flavor,omitempty"`
        AvailabilityZone string            `json:"availability_zone,omitempty"`
        MinInstances     int64             `json:"minimum_instances,omitempty"`
        MaxInstances     int64             `json:"maximum_instances,omitempty"`
        Status           string            `json:"status,omitempty"`
        Labels           map[string]string `json:"labels,omitempty"`

        TargetInstances    int64 `json:"target_instances,omitempty"`
        AvailableInstances int64 `json:"available_instances,omitempty"`

        ErrorMessages []string `json:"error_messages,omitempty"`
}

func (instancePool *InstancePool) Key() string <span class="cov0" title="0">{
        return fmt.Sprintf("%d-%d", instancePool.KaasId, instancePool.Id)
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package dynamic

import (
        "encoding/json"
        "fmt"
        "math/big"

        "github.com/hashicorp/terraform-plugin-framework/attr"
        "github.com/hashicorp/terraform-plugin-framework/types"
        "github.com/hashicorp/terraform-plugin-framework/types/basetypes"
)

type UnknownValueHandler func(val attr.Value) ([]byte, error)

func ToJSON(d types.Dynamic) ([]byte, error) <span class="cov0" title="0">{
        return attrValueToJSON(d.UnderlyingValue(), nil)
}</span>

func ToJSONWithUnknownValueHandler(d types.Dynamic, handler UnknownValueHandler) ([]byte, error) <span class="cov0" title="0">{
        return attrValueToJSON(d.UnderlyingValue(), handler)
}</span>

func attrListToJSON(in []attr.Value, handler UnknownValueHandler) ([]json.RawMessage, error) <span class="cov0" title="0">{
        l := make([]json.RawMessage, 0)
        for _, v := range in </span><span class="cov0" title="0">{
                vv, err := attrValueToJSON(v, handler)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">l = append(l, json.RawMessage(vv))</span>
        }
        <span class="cov0" title="0">return l, nil</span>
}

func attrMapToJSON(in map[string]attr.Value, handler UnknownValueHandler) (map[string]json.RawMessage, error) <span class="cov0" title="0">{
        m := map[string]json.RawMessage{}
        for k, v := range in </span><span class="cov0" title="0">{
                vv, err := attrValueToJSON(v, handler)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">m[k] = json.RawMessage(vv)</span>
        }
        <span class="cov0" title="0">return m, nil</span>
}

func attrValueToJSON(val attr.Value, handler UnknownValueHandler) ([]byte, error) <span class="cov0" title="0">{
        if val == nil || val.IsNull() </span><span class="cov0" title="0">{
                return json.Marshal(nil)
        }</span>
        <span class="cov0" title="0">if val.IsUnknown() </span><span class="cov0" title="0">{
                if handler != nil </span><span class="cov0" title="0">{
                        return handler(val)
                }</span>
        }
        <span class="cov0" title="0">switch value := val.(type) </span>{
        case types.Bool:<span class="cov0" title="0">
                return json.Marshal(value.ValueBool())</span>
        case types.String:<span class="cov0" title="0">
                return json.Marshal(value.ValueString())</span>
        case types.Int64:<span class="cov0" title="0">
                return json.Marshal(value.ValueInt64())</span>
        case types.Float64:<span class="cov0" title="0">
                return json.Marshal(value.ValueFloat64())</span>
        case types.Number:<span class="cov0" title="0">
                v, _ := value.ValueBigFloat().Float64()
                return json.Marshal(v)</span>
        case types.List:<span class="cov0" title="0">
                l, err := attrListToJSON(value.Elements(), handler)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return json.Marshal(l)</span>
        case types.Set:<span class="cov0" title="0">
                l, err := attrListToJSON(value.Elements(), handler)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return json.Marshal(l)</span>
        case types.Tuple:<span class="cov0" title="0">
                l, err := attrListToJSON(value.Elements(), handler)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return json.Marshal(l)</span>
        case types.Map:<span class="cov0" title="0">
                m, err := attrMapToJSON(value.Elements(), handler)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return json.Marshal(m)</span>
        case types.Object:<span class="cov0" title="0">
                m, err := attrMapToJSON(value.Attributes(), handler)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return json.Marshal(m)</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("Unhandled type: %T", value)</span>
        }
}

func FromJSON(b []byte, typ attr.Type) (types.Dynamic, error) <span class="cov0" title="0">{
        v, err := attrValueFromJSON(b, typ)
        if err != nil </span><span class="cov0" title="0">{
                return types.Dynamic{}, err
        }</span>
        <span class="cov0" title="0">return types.DynamicValue(v), nil</span>
}

func attrListFromJSON(b []byte, etyp attr.Type) ([]attr.Value, error) <span class="cov0" title="0">{
        var l []json.RawMessage
        if err := json.Unmarshal(b, &amp;l); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">vals := make([]attr.Value, 0)
        for _, b := range l </span><span class="cov0" title="0">{
                val, err := attrValueFromJSON(b, etyp)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">vals = append(vals, val)</span>
        }
        <span class="cov0" title="0">return vals, nil</span>
}

func attrValueFromJSON(b []byte, typ attr.Type) (attr.Value, error) <span class="cov0" title="0">{
        switch typ := typ.(type) </span>{
        case basetypes.BoolType:<span class="cov0" title="0">
                if b == nil || string(b) == "null" </span><span class="cov0" title="0">{
                        return types.BoolNull(), nil
                }</span>
                <span class="cov0" title="0">var v bool
                if err := json.Unmarshal(b, &amp;v); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return types.BoolValue(v), nil</span>
        case basetypes.StringType:<span class="cov0" title="0">
                if b == nil || string(b) == "null" </span><span class="cov0" title="0">{
                        return types.StringNull(), nil
                }</span>
                <span class="cov0" title="0">var v string
                if err := json.Unmarshal(b, &amp;v); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return types.StringValue(v), nil</span>
        case basetypes.Int64Type:<span class="cov0" title="0">
                if b == nil || string(b) == "null" </span><span class="cov0" title="0">{
                        return types.Int64Null(), nil
                }</span>
                <span class="cov0" title="0">var v int64
                if err := json.Unmarshal(b, &amp;v); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return types.Int64Value(v), nil</span>
        case basetypes.Float64Type:<span class="cov0" title="0">
                if b == nil || string(b) == "null" </span><span class="cov0" title="0">{
                        return types.Float64Null(), nil
                }</span>
                <span class="cov0" title="0">var v float64
                if err := json.Unmarshal(b, &amp;v); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return types.Float64Value(v), nil</span>
        case basetypes.NumberType:<span class="cov0" title="0">
                if b == nil || string(b) == "null" </span><span class="cov0" title="0">{
                        return types.NumberNull(), nil
                }</span>
                <span class="cov0" title="0">var v float64
                if err := json.Unmarshal(b, &amp;v); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return types.NumberValue(big.NewFloat(v)), nil</span>
        case basetypes.ListType:<span class="cov0" title="0">
                if b == nil || string(b) == "null" </span><span class="cov0" title="0">{
                        return types.ListNull(typ.ElemType), nil
                }</span>
                <span class="cov0" title="0">vals, err := attrListFromJSON(b, typ.ElemType)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">vv, diags := types.ListValue(typ.ElemType, vals)
                if diags.HasError() </span><span class="cov0" title="0">{
                        diag := diags.Errors()[0]
                        return nil, fmt.Errorf("%s: %s", diag.Summary(), diag.Detail())
                }</span>
                <span class="cov0" title="0">return vv, nil</span>
        case basetypes.SetType:<span class="cov0" title="0">
                if b == nil || string(b) == "null" </span><span class="cov0" title="0">{
                        return types.SetNull(typ.ElemType), nil
                }</span>
                <span class="cov0" title="0">vals, err := attrListFromJSON(b, typ.ElemType)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">vv, diags := types.SetValue(typ.ElemType, vals)
                if diags.HasError() </span><span class="cov0" title="0">{
                        diag := diags.Errors()[0]
                        return nil, fmt.Errorf("%s: %s", diag.Summary(), diag.Detail())
                }</span>
                <span class="cov0" title="0">return vv, nil</span>
        case basetypes.TupleType:<span class="cov0" title="0">
                if b == nil || string(b) == "null" </span><span class="cov0" title="0">{
                        return types.TupleNull(typ.ElemTypes), nil
                }</span>
                <span class="cov0" title="0">var l []json.RawMessage
                if err := json.Unmarshal(b, &amp;l); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">if len(l) != len(typ.ElemTypes) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("tuple element size not match: json=%d, type=%d", len(l), len(typ.ElemTypes))
                }</span>
                <span class="cov0" title="0">vals := make([]attr.Value, 0)
                for i, b := range l </span><span class="cov0" title="0">{
                        val, err := attrValueFromJSON(b, typ.ElemTypes[i])
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">vals = append(vals, val)</span>
                }
                <span class="cov0" title="0">vv, diags := types.TupleValue(typ.ElemTypes, vals)
                if diags.HasError() </span><span class="cov0" title="0">{
                        diag := diags.Errors()[0]
                        return nil, fmt.Errorf("%s: %s", diag.Summary(), diag.Detail())
                }</span>
                <span class="cov0" title="0">return vv, nil</span>
        case basetypes.MapType:<span class="cov0" title="0">
                if b == nil || string(b) == "null" </span><span class="cov0" title="0">{
                        return types.MapNull(typ.ElemType), nil
                }</span>
                <span class="cov0" title="0">var m map[string]json.RawMessage
                if err := json.Unmarshal(b, &amp;m); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">vals := map[string]attr.Value{}
                for k, v := range m </span><span class="cov0" title="0">{
                        val, err := attrValueFromJSON(v, typ.ElemType)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">vals[k] = val</span>
                }
                <span class="cov0" title="0">vv, diags := types.MapValue(typ.ElemType, vals)
                if diags.HasError() </span><span class="cov0" title="0">{
                        diag := diags.Errors()[0]
                        return nil, fmt.Errorf("%s: %s", diag.Summary(), diag.Detail())
                }</span>
                <span class="cov0" title="0">return vv, nil</span>
        case basetypes.ObjectType:<span class="cov0" title="0">
                if b == nil || string(b) == "null" </span><span class="cov0" title="0">{
                        return types.ObjectNull(typ.AttributeTypes()), nil
                }</span>
                <span class="cov0" title="0">var m map[string]json.RawMessage
                if err := json.Unmarshal(b, &amp;m); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">vals := map[string]attr.Value{}
                attrTypes := typ.AttributeTypes()

                for k, attrType := range attrTypes </span><span class="cov0" title="0">{
                        val, err := attrValueFromJSON(m[k], attrType)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">vals[k] = val</span>
                }
                <span class="cov0" title="0">vv, diags := types.ObjectValue(attrTypes, vals)
                if diags.HasError() </span><span class="cov0" title="0">{
                        diag := diags.Errors()[0]
                        return nil, fmt.Errorf("%s: %s", diag.Summary(), diag.Detail())
                }</span>
                <span class="cov0" title="0">return vv, nil</span>
        case basetypes.DynamicType:<span class="cov0" title="0">
                if b == nil || string(b) == "null" </span><span class="cov0" title="0">{
                        return types.DynamicNull(), nil
                }</span>
                <span class="cov0" title="0">_, vv, err := attrValueFromJSONImplied(b)
                return vv, err</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("Unhandled type: %T", typ)</span>
        }
}

// FromJSONImplied is similar to FromJSON, while it is for typeless case.
// In which case, the following type conversion rules are applied (Go -&gt; TF):
// - bool: bool
// - float64: number
// - string: string
// - []interface{}: tuple
// - map[string]interface{}: object
// - nil: null (dynamic)
// - &lt;unknown&gt;: unknown (dynamic)
func FromJSONImplied(b []byte) (types.Dynamic, error) <span class="cov0" title="0">{
        _, v, err := attrValueFromJSONImplied(b)
        if err != nil </span><span class="cov0" title="0">{
                return types.Dynamic{}, err
        }</span>
        <span class="cov0" title="0">return types.DynamicValue(v), nil</span>
}

func attrValueFromJSONImplied(b []byte) (attr.Type, attr.Value, error) <span class="cov0" title="0">{
        if string(b) == "null" </span><span class="cov0" title="0">{
                return types.DynamicType, types.DynamicNull(), nil
        }</span>

        <span class="cov0" title="0">var object map[string]json.RawMessage
        if err := json.Unmarshal(b, &amp;object); err == nil </span><span class="cov0" title="0">{
                attrTypes := map[string]attr.Type{}
                attrVals := map[string]attr.Value{}
                for k, v := range object </span><span class="cov0" title="0">{
                        attrTypes[k], attrVals[k], err = attrValueFromJSONImplied(v)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, nil, err
                        }</span>
                }
                <span class="cov0" title="0">typ := types.ObjectType{AttrTypes: attrTypes}
                val, diags := types.ObjectValue(attrTypes, attrVals)
                if diags.HasError() </span><span class="cov0" title="0">{
                        diag := diags.Errors()[0]
                        return nil, nil, fmt.Errorf("%s: %s", diag.Summary(), diag.Detail())
                }</span>
                <span class="cov0" title="0">return typ, val, nil</span>
        }

        <span class="cov0" title="0">var array []json.RawMessage
        if err := json.Unmarshal(b, &amp;array); err == nil </span><span class="cov0" title="0">{
                eTypes := []attr.Type{}
                eVals := []attr.Value{}
                for _, e := range array </span><span class="cov0" title="0">{
                        eType, eVal, err := attrValueFromJSONImplied(e)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, nil, err
                        }</span>
                        <span class="cov0" title="0">eTypes = append(eTypes, eType)
                        eVals = append(eVals, eVal)</span>
                }
                <span class="cov0" title="0">typ := types.TupleType{ElemTypes: eTypes}
                val, diags := types.TupleValue(eTypes, eVals)
                if diags.HasError() </span><span class="cov0" title="0">{
                        diag := diags.Errors()[0]
                        return nil, nil, fmt.Errorf("%s: %s", diag.Summary(), diag.Detail())
                }</span>
                <span class="cov0" title="0">return typ, val, nil</span>
        }

        // Primitives
        <span class="cov0" title="0">var v interface{}
        if err := json.Unmarshal(b, &amp;v); err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("failed to unmarshal %s: %v", string(b), err)
        }</span>

        <span class="cov0" title="0">switch v := v.(type) </span>{
        case bool:<span class="cov0" title="0">
                return types.BoolType, types.BoolValue(v), nil</span>
        case float64:<span class="cov0" title="0">
                return types.NumberType, types.NumberValue(big.NewFloat(v)), nil</span>
        case string:<span class="cov0" title="0">
                if v == "&lt;unknown&gt;" </span><span class="cov0" title="0">{
                        return types.DynamicType, types.DynamicUnknown(), nil
                }</span>
                <span class="cov0" title="0">return types.StringType, types.StringValue(v), nil</span>
        case nil:<span class="cov0" title="0">
                return types.DynamicType, types.DynamicNull(), nil</span>
        default:<span class="cov0" title="0">
                return nil, nil, fmt.Errorf("Unhandled type: %T", v)</span>
        }
}

// IsFullyKnown returns true if `val` is known. If `val` is an aggregate type,
// IsFullyKnown only returns true if all elements and attributes are known, as
// well.
func IsFullyKnown(val attr.Value) bool <span class="cov0" title="0">{
        if val == nil </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">if val.IsUnknown() </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">switch v := val.(type) </span>{
        case types.Dynamic:<span class="cov0" title="0">
                return IsFullyKnown(v.UnderlyingValue())</span>
        case types.List:<span class="cov0" title="0">
                for _, e := range v.Elements() </span><span class="cov0" title="0">{
                        if !IsFullyKnown(e) </span><span class="cov0" title="0">{
                                return false
                        }</span>
                }
                <span class="cov0" title="0">return true</span>
        case types.Set:<span class="cov0" title="0">
                for _, e := range v.Elements() </span><span class="cov0" title="0">{
                        if !IsFullyKnown(e) </span><span class="cov0" title="0">{
                                return false
                        }</span>
                }
                <span class="cov0" title="0">return true</span>
        case types.Tuple:<span class="cov0" title="0">
                for _, e := range v.Elements() </span><span class="cov0" title="0">{
                        if !IsFullyKnown(e) </span><span class="cov0" title="0">{
                                return false
                        }</span>
                }
                <span class="cov0" title="0">return true</span>
        case types.Map:<span class="cov0" title="0">
                for _, e := range v.Elements() </span><span class="cov0" title="0">{
                        if !IsFullyKnown(e) </span><span class="cov0" title="0">{
                                return false
                        }</span>
                }
                <span class="cov0" title="0">return true</span>
        case types.Object:<span class="cov0" title="0">
                for _, e := range v.Attributes() </span><span class="cov0" title="0">{
                        if !IsFullyKnown(e) </span><span class="cov0" title="0">{
                                return false
                        }</span>
                }
                <span class="cov0" title="0">return true</span>
        default:<span class="cov0" title="0">
                return true</span>
        }
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package dynamic

import (
        "context"
        "fmt"

        "github.com/hashicorp/terraform-plugin-framework/schema/validator"
        "github.com/hashicorp/terraform-plugin-framework/types/basetypes"
)

type DynamicObjectValidator struct {
        Strict bool
}

func NewDynamicObjectValidator() *DynamicObjectValidator <span class="cov0" title="0">{
        return &amp;DynamicObjectValidator{}
}</span>

var _ validator.Dynamic = (*DynamicObjectValidator)(nil)

func (dv *DynamicObjectValidator) Description(context.Context) string <span class="cov0" title="0">{
        return ""
}</span>

func (dv *DynamicObjectValidator) MarkdownDescription(context.Context) string <span class="cov0" title="0">{
        return ""
}</span>

func (dv *DynamicObjectValidator) ValidateDynamic(ctx context.Context, req validator.DynamicRequest, res *validator.DynamicResponse) <span class="cov0" title="0">{
        if req.ConfigValue.IsNull() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">obj, isObject := req.ConfigValue.UnderlyingValue().(basetypes.ObjectValue)
        if !isObject </span><span class="cov0" title="0">{
                res.Diagnostics.AddAttributeError(req.Path, "Type mismatch", fmt.Sprintf("Attribute should be an object and not a %v", obj.Type(ctx)))
                return
        }</span>

        <span class="cov0" title="0">elems := obj.Attributes()
        if len(elems) == 0 </span><span class="cov0" title="0">{
                res.Diagnostics.AddAttributeError(req.Path, "configuration is empty", "configuration needs to have at least one element, delete the field if you do not want to configure it")
        }</span>
        <span class="cov0" title="0">for _, value := range elems </span><span class="cov0" title="0">{
                _, isList := value.(basetypes.ListValue)
                if isList </span><span class="cov0" title="0">{
                        res.Diagnostics.AddAttributeError(req.Path, "Wrong type", "please use tuple when using a list inside a dynamic object")
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package provider

import (
        "context"
        "os"
        "terraform-provider-infomaniak/internal/provider/registry"

        "github.com/hashicorp/terraform-plugin-framework/datasource"
        "github.com/hashicorp/terraform-plugin-framework/function"
        "github.com/hashicorp/terraform-plugin-framework/path"
        "github.com/hashicorp/terraform-plugin-framework/provider"
        "github.com/hashicorp/terraform-plugin-framework/provider/schema"
        "github.com/hashicorp/terraform-plugin-framework/providerserver"
        "github.com/hashicorp/terraform-plugin-framework/resource"
        "github.com/hashicorp/terraform-plugin-framework/types"
        "github.com/hashicorp/terraform-plugin-go/tfprotov6"
        "github.com/hashicorp/terraform-plugin-log/tflog"
)

// Environment variables used by the provider
const (
        INFOMANIAK_TOKEN = "INFOMANIAK_TOKEN"
        INFOMANIAK_HOST  = "INFOMANIAK_HOST"
)

// Ensure IkProvider satisfies various kaas interfaces.
var (
        _ provider.Provider              = &amp;IkProvider{}
        _ provider.ProviderWithFunctions = &amp;IkProvider{}

        DefaultHost = "https://api.infomaniak.com"
)

// IkProvider defines the kaas implementation.
type IkProvider struct {
        // version is set to the kaas version on release, "dev" when the
        // kaas is built and ran locally, and "test" when running acceptance
        // testing.
        version string

        ik *IkProviderData
}

// IkProviderData defines the data associated with the provider
type IkProviderData struct {
        Version types.String `tfsdk:"version"`
        Data    *IkProviderModel
}

type IkProviderModel struct {
        Host  types.String `tfsdk:"host"`
        Token types.String `tfsdk:"token"`
}

func (p *IkProvider) Metadata(ctx context.Context, req provider.MetadataRequest, resp *provider.MetadataResponse) <span class="cov0" title="0">{
        resp.TypeName = "infomaniak"
        resp.Version = p.version
}</span>

func (p *IkProvider) Schema(ctx context.Context, req provider.SchemaRequest, resp *provider.SchemaResponse) <span class="cov0" title="0">{
        resp.Schema = schema.Schema{
                Attributes: map[string]schema.Attribute{
                        "host": schema.StringAttribute{
                                Optional:            true,
                                Description:         "The base endpoint for Infomaniak's API (including scheme).",
                                MarkdownDescription: "The base endpoint for Infomaniak's API (including scheme).",
                        },
                        "token": schema.StringAttribute{
                                Required:            os.Getenv(INFOMANIAK_TOKEN) == "",
                                Optional:            os.Getenv(INFOMANIAK_TOKEN) != "",
                                Sensitive:           true,
                                Description:         "The token used for authenticating against Infomaniak's API.",
                                MarkdownDescription: "The token used for authenticating against Infomaniak's API.",
                        },
                },
                Description:         "Infomaniak's provider.",
                MarkdownDescription: "Infomaniak's provider.",
        }
}</span>

func (p *IkProvider) Configure(ctx context.Context, req provider.ConfigureRequest, resp *provider.ConfigureResponse) <span class="cov0" title="0">{
        tflog.Debug(ctx, "Provider configuration started")

        if p.ik != nil </span><span class="cov0" title="0">{
                tflog.Debug(ctx, "Provider already present, skipping configuration")
                resp.DataSourceData = p.ik
                resp.ResourceData = p.ik
                return
        }</span>

        <span class="cov0" title="0">var data IkProviderModel

        resp.Diagnostics.Append(req.Config.Get(ctx, &amp;data)...)

        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">if data.Host.IsUnknown() </span><span class="cov0" title="0">{
                resp.Diagnostics.AddAttributeError(
                        path.Root("host"),
                        "Unknown Infomaniak API Host",
                        "The provider cannot create the Infomaniak API client as there is an unknown configuration value for the Infomaniak API host. "+
                                "Either target apply the source of the value first, set the value statically in the configuration, or use the INFOMANIAK_HOST environment variable.",
                )
        }</span>

        <span class="cov0" title="0">if data.Token.IsUnknown() </span><span class="cov0" title="0">{
                resp.Diagnostics.AddAttributeError(
                        path.Root("token"),
                        "Unknown Infomaniak API Token",
                        "The provider cannot create the Infomaniak API client as there is an unknown configuration value for the Infomaniak API username. "+
                                "Either target apply the source of the value first, set the value statically in the configuration, or use the INFOMANIAK_TOKEN environment variable.",
                )
        }</span>

        <span class="cov0" title="0">if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">host := os.Getenv(INFOMANIAK_HOST)
        token := os.Getenv(INFOMANIAK_TOKEN)

        if host == "" </span><span class="cov0" title="0">{
                if !data.Host.IsNull() </span><span class="cov0" title="0">{
                        host = data.Host.ValueString()
                }</span> else<span class="cov0" title="0"> {
                        host = DefaultHost
                }</span>
        }

        <span class="cov0" title="0">if token == "" &amp;&amp; !data.Token.IsNull() </span><span class="cov0" title="0">{
                token = data.Token.ValueString()
        }</span>

        <span class="cov0" title="0">data.Host = types.StringValue(host)
        data.Token = types.StringValue(token)

        if token == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddAttributeError(
                        path.Root("username"),
                        "Missing Infomaniak API Username",
                        "The provider cannot create the Infomaniak API client as there is a missing or empty value for the Infomaniak API username. "+
                                "Set the username value in the configuration or use the INFOMANIAK_TOKEN environment variable. "+
                                "If either is already set, ensure the value is not empty.",
                )
        }</span>

        <span class="cov0" title="0">if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">p.ik = &amp;IkProviderData{
                Version: types.StringValue(p.version),
                Data:    &amp;data,
        }

        resp.DataSourceData = p.ik
        resp.ResourceData = p.ik</span>
}

func (p *IkProvider) Resources(ctx context.Context) []func() resource.Resource <span class="cov0" title="0">{
        return registry.GetResources()
}</span>

func (p *IkProvider) DataSources(ctx context.Context) []func() datasource.DataSource <span class="cov0" title="0">{
        return registry.GetDataSources()
}</span>

func (p *IkProvider) Functions(ctx context.Context) []func() function.Function <span class="cov0" title="0">{
        return nil
}</span>

func New(version string) func() provider.Provider <span class="cov0" title="0">{
        return func() provider.Provider </span><span class="cov0" title="0">{
                return &amp;IkProvider{
                        version: version,
                }
        }</span>
}

func ProtoV6ProviderFactories() map[string]func() (tfprotov6.ProviderServer, error) <span class="cov0" title="0">{
        return map[string]func() (tfprotov6.ProviderServer, error){
                "infomaniak": providerserver.NewProtocol6WithError(New("test")()),
        }
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">package registry

import (
        "github.com/hashicorp/terraform-plugin-framework/datasource"
        "github.com/hashicorp/terraform-plugin-framework/resource"
)

var resources []func() resource.Resource
var datasources []func() datasource.DataSource

func RegisterResource(F func() resource.Resource) <span class="cov0" title="0">{
        resources = append(resources, F)
}</span>

func RegisterDataSource(F func() datasource.DataSource) <span class="cov0" title="0">{
        datasources = append(datasources, F)
}</span>

func GetResources() []func() resource.Resource <span class="cov0" title="0">{
        return resources
}</span>

func GetDataSources() []func() datasource.DataSource <span class="cov0" title="0">{
        return datasources
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">package provider

import (
        "fmt"
        "os"
        "terraform-provider-infomaniak/internal/apis"
)

func GetApiClient(providerData any) (*apis.Client, error) <span class="cov0" title="0">{
        data, ok := providerData.(*IkProviderData)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("expected *provider.IkProviderData, got: %T", providerData)
        }</span>

        <span class="cov0" title="0">mocked := os.Getenv("TF_TESTS_MOCKED")
        if data.Version.ValueString() == "dev" &amp;&amp; mocked == "true" </span><span class="cov0" title="0">{
                return apis.NewMockClient(), nil
        }</span>

        <span class="cov0" title="0">client := apis.NewClient(data.Data.Host.ValueString(), data.Data.Token.ValueString(), data.Version.ValueString())

        return client, nil</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package dbaas

import (
        "context"
        "errors"
        "fmt"
        "strconv"
        "strings"
        "terraform-provider-infomaniak/internal/apis"
        "terraform-provider-infomaniak/internal/apis/dbaas"
        "terraform-provider-infomaniak/internal/provider"

        "github.com/hashicorp/terraform-plugin-framework/path"
        "github.com/hashicorp/terraform-plugin-framework/resource"

        "github.com/hashicorp/terraform-plugin-framework/types"
)

var (
        _ resource.Resource                = &amp;dbaasBackupScheduleResource{}
        _ resource.ResourceWithConfigure   = &amp;dbaasBackupScheduleResource{}
        _ resource.ResourceWithImportState = &amp;dbaasBackupScheduleResource{}
)

func NewDBaasBackupScheduleResource() resource.Resource <span class="cov0" title="0">{
        return &amp;dbaasBackupScheduleResource{}
}</span>

type dbaasBackupScheduleResource struct {
        client *apis.Client
}

type DBaasBackupScheduleModel struct {
        PublicCloudId        types.Int64 `tfsdk:"public_cloud_id"`
        PublicCloudProjectId types.Int64 `tfsdk:"public_cloud_project_id"`
        DbaasId              types.Int64 `tfsdk:"dbaas_id"`

        Id            types.Int64  `tfsdk:"id"`
        Name          types.String `tfsdk:"name"`
        ScheduledAt   types.String `tfsdk:"scheduled_at"`
        Retention     types.Int64  `tfsdk:"retention"`
        IsPitrEnabled types.Bool   `tfsdk:"is_pitr_enabled"`
}

func (model *DBaasBackupScheduleModel) fill(backupSchedule *dbaas.DBaasBackupSchedule) <span class="cov0" title="0">{
        model.ScheduledAt = types.StringPointerValue(backupSchedule.ScheduledAt)
        model.Retention = types.Int64PointerValue(backupSchedule.Retention)
        model.IsPitrEnabled = types.BoolPointerValue(backupSchedule.IsPitrEnabled)
        model.Name = types.StringPointerValue(backupSchedule.Name)
        model.Id = types.Int64PointerValue(backupSchedule.Id)
}</span>

func (r *dbaasBackupScheduleResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) <span class="cov0" title="0">{
        resp.TypeName = req.ProviderTypeName + "_dbaas_backup_schedule"
}</span>

// Configure adds the provider configured client to the data source.
func (r *dbaasBackupScheduleResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) <span class="cov0" title="0">{
        // Add a nil check when handling ProviderData because Terraform
        // sets that data after it calls the ConfigureProvider RPC.
        if req.ProviderData == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">client, err := provider.GetApiClient(req.ProviderData)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unexpected Resource Configure Type",
                        err.Error(),
                )
                return
        }</span>

        <span class="cov0" title="0">r.client = client</span>
}

func (r *dbaasBackupScheduleResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) <span class="cov0" title="0">{
        resp.Schema = getDbaasBackupScheduleResourceSchema()
}</span>

func (r *dbaasBackupScheduleResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) <span class="cov0" title="0">{
        var data DBaasBackupScheduleModel

        // Read Terraform plan data into the model
        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)

        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">input := &amp;dbaas.DBaasBackupSchedule{
                ScheduledAt:   data.ScheduledAt.ValueStringPointer(),
                Retention:     data.Retention.ValueInt64Pointer(),
                IsPitrEnabled: data.IsPitrEnabled.ValueBoolPointer(),
        }

        scheduleId, err := r.client.DBaas.CreateDBaasScheduleBackup(
                data.PublicCloudId.ValueInt64(),
                data.PublicCloudProjectId.ValueInt64(),
                data.DbaasId.ValueInt64(),
                input,
        )
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error when creating Backup Schedule",
                        err.Error(),
                )
                return
        }</span>

        <span class="cov0" title="0">data.Id = types.Int64Value(scheduleId)

        scheduleBackup, err := r.client.DBaas.GetDBaasScheduleBackup(
                data.PublicCloudId.ValueInt64(),
                data.PublicCloudProjectId.ValueInt64(),
                data.DbaasId.ValueInt64(),
                data.Id.ValueInt64(),
        )
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error when getting Backup Schedule",
                        err.Error(),
                )
                return
        }</span>

        <span class="cov0" title="0">data.fill(scheduleBackup)

        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *dbaasBackupScheduleResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) <span class="cov0" title="0">{
        var data DBaasBackupScheduleModel
        var state DBaasBackupScheduleModel

        // Read Terraform plan data into the model
        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;state)...)

        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">input := &amp;dbaas.DBaasBackupSchedule{
                ScheduledAt:   data.ScheduledAt.ValueStringPointer(),
                Retention:     data.Retention.ValueInt64Pointer(),
                IsPitrEnabled: data.IsPitrEnabled.ValueBoolPointer(),
        }

        ok, err := r.client.DBaas.UpdateDBaasScheduleBackup(
                data.PublicCloudId.ValueInt64(),
                data.PublicCloudProjectId.ValueInt64(),
                data.DbaasId.ValueInt64(),
                data.Id.ValueInt64(),
                input,
        )
        if !ok &amp;&amp; err == nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError("Unknown Backup Schedule error", "")
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error when updating Backup Schedule",
                        err.Error(),
                )
                return
        }</span>

        <span class="cov0" title="0">scheduleBackup, err := r.client.DBaas.GetDBaasScheduleBackup(
                data.PublicCloudId.ValueInt64(),
                data.PublicCloudProjectId.ValueInt64(),
                data.DbaasId.ValueInt64(),
                data.Id.ValueInt64(),
        )
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error when getting Backup Schedule",
                        err.Error(),
                )
                return
        }</span>

        <span class="cov0" title="0">state.fill(scheduleBackup)

        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;state)...)</span>
}

func (r *dbaasBackupScheduleResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) <span class="cov0" title="0">{
        var state DBaasBackupScheduleModel

        // Read Terraform plan data into the model
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;state)...)

        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">scheduleBackup, err := r.client.DBaas.GetDBaasScheduleBackup(
                state.PublicCloudId.ValueInt64(),
                state.PublicCloudProjectId.ValueInt64(),
                state.DbaasId.ValueInt64(),
                state.Id.ValueInt64(),
        )
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error when getting Backup Schedule",
                        err.Error(),
                )
                return
        }</span>

        <span class="cov0" title="0">state.fill(scheduleBackup)

        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;state)...)</span>
}

func (r *dbaasBackupScheduleResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) <span class="cov0" title="0">{
        var state DBaasBackupScheduleModel

        // Read Terraform prior state data into the model
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;state)...)

        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // DeleteDBaas API call logic
        <span class="cov0" title="0">_, err := r.client.DBaas.DeleteDBaasScheduleBackup(
                state.PublicCloudId.ValueInt64(),
                state.PublicCloudProjectId.ValueInt64(),
                state.DbaasId.ValueInt64(),
                state.Id.ValueInt64(),
        )
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error when deleting DBaaS backup schedule",
                        err.Error(),
                )
                return
        }</span>

        <span class="cov0" title="0">resp.Diagnostics.Append(resp.State.Set(ctx, &amp;state)...)</span>
}

func (r *dbaasBackupScheduleResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) <span class="cov0" title="0">{
        idParts := strings.Split(req.ID, ",")

        if len(idParts) != 4 || idParts[0] == "" || idParts[1] == "" || idParts[2] == "" || idParts[3] == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unexpected Import Identifier",
                        fmt.Sprintf("Expected import identifier with format: public_cloud_id,public_cloud_project_id,id. Got: %q", req.ID),
                )
                return
        }</span>

        <span class="cov0" title="0">var errorList error

        publicCloudId, err := strconv.ParseInt(idParts[0], 10, 64)
        errorList = errors.Join(errorList, err)
        publicCloudProjectId, err := strconv.ParseInt(idParts[1], 10, 64)
        errorList = errors.Join(errorList, err)
        dbaasId, err := strconv.ParseInt(idParts[2], 10, 64)
        errorList = errors.Join(errorList, err)
        id, err := strconv.ParseInt(idParts[3], 10, 64)
        errorList = errors.Join(errorList, err)

        if errorList != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unexpected Import Identifier",
                        fmt.Sprintf("Expected import identifier with format: public_cloud_id,public_cloud_project_id,dbaas_id,id. Got: %q", req.ID),
                )
                return
        }</span>

        <span class="cov0" title="0">resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("public_cloud_id"), publicCloudId)...)
        resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("public_cloud_project_id"), publicCloudProjectId)...)
        resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("dbaas_id"), dbaasId)...)
        resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("id"), id)...)</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package dbaas

import (
        "github.com/hashicorp/terraform-plugin-framework/resource/schema"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/boolplanmodifier"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/int64planmodifier"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
)

func getDbaasBackupScheduleResourceSchema() schema.Schema <span class="cov0" title="0">{
        return schema.Schema{
                Attributes: map[string]schema.Attribute{
                        "public_cloud_id": schema.Int64Attribute{
                                Required:            true,
                                MarkdownDescription: "The id of the public cloud",
                                PlanModifiers: []planmodifier.Int64{
                                        int64planmodifier.RequiresReplace(),
                                },
                        },
                        "public_cloud_project_id": schema.Int64Attribute{
                                Required:            true,
                                MarkdownDescription: "The id of the public cloud project",
                                PlanModifiers: []planmodifier.Int64{
                                        int64planmodifier.RequiresReplace(),
                                },
                        },
                        "dbaas_id": schema.Int64Attribute{
                                Required:            true,
                                MarkdownDescription: "The id of the dbaas",
                                PlanModifiers: []planmodifier.Int64{
                                        int64planmodifier.RequiresReplace(),
                                },
                        },
                        "id": schema.Int64Attribute{
                                Computed:            true,
                                MarkdownDescription: "BackupSchedule identifier",
                                PlanModifiers: []planmodifier.Int64{
                                        int64planmodifier.UseStateForUnknown(),
                                },
                        },
                        "name": schema.StringAttribute{
                                Computed:            true,
                                MarkdownDescription: "Name of the backup",
                                PlanModifiers: []planmodifier.String{
                                        stringplanmodifier.UseStateForUnknown(),
                                },
                        },
                        "scheduled_at": schema.StringAttribute{
                                Required:            true,
                                MarkdownDescription: "Use the given time as the time to create the scheduled backup (24 hour, UTC)",
                                PlanModifiers: []planmodifier.String{
                                        stringplanmodifier.UseStateForUnknown(),
                                },
                        },
                        "retention": schema.Int64Attribute{
                                Required:            true,
                                MarkdownDescription: "The number of backups to keep for the schedule",
                                PlanModifiers: []planmodifier.Int64{
                                        int64planmodifier.UseStateForUnknown(),
                                },
                        },
                        "is_pitr_enabled": schema.BoolAttribute{
                                Required:            true,
                                MarkdownDescription: "Enable/Disable point in time recovery",
                                PlanModifiers: []planmodifier.Bool{
                                        boolplanmodifier.UseStateForUnknown(),
                                },
                        },
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">package dbaas

import (
        "context"
        "terraform-provider-infomaniak/internal/apis"
        "terraform-provider-infomaniak/internal/provider"

        "github.com/hashicorp/terraform-plugin-framework/datasource"
        "github.com/hashicorp/terraform-plugin-framework/types"
)

// Ensure the implementation satisfies the expected interfaces.
var (
        _ datasource.DataSource              = &amp;dbaasConstsDataSource{}
        _ datasource.DataSourceWithConfigure = &amp;dbaasConstsDataSource{}
)

type dbaasConstsDataSource struct {
        client *apis.Client
}

// NewDBaasDataSource is a helper function to simplify the provider implementation.
func NewDBaasConstsDataSource() datasource.DataSource <span class="cov0" title="0">{
        return &amp;dbaasConstsDataSource{}
}</span>

// Configure adds the provider configured client to the data source.
func (d *dbaasConstsDataSource) Configure(_ context.Context, req datasource.ConfigureRequest, resp *datasource.ConfigureResponse) <span class="cov0" title="0">{
        // Add a nil check when handling ProviderData because Terraform
        // sets that data after it calls the ConfigureProvider RPC.
        if req.ProviderData == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">client, err := provider.GetApiClient(req.ProviderData)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unexpected Data Source Configure Type",
                        err.Error(),
                )
                return
        }</span>

        <span class="cov0" title="0">d.client = client</span>
}

type DBaasConstsDataModel struct {
        Regions types.List   `tfsdk:"regions"`
        Types   []DBaasTypes `tfsdk:"types"`
}

type DBaasTypes struct {
        Name     types.String `tfsdk:"name"`
        Versions types.List   `tfsdk:"versions"`
}

// Schema defines the schema for the data source.
func (d *dbaasConstsDataSource) Schema(ctx context.Context, _ datasource.SchemaRequest, resp *datasource.SchemaResponse) <span class="cov0" title="0">{
        resp.Schema = getDbaasConstantsDataSourceSchema()
}</span>

// Read refreshes the Terraform state with the latest data.
func (d *dbaasConstsDataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) <span class="cov0" title="0">{
        var data DBaasConstsDataModel

        resp.Diagnostics.Append(req.Config.Get(ctx, &amp;data)...)

        regions, err := d.client.DBaas.GetDbaasRegions()
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unable to find DBaaS regions",
                        err.Error(),
                )
                return
        }</span>

        <span class="cov0" title="0">tfregions, diags := types.ListValueFrom(ctx, types.StringType, regions)
        resp.Diagnostics.Append(diags...)
        data.Regions = tfregions

        dbaasTypes, err := d.client.DBaas.GetDbaasTypes()
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unable to find DBaaS types",
                        err.Error(),
                )
                return
        }</span>

        <span class="cov0" title="0">var dbaasPacks []DBaasTypes
        for _, dbType := range dbaasTypes </span><span class="cov0" title="0">{
                versioned, diags := types.ListValueFrom(ctx, types.StringType, dbType.Versions)
                resp.Diagnostics.Append(diags...)
                dbaasPacks = append(dbaasPacks, DBaasTypes{
                        Name:     types.StringValue(dbType.Name),
                        Versions: versioned,
                })
        }</span>
        <span class="cov0" title="0">data.Types = dbaasPacks

        // Set state
        diags = resp.State.Set(ctx, &amp;data)
        resp.Diagnostics.Append(diags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>
}

// Metadata returns the data source type name.
func (d *dbaasConstsDataSource) Metadata(_ context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) <span class="cov0" title="0">{
        resp.TypeName = req.ProviderTypeName + "_dbaas_constants"
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">package dbaas

import (
        "github.com/hashicorp/terraform-plugin-framework/datasource/schema"
        "github.com/hashicorp/terraform-plugin-framework/types"
)

func getDbaasConstantsDataSourceSchema() schema.Schema <span class="cov0" title="0">{
        return schema.Schema{
                Attributes: map[string]schema.Attribute{
                        "types": schema.ListNestedAttribute{
                                NestedObject: schema.NestedAttributeObject{
                                        Attributes: map[string]schema.Attribute{
                                                "name": schema.StringAttribute{
                                                        Computed: true,
                                                },
                                                "versions": schema.ListAttribute{
                                                        Computed:    true,
                                                        ElementType: types.StringType,
                                                },
                                        },
                                },
                                Computed: true,
                        },
                        "regions": schema.ListAttribute{
                                ElementType: types.StringType,
                                Computed:    true,
                        },
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file21" style="display: none">package dbaas

import (
        "context"
        "terraform-provider-infomaniak/internal/apis"
        "terraform-provider-infomaniak/internal/apis/dbaas"
        "terraform-provider-infomaniak/internal/provider"

        "github.com/hashicorp/terraform-plugin-framework/datasource"
        "github.com/hashicorp/terraform-plugin-framework/types"
)

// Ensure the implementation satisfies the expected interfaces.
var (
        _ datasource.DataSource              = &amp;dbaasDataSource{}
        _ datasource.DataSourceWithConfigure = &amp;dbaasDataSource{}
)

type dbaasDataSource struct {
        client *apis.Client
}

// NewDBaasDataSource is a helper function to simplify the provider implementation.
func NewDBaasDataSource() datasource.DataSource <span class="cov0" title="0">{
        return &amp;dbaasDataSource{}
}</span>

// Configure adds the provider configured client to the data source.
func (d *dbaasDataSource) Configure(_ context.Context, req datasource.ConfigureRequest, resp *datasource.ConfigureResponse) <span class="cov0" title="0">{
        // Add a nil check when handling ProviderData because Terraform
        // sets that data after it calls the ConfigureProvider RPC.
        if req.ProviderData == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">client, err := provider.GetApiClient(req.ProviderData)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unexpected Data Source Configure Type",
                        err.Error(),
                )
                return
        }</span>

        <span class="cov0" title="0">d.client = client</span>
}

type DBaasDataModel struct {
        PublicCloudId        types.Int64  `tfsdk:"public_cloud_id"`
        PublicCloudProjectId types.Int64  `tfsdk:"public_cloud_project_id"`
        Id                   types.Int64  `tfsdk:"id"`
        KubernetesIdentifier types.String `tfsdk:"kube_identifier"`

        Name     types.String `tfsdk:"name"`
        PackName types.String `tfsdk:"pack_name"`
        Region   types.String `tfsdk:"region"`
        Type     types.String `tfsdk:"type"`
        Version  types.String `tfsdk:"version"`

        Host types.String `tfsdk:"host"`
        Port types.String `tfsdk:"port"`
        User types.String `tfsdk:"user"`
        Ca   types.String `tfsdk:"ca"`

        AllowedCIDRs types.List `tfsdk:"allowed_cidrs"`
}

func (data *DBaasDataModel) fill(obj *dbaas.DBaaS) <span class="cov0" title="0">{
        data.Region = types.StringValue(obj.Region)
        data.Name = types.StringValue(obj.Name)
        data.PackName = types.StringValue(obj.Pack.Name)
        data.Region = types.StringValue(obj.Region)
        data.Type = types.StringValue(obj.Type)
        data.Version = types.StringValue(obj.Version)
        if obj.Connection != nil </span><span class="cov0" title="0">{
                data.Host = types.StringValue(obj.Connection.Host)
                data.Port = types.StringValue(obj.Connection.Port)
                data.User = types.StringValue(obj.Connection.User)
                data.Ca = types.StringValue(obj.Connection.Ca)
        }</span>
        <span class="cov0" title="0">data.KubernetesIdentifier = types.StringValue(obj.KubernetesIdentifier)</span>
}

// Schema defines the schema for the data source.
func (d *dbaasDataSource) Schema(ctx context.Context, _ datasource.SchemaRequest, resp *datasource.SchemaResponse) <span class="cov0" title="0">{
        resp.Schema = getDbaasDataSourceSchema()
}</span>

// Read refreshes the Terraform state with the latest data.
func (d *dbaasDataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) <span class="cov0" title="0">{
        var data DBaasDataModel

        resp.Diagnostics.Append(req.Config.Get(ctx, &amp;data)...)

        obj, err := d.client.DBaas.GetDBaaS(
                data.PublicCloudId.ValueInt64(),
                data.PublicCloudProjectId.ValueInt64(),
                data.Id.ValueInt64(),
        )
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unable to find DBaaS",
                        err.Error(),
                )
                return
        }</span>

        <span class="cov0" title="0">data.fill(obj)

        filteredIps, err := d.client.DBaas.GetIpFilters(
                data.PublicCloudId.ValueInt64(),
                data.PublicCloudProjectId.ValueInt64(),
                data.Id.ValueInt64(),
        )
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error when reading DBaaS filtered IPs",
                        err.Error(),
                )
                return
        }</span>

        <span class="cov0" title="0">listFilteredIps, diags := types.ListValueFrom(ctx, types.StringType, filteredIps)
        data.AllowedCIDRs = listFilteredIps
        resp.Diagnostics.Append(diags...)

        // Set state
        diags = resp.State.Set(ctx, &amp;data)
        resp.Diagnostics.Append(diags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>
}

// Metadata returns the data source type name.
func (d *dbaasDataSource) Metadata(_ context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) <span class="cov0" title="0">{
        resp.TypeName = req.ProviderTypeName + "_dbaas"
}</span>
</pre>
		
		<pre class="file" id="file22" style="display: none">package dbaas

import (
        "github.com/hashicorp/terraform-plugin-framework/datasource/schema"
        "github.com/hashicorp/terraform-plugin-framework/types"
)

func getDbaasDataSourceSchema() schema.Schema <span class="cov0" title="0">{
        return schema.Schema{
                Attributes: map[string]schema.Attribute{
                        "public_cloud_id": schema.Int64Attribute{
                                Required:            true,
                                MarkdownDescription: "The id of the public cloud where DBaaS is installed",
                        },
                        "public_cloud_project_id": schema.Int64Attribute{
                                Required:            true,
                                MarkdownDescription: "The id of the public cloud project where DBaaS is installed",
                        },
                        "id": schema.Int64Attribute{
                                Required:            true,
                                MarkdownDescription: "The id of this DBaaS",
                        },
                        "name": schema.StringAttribute{
                                Computed:            true,
                                MarkdownDescription: "The name of the DBaaS project",
                        },
                        "pack_name": schema.StringAttribute{
                                Computed:            true,
                                MarkdownDescription: "The name of the pack associated to the DBaaS project",
                        },
                        "region": schema.StringAttribute{
                                Computed:            true,
                                MarkdownDescription: "The region where the DBaaS project resides in.",
                        },
                        "type": schema.StringAttribute{
                                Computed:            true,
                                MarkdownDescription: "The type of the database associated with the DBaaS project",
                        },
                        "version": schema.StringAttribute{
                                Computed:            true,
                                MarkdownDescription: "The version of the database associated with the DBaaS project",
                        },
                        "host": schema.StringAttribute{
                                Computed:            true,
                                MarkdownDescription: "The host to access this database.",
                        },
                        "port": schema.StringAttribute{
                                Computed:            true,
                                MarkdownDescription: "The port to access this database.",
                        },
                        "user": schema.StringAttribute{
                                Computed:            true,
                                MarkdownDescription: "The username to access this database.",
                        },
                        "ca": schema.StringAttribute{
                                Computed:            true,
                                MarkdownDescription: "The Database CA Certificate",
                        },
                        "allowed_cidrs": schema.ListAttribute{
                                Computed:            true,
                                ElementType:         types.StringType,
                                MarkdownDescription: "Allowed to query Database IP whitelist",
                        },
                        "kube_identifier": schema.StringAttribute{
                                Computed:            true,
                                MarkdownDescription: "DbaaS kubernetes name",
                        },
                },
                MarkdownDescription: "The dbaas data source allows the user to manage a dbaas project",
        }
}</span>
</pre>
		
		<pre class="file" id="file23" style="display: none">package dbaasmigration

import (
        "context"

        "github.com/hashicorp/terraform-plugin-framework/resource"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/int64planmodifier"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/listplanmodifier"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/mapplanmodifier"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
        "github.com/hashicorp/terraform-plugin-framework/types"
)

type DBaasModelV0 struct {
        PublicCloudId        types.Int64  `tfsdk:"public_cloud_id"`
        PublicCloudProjectId types.Int64  `tfsdk:"public_cloud_project_id"`
        Id                   types.Int64  `tfsdk:"id"`
        KubernetesIdentifier types.String `tfsdk:"kube_identifier"`

        Name     types.String `tfsdk:"name"`
        PackName types.String `tfsdk:"pack_name"`
        Region   types.String `tfsdk:"region"`
        Type     types.String `tfsdk:"type"`
        Version  types.String `tfsdk:"version"`

        Host     types.String `tfsdk:"host"`
        Port     types.String `tfsdk:"port"`
        User     types.String `tfsdk:"user"`
        Password types.String `tfsdk:"password"`
        Ca       types.String `tfsdk:"ca"`

        AllowedCIDRs types.List `tfsdk:"allowed_cidrs"`

        Configuration          types.Map `tfsdk:"configuration"`
        EffectiveConfiguration types.Map `tfsdk:"effective_configuration"`
}

type DBaasModelV1 struct {
        PublicCloudId        types.Int64  `tfsdk:"public_cloud_id"`
        PublicCloudProjectId types.Int64  `tfsdk:"public_cloud_project_id"`
        Id                   types.Int64  `tfsdk:"id"`
        KubernetesIdentifier types.String `tfsdk:"kube_identifier"`

        Name     types.String `tfsdk:"name"`
        PackName types.String `tfsdk:"pack_name"`
        Region   types.String `tfsdk:"region"`
        Type     types.String `tfsdk:"type"`
        Version  types.String `tfsdk:"version"`

        Host     types.String `tfsdk:"host"`
        Port     types.String `tfsdk:"port"`
        User     types.String `tfsdk:"user"`
        Password types.String `tfsdk:"password"`
        Ca       types.String `tfsdk:"ca"`

        AllowedCIDRs types.List `tfsdk:"allowed_cidrs"`

        Configuration          types.Dynamic `tfsdk:"configuration"`
        EffectiveConfiguration types.Dynamic `tfsdk:"effective_configuration"`
}

func GetV0Schema() *schema.Schema <span class="cov0" title="0">{
        return &amp;schema.Schema{
                Version: 0,
                Attributes: map[string]schema.Attribute{
                        "public_cloud_id": schema.Int64Attribute{
                                Required:            true,
                                MarkdownDescription: "The id of the public cloud",
                                PlanModifiers: []planmodifier.Int64{
                                        int64planmodifier.RequiresReplace(),
                                },
                        },
                        "public_cloud_project_id": schema.Int64Attribute{
                                Required:            true,
                                MarkdownDescription: "The id of the public cloud project",
                                PlanModifiers: []planmodifier.Int64{
                                        int64planmodifier.RequiresReplace(),
                                },
                        },
                        "id": schema.Int64Attribute{
                                Computed:            true,
                                MarkdownDescription: "The unique identifier for the DBaaS instance.",
                                PlanModifiers: []planmodifier.Int64{
                                        int64planmodifier.UseStateForUnknown(),
                                },
                        },
                        "pack_name": schema.StringAttribute{
                                Required:            true,
                                MarkdownDescription: "The name of the pack associated to the DBaaS project",
                                PlanModifiers: []planmodifier.String{
                                        stringplanmodifier.RequiresReplace(),
                                },
                        },
                        "type": schema.StringAttribute{
                                Required:            true,
                                MarkdownDescription: "The type of database associated with the DBaaS being installed",
                                PlanModifiers: []planmodifier.String{
                                        stringplanmodifier.RequiresReplace(),
                                },
                        },
                        "version": schema.StringAttribute{
                                Required:            true,
                                MarkdownDescription: "The version of database associated with the DBaaS being installed",
                                PlanModifiers: []planmodifier.String{
                                        stringplanmodifier.RequiresReplace(),
                                },
                        },
                        "name": schema.StringAttribute{
                                Required:            true,
                                MarkdownDescription: "The name of the DBaaS project",
                                PlanModifiers: []planmodifier.String{
                                        stringplanmodifier.UseStateForUnknown(),
                                },
                        },
                        "region": schema.StringAttribute{
                                Required:            true,
                                MarkdownDescription: "The region where the DBaaS will reside.",
                                PlanModifiers: []planmodifier.String{
                                        stringplanmodifier.RequiresReplace(),
                                        stringplanmodifier.UseStateForUnknown(),
                                },
                        },
                        "host": schema.StringAttribute{
                                Computed:            true,
                                MarkdownDescription: "The host to access this database.",
                        },
                        "port": schema.StringAttribute{
                                Computed:            true,
                                MarkdownDescription: "The port to access this database.",
                        },
                        "user": schema.StringAttribute{
                                Computed:            true,
                                MarkdownDescription: "The username to access this database.",
                        },
                        "password": schema.StringAttribute{
                                Computed:            true,
                                Sensitive:           true,
                                MarkdownDescription: "The password to access this database.",
                        },
                        "ca": schema.StringAttribute{
                                Computed:            true,
                                MarkdownDescription: "The Database CA Certificate",
                        },
                        "allowed_cidrs": schema.ListAttribute{
                                Required:            true,
                                ElementType:         types.StringType,
                                MarkdownDescription: "Allowed to query Database IP whitelist",
                                PlanModifiers: []planmodifier.List{
                                        listplanmodifier.UseStateForUnknown(),
                                },
                        },
                        "kube_identifier": schema.StringAttribute{
                                Computed:            true,
                                MarkdownDescription: "DbaaS kubernetes name",
                        },
                        "configuration": schema.MapAttribute{
                                Computed:    true,
                                Optional:    true,
                                ElementType: types.StringType,
                                PlanModifiers: []planmodifier.Map{
                                        mapplanmodifier.UseStateForUnknown(),
                                },
                        },
                        "effective_configuration": schema.MapAttribute{
                                Computed:    true,
                                ElementType: types.StringType,
                        },
                },
                MarkdownDescription: "The dbaas resource allows the user to manage a dbaas project",
        }
}</span>

func StateUpgrader(ctx context.Context, request resource.UpgradeStateRequest, response *resource.UpgradeStateResponse) <span class="cov0" title="0">{
        var state DBaasModelV0

        // Read Terraform plan data into the model
        response.Diagnostics.Append(request.State.Get(ctx, &amp;state)...)

        var newState DBaasModelV1

        newState.PublicCloudId = state.PublicCloudId
        newState.PublicCloudProjectId = state.PublicCloudProjectId
        newState.Id = state.Id
        newState.KubernetesIdentifier = state.KubernetesIdentifier

        newState.Name = state.Name
        newState.PackName = state.PackName
        newState.Region = state.Region
        newState.Type = state.Type
        newState.Version = state.Version

        newState.Host = state.Host
        newState.Port = state.Port
        newState.User = state.User
        newState.Password = state.Password
        newState.Ca = state.Ca

        newState.AllowedCIDRs = state.AllowedCIDRs

        newState.EffectiveConfiguration = types.DynamicNull()
        if state.Configuration.IsUnknown() </span><span class="cov0" title="0">{
                newState.Configuration = types.DynamicUnknown()
                return
        }</span>
        <span class="cov0" title="0">newState.Configuration = types.DynamicNull()
        response.Diagnostics.Append(response.State.Set(ctx, &amp;newState)...)</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package dbaas

import (
        "context"
        "terraform-provider-infomaniak/internal/apis"
        "terraform-provider-infomaniak/internal/apis/dbaas"
        "terraform-provider-infomaniak/internal/provider"

        "github.com/hashicorp/terraform-plugin-framework/datasource"
        "github.com/hashicorp/terraform-plugin-framework/types"
)

// Ensure the implementation satisfies the expected interfaces.
var (
        _ datasource.DataSource              = &amp;dbaasPackDataSource{}
        _ datasource.DataSourceWithConfigure = &amp;dbaasPackDataSource{}
)

type dbaasPackDataSource struct {
        client *apis.Client
}

// NewDBaasDataSource is a helper function to simplify the provider implementation.
func NewDBaasPackDataSource() datasource.DataSource <span class="cov0" title="0">{
        return &amp;dbaasPackDataSource{}
}</span>

// Configure adds the provider configured client to the data source.
func (d *dbaasPackDataSource) Configure(_ context.Context, req datasource.ConfigureRequest, resp *datasource.ConfigureResponse) <span class="cov0" title="0">{
        // Add a nil check when handling ProviderData because Terraform
        // sets that data after it calls the ConfigureProvider RPC.
        if req.ProviderData == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">client, err := provider.GetApiClient(req.ProviderData)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unexpected Data Source Configure Type",
                        err.Error(),
                )
                return
        }</span>

        <span class="cov0" title="0">d.client = client</span>
}

type DBaasPackDataModel struct {
        Type      types.String `tfsdk:"type"`
        ID        types.Int64  `tfsdk:"id"`
        Group     types.String `tfsdk:"group"`
        Name      types.String `tfsdk:"name"`
        Instances types.Int64  `tfsdk:"instances"`
        CPU       types.Int64  `tfsdk:"cpu"`
        RAM       types.Int64  `tfsdk:"ram"`
        Storage   types.Int64  `tfsdk:"storage"`
        Rates     *RatesModel  `tfsdk:"rates"`
}

type RatesModel struct {
        CHF *PricingModel `tfsdk:"chf"`
        EUR *PricingModel `tfsdk:"eur"`
}

type PricingModel struct {
        HourlyExcludingTaxes types.Float64 `tfsdk:"hour_excl_tax"`
        HourlyIncludingTaxes types.Float64 `tfsdk:"hour_incl_tax"`
}

// Schema defines the schema for the data source.
func (d *dbaasPackDataSource) Schema(ctx context.Context, _ datasource.SchemaRequest, resp *datasource.SchemaResponse) <span class="cov0" title="0">{
        resp.Schema = getDbaasPacksDataSourceSchema()
}</span>

// Read refreshes the Terraform state with the latest data.
func (d *dbaasPackDataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) <span class="cov0" title="0">{
        var data DBaasPackDataModel

        resp.Diagnostics.Append(req.Config.Get(ctx, &amp;data)...)

        pack, err := d.client.DBaas.GetDbaasPack(dbaas.PackFilter{
                DbType:    data.Type.ValueString(),
                Group:     data.Group.ValueStringPointer(),
                Name:      data.Name.ValueStringPointer(),
                Instances: data.Instances.ValueInt64Pointer(),
                Cpu:       data.CPU.ValueInt64Pointer(),
                Ram:       data.RAM.ValueInt64Pointer(),
                Storage:   data.Storage.ValueInt64Pointer(),
        })
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unable to find DBaaS packs",
                        err.Error(),
                )
                return
        }</span>

        <span class="cov0" title="0">data.Type = types.StringValue(pack.Type)
        data.Group = types.StringValue(pack.Group)
        data.ID = types.Int64Value(pack.ID)
        data.Name = types.StringValue(pack.Name)
        data.Instances = types.Int64Value(pack.Instances)
        data.CPU = types.Int64Value(pack.CPU)
        data.RAM = types.Int64Value(pack.RAM)
        data.Storage = types.Int64Value(pack.Storage)

        // Set state
        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>
}

// Metadata returns the data source type name.
func (d *dbaasPackDataSource) Metadata(_ context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) <span class="cov0" title="0">{
        resp.TypeName = req.ProviderTypeName + "_dbaas_pack"
}</span>
</pre>
		
		<pre class="file" id="file25" style="display: none">package dbaas

import "github.com/hashicorp/terraform-plugin-framework/datasource/schema"

func getDbaasPacksDataSourceSchema() schema.Schema <span class="cov0" title="0">{
        pricingObject := schema.SingleNestedAttribute{
                Computed: true,
                Attributes: map[string]schema.Attribute{
                        "hour_excl_tax": schema.Float64Attribute{
                                Computed: true,
                        },
                        "hour_incl_tax": schema.Float64Attribute{
                                Computed: true,
                        },
                },
        }
        return schema.Schema{
                Attributes: map[string]schema.Attribute{
                        "type": schema.StringAttribute{
                                Required: true,
                        },
                        "id": schema.Int64Attribute{
                                Computed: true,
                        },
                        "group": schema.StringAttribute{
                                Optional: true,
                        },
                        "name": schema.StringAttribute{
                                Optional: true,
                        },
                        "instances": schema.Int64Attribute{
                                Optional: true,
                        },
                        "cpu": schema.Int64Attribute{
                                Optional: true,
                        },
                        "ram": schema.Int64Attribute{
                                Optional: true,
                        },
                        "storage": schema.Int64Attribute{
                                Optional: true,
                        },
                        "rates": schema.SingleNestedAttribute{
                                Computed: true,
                                Attributes: map[string]schema.Attribute{
                                        "chf": pricingObject,
                                        "eur": pricingObject,
                                },
                        },
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file26" style="display: none">package dbaas

import (
        "context"
        "encoding/json"
        "errors"
        "fmt"
        "reflect"
        "strconv"
        "strings"
        "terraform-provider-infomaniak/internal/apis"
        "terraform-provider-infomaniak/internal/apis/dbaas"
        "terraform-provider-infomaniak/internal/dynamic"
        "terraform-provider-infomaniak/internal/provider"
        dbaasmigration "terraform-provider-infomaniak/internal/services/dbaas/dbaas_migration"
        "terraform-provider-infomaniak/internal/utils"
        "time"

        "github.com/hashicorp/terraform-plugin-framework/diag"
        "github.com/hashicorp/terraform-plugin-framework/path"
        "github.com/hashicorp/terraform-plugin-framework/resource"

        "github.com/hashicorp/terraform-plugin-framework/types"
)

var (
        _ resource.Resource                 = &amp;dbaasResource{}
        _ resource.ResourceWithConfigure    = &amp;dbaasResource{}
        _ resource.ResourceWithImportState  = &amp;dbaasResource{}
        _ resource.ResourceWithUpgradeState = &amp;dbaasResource{}
)

func NewDBaasResource() resource.Resource <span class="cov0" title="0">{
        return &amp;dbaasResource{}
}</span>

type dbaasResource struct {
        client *apis.Client
}

type DBaasModel struct {
        PublicCloudId        types.Int64  `tfsdk:"public_cloud_id"`
        PublicCloudProjectId types.Int64  `tfsdk:"public_cloud_project_id"`
        Id                   types.Int64  `tfsdk:"id"`
        KubernetesIdentifier types.String `tfsdk:"kube_identifier"`

        Name     types.String `tfsdk:"name"`
        PackName types.String `tfsdk:"pack_name"`
        Region   types.String `tfsdk:"region"`
        Type     types.String `tfsdk:"type"`
        Version  types.String `tfsdk:"version"`

        Host     types.String `tfsdk:"host"`
        Port     types.String `tfsdk:"port"`
        User     types.String `tfsdk:"user"`
        Password types.String `tfsdk:"password"`
        Ca       types.String `tfsdk:"ca"`

        AllowedCIDRs types.List `tfsdk:"allowed_cidrs"`

        Configuration          types.Dynamic `tfsdk:"configuration"`
        EffectiveConfiguration types.Dynamic `tfsdk:"effective_configuration"`
}

func (r *dbaasResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) <span class="cov0" title="0">{
        resp.TypeName = req.ProviderTypeName + "_dbaas"
}</span>

// Configure adds the provider configured client to the data source.
func (r *dbaasResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) <span class="cov0" title="0">{
        // Add a nil check when handling ProviderData because Terraform
        // sets that data after it calls the ConfigureProvider RPC.
        if req.ProviderData == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">client, err := provider.GetApiClient(req.ProviderData)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unexpected Resource Configure Type",
                        err.Error(),
                )
                return
        }</span>

        <span class="cov0" title="0">r.client = client</span>
}

func (r *dbaasResource) UpgradeState(context.Context) map[int64]resource.StateUpgrader <span class="cov0" title="0">{
        return map[int64]resource.StateUpgrader{
                0: {
                        PriorSchema:   dbaasmigration.GetV0Schema(),
                        StateUpgrader: dbaasmigration.StateUpgrader,
                },
        }
}</span>

func (r *dbaasResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) <span class="cov0" title="0">{
        resp.Schema = getDbaasResourceSchema()
}</span>

func (r *dbaasResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) <span class="cov0" title="0">{
        var data DBaasModel

        // Read Terraform plan data into the model
        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)

        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">chosenPack, err := r.getPackId(data, &amp;resp.Diagnostics)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">input := &amp;dbaas.DBaaS{
                Project: dbaas.DBaaSProject{
                        PublicCloudId: data.PublicCloudId.ValueInt64(),
                        ProjectId:     data.PublicCloudProjectId.ValueInt64(),
                },
                Region:  data.Region.ValueString(),
                Version: data.Version.ValueString(),
                Type:    data.Type.ValueString(),
                Name:    data.Name.ValueString(),
                PackId:  chosenPack.Id,
        }

        // CreateDBaas API call logic
        createInfos, err := r.client.DBaas.CreateDBaaS(input)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error when creating DBaaS",
                        err.Error(),
                )
                return
        }</span>

        <span class="cov0" title="0">data.Id = types.Int64Value(createInfos.Id)
        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)

        dbaasObject, err := r.waitUntilActive(ctx, input, createInfos.Id)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error when waiting for DBaaS to be Active",
                        err.Error(),
                )
                return
        }</span>

        <span class="cov0" title="0">if dbaasObject == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">cidrs := make([]string, 0, len(data.AllowedCIDRs.Elements()))
        resp.Diagnostics.Append(data.AllowedCIDRs.ElementsAs(ctx, &amp;cidrs, false)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">allowedCIDRs := dbaas.AllowedCIDRs{
                IpFilters: cidrs,
        }
        ok, err := r.client.DBaas.PatchIpFilters(
                input.Project.PublicCloudId,
                input.Project.ProjectId,
                dbaasObject.Id,
                allowedCIDRs,
        )
        if !ok </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError("Unknown IP filter error", "")
                return
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error when updating IP Filters",
                        err.Error(),
                )
                return
        }</span>

        <span class="cov0" title="0">if !data.Configuration.IsNull() &amp;&amp; !data.Configuration.IsUnknown() </span><span class="cov0" title="0">{
                configuration, d := utils.ConvertDynamicObjectToMapAny(data.Configuration)
                resp.Diagnostics.Append(d...)
                if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                        return
                }</span>

                <span class="cov0" title="0">ok, err = r.client.DBaas.PutConfiguration(
                        data.PublicCloudId.ValueInt64(),
                        data.PublicCloudProjectId.ValueInt64(),
                        data.Id.ValueInt64(),
                        configuration,
                )
                if !ok &amp;&amp; err == nil </span><span class="cov0" title="0">{
                        resp.Diagnostics.AddError("Unknown Settings error", "")
                        return
                }</span>
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        resp.Diagnostics.AddError(
                                "Error when updating DBaaS Settings",
                                err.Error(),
                        )
                        return
                }</span>
        } else<span class="cov0" title="0"> {
                data.Configuration = types.DynamicNull()
        }</span>

        <span class="cov0" title="0">newEffectiveConfig, diags := r.refreshEffectiveConfiguration(
                data.PublicCloudId.ValueInt64(),
                data.PublicCloudProjectId.ValueInt64(),
                data.Id.ValueInt64(),
        )
        resp.Diagnostics.Append(diags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">data.EffectiveConfiguration = newEffectiveConfig
        data.fill(dbaasObject)
        data.Password = types.StringValue(createInfos.RootPassword)

        // Save data into Terraform state
        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *dbaasResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) <span class="cov0" title="0">{
        var state DBaasModel

        // Read Terraform plan data into the model
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;state)...)

        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // Read API call logic
        <span class="cov0" title="0">dbaasObject, err := r.client.DBaas.GetDBaaS(
                state.PublicCloudId.ValueInt64(),
                state.PublicCloudProjectId.ValueInt64(),
                state.Id.ValueInt64(),
        )
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error when reading DBaaS",
                        err.Error(),
                )
                return
        }</span>

        <span class="cov0" title="0">filteredIps, err := r.client.DBaas.GetIpFilters(
                state.PublicCloudId.ValueInt64(),
                state.PublicCloudProjectId.ValueInt64(),
                state.Id.ValueInt64(),
        )
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error when reading DBaaS filtered IPs",
                        err.Error(),
                )
                return
        }</span>

        <span class="cov0" title="0">listFilteredIps, diags := types.ListValueFrom(ctx, types.StringType, filteredIps)
        state.AllowedCIDRs = listFilteredIps
        resp.Diagnostics.Append(diags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">newEffectiveConfig, diags := r.refreshEffectiveConfiguration(
                state.PublicCloudId.ValueInt64(),
                state.PublicCloudProjectId.ValueInt64(),
                state.Id.ValueInt64(),
        )
        resp.Diagnostics.Append(diags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">newEffectiveConfig, newConfig, diags := utils.ObjectStateManager(
                ctx,
                newEffectiveConfig,
                state.EffectiveConfiguration,
                state.Configuration,
        )
        resp.Diagnostics.Append(diags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">newConfigMap, diags := utils.ConvertDynamicObjectToMapAny(newConfig)
        resp.Diagnostics.Append(diags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">newConfigConverted := utils.ConvertIntsToStrings(newConfigMap)

        stateConfigMap, diags := utils.ConvertDynamicObjectToMapAny(state.Configuration)
        resp.Diagnostics.Append(diags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">stateConfigConverted := utils.ConvertIntsToStrings(stateConfigMap)

        if !reflect.DeepEqual(newConfigConverted, stateConfigConverted) </span><span class="cov0" title="0">{
                state.Configuration = newConfig
        }</span>

        <span class="cov0" title="0">state.EffectiveConfiguration = newEffectiveConfig

        state.fill(dbaasObject)

        // Save updated data into Terraform state
        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;state)...)</span>
}

func (r *dbaasResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) <span class="cov0" title="0">{
        var state DBaasModel
        var data DBaasModel

        // Read Terraform plan data into the model
        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;state)...)

        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">chosenPackState, err := r.getPackId(state, &amp;resp.Diagnostics)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        // Update API call logic
        <span class="cov0" title="0">input := &amp;dbaas.DBaaS{
                Project: dbaas.DBaaSProject{
                        PublicCloudId: data.PublicCloudId.ValueInt64(),
                        ProjectId:     data.PublicCloudProjectId.ValueInt64(),
                },
                Id:      state.Id.ValueInt64(),
                Name:    data.Name.ValueString(),
                PackId:  chosenPackState.Id,
                Region:  state.Region.ValueString(),
                Version: state.Version.ValueString(),
                Type:    state.Type.ValueString(),
        }

        _, err = r.client.DBaas.UpdateDBaaS(input)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error when updating DBaaS",
                        err.Error(),
                )
                return
        }</span>

        <span class="cov0" title="0">dbaasObject, err := r.waitUntilActive(ctx, input, input.Id)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error when getting DBaaS",
                        err.Error(),
                )
                return
        }</span>

        <span class="cov0" title="0">if dbaasObject == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">cidrs := make([]string, 0, len(data.AllowedCIDRs.Elements()))
        resp.Diagnostics.Append(data.AllowedCIDRs.ElementsAs(ctx, &amp;cidrs, false)...)
        allowedCIDRs := dbaas.AllowedCIDRs{
                IpFilters: cidrs,
        }
        ok, err := r.client.DBaas.PatchIpFilters(
                state.PublicCloudId.ValueInt64(),
                state.PublicCloudProjectId.ValueInt64(),
                state.Id.ValueInt64(),
                allowedCIDRs,
        )
        if !ok &amp;&amp; err == nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError("Unknown IP filter error", "")
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error when updating IP Filters",
                        err.Error(),
                )
                return
        }</span>

        <span class="cov0" title="0">state.AllowedCIDRs = data.AllowedCIDRs

        if !data.Configuration.IsNull() &amp;&amp; !data.Configuration.IsUnknown() </span><span class="cov0" title="0">{
                configuration, d := utils.ConvertDynamicObjectToMapAny(data.Configuration)
                resp.Diagnostics.Append(d...)
                if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                        return
                }</span>

                <span class="cov0" title="0">ok, err = r.client.DBaas.PutConfiguration(
                        state.PublicCloudId.ValueInt64(),
                        state.PublicCloudProjectId.ValueInt64(),
                        state.Id.ValueInt64(),
                        configuration,
                )
                if !ok &amp;&amp; err == nil </span><span class="cov0" title="0">{
                        resp.Diagnostics.AddError("Unknown Settings error", "")
                        return
                }</span>
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        resp.Diagnostics.AddError(
                                "Error when updating DBaaS Settings",
                                err.Error(),
                        )
                        return
                }</span>

                <span class="cov0" title="0">state.Configuration = data.Configuration</span>
        } else<span class="cov0" title="0"> {
                state.Configuration = types.DynamicNull()
        }</span>

        <span class="cov0" title="0">newEffectiveConfig, diags := r.refreshEffectiveConfiguration(
                state.PublicCloudId.ValueInt64(),
                state.PublicCloudProjectId.ValueInt64(),
                state.Id.ValueInt64(),
        )
        resp.Diagnostics.Append(diags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">state.EffectiveConfiguration = newEffectiveConfig
        state.fill(dbaasObject)

        // Save updated data into Terraform state
        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;state)...)</span>
}

func (r *dbaasResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) <span class="cov0" title="0">{
        var data DBaasModel

        // Read Terraform prior state data into the model
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;data)...)

        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // DeleteDBaas API call logic
        <span class="cov0" title="0">_, err := r.client.DBaas.DeleteDBaaS(
                data.PublicCloudId.ValueInt64(),
                data.PublicCloudProjectId.ValueInt64(),
                data.Id.ValueInt64(),
        )
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error when deleting DBaaS",
                        err.Error(),
                )
                return
        }</span>
}

func (r *dbaasResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) <span class="cov0" title="0">{
        idParts := strings.Split(req.ID, ",")

        if len(idParts) != 3 || idParts[0] == "" || idParts[1] == "" || idParts[2] == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unexpected Import Identifier",
                        fmt.Sprintf("Expected import identifier with format: public_cloud_id,public_cloud_project_id,id. Got: %q", req.ID),
                )
                return
        }</span>

        <span class="cov0" title="0">var errorList error

        publicCloudId, err := strconv.ParseInt(idParts[0], 10, 64)
        errorList = errors.Join(errorList, err)
        publicCloudProjectId, err := strconv.ParseInt(idParts[1], 10, 64)
        errorList = errors.Join(errorList, err)
        dbaasId, err := strconv.ParseInt(idParts[2], 10, 64)
        errorList = errors.Join(errorList, err)

        if errorList != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unexpected Import Identifier",
                        fmt.Sprintf("Expected import identifier with format: public_cloud_id,public_cloud_project_id,id. Got: %q", req.ID),
                )
                return
        }</span>

        <span class="cov0" title="0">resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("public_cloud_id"), publicCloudId)...)
        resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("public_cloud_project_id"), publicCloudProjectId)...)
        resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("id"), dbaasId)...)</span>
}

func (r *dbaasResource) getPackId(data DBaasModel, diagnostic *diag.Diagnostics) (*dbaas.DBaaSPack, error) <span class="cov0" title="0">{
        pack, err := r.client.DBaas.FindPack(data.Type.ValueString(), data.PackName.ValueString())
        if err != nil </span><span class="cov0" title="0">{
                diagnostic.AddError(
                        "Could not find DBaaS Pack",
                        err.Error(),
                )
                return nil, err
        }</span>

        <span class="cov0" title="0">return pack, nil</span>
}

func (model *DBaasModel) fill(dbaas *dbaas.DBaaS) <span class="cov0" title="0">{
        model.Id = types.Int64Value(dbaas.Id)
        model.KubernetesIdentifier = types.StringValue(dbaas.KubernetesIdentifier)
        model.Region = types.StringValue(dbaas.Region)
        model.Type = types.StringValue(dbaas.Type)
        model.Version = types.StringValue(dbaas.Version)
        model.Name = types.StringValue(dbaas.Name)
        model.PackName = types.StringValue(dbaas.Pack.Name)

        if dbaas.Connection != nil </span><span class="cov0" title="0">{
                model.Host = types.StringValue(dbaas.Connection.Host)
                model.Port = types.StringValue(dbaas.Connection.Port)
                model.User = types.StringValue(dbaas.Connection.User)
                model.Ca = types.StringValue(dbaas.Connection.Ca)

                if model.Password == types.StringNull() || model.Password == types.StringUnknown() </span><span class="cov0" title="0">{
                        model.Password = types.StringValue(dbaas.Connection.Password)
                }</span>
        }
}

func (r *dbaasResource) refreshEffectiveConfiguration(publicCloudId, publicCloudProjectId, id int64) (types.Dynamic, diag.Diagnostics) <span class="cov0" title="0">{
        var diags diag.Diagnostics
        effectiveSettings, err := r.client.DBaas.GetConfiguration(
                publicCloudId,
                publicCloudProjectId,
                id,
        )
        if err != nil </span><span class="cov0" title="0">{
                diags.AddError(
                        "Error when reading DBaaS settings",
                        err.Error(),
                )
                return types.DynamicNull(), diags
        }</span>

        <span class="cov0" title="0">jsonEffectiveSettigs, err := json.Marshal(effectiveSettings)
        if err != nil </span><span class="cov0" title="0">{
                diags.AddError("could not marshall", "effective settings json marshall fail")
        }</span>
        <span class="cov0" title="0">dynamicObj, err := dynamic.FromJSONImplied(jsonEffectiveSettigs)
        if err != nil </span><span class="cov0" title="0">{
                diags.AddError("could not create dynamic object", "effective settings dynamic object from json creation failure")
        }</span>

        <span class="cov0" title="0">return dynamicObj, diags</span>
}

func (r *dbaasResource) waitUntilActive(ctx context.Context, dbaas *dbaas.DBaaS, id int64) (*dbaas.DBaaS, error) <span class="cov0" title="0">{
        t := time.NewTicker(5 * time.Second)
        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return nil, nil</span>
                case &lt;-t.C:<span class="cov0" title="0">
                        found, err := r.client.DBaas.GetDBaaS(dbaas.Project.PublicCloudId, dbaas.Project.ProjectId, id)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>

                        <span class="cov0" title="0">if ctx.Err() != nil </span><span class="cov0" title="0">{
                                return nil, nil
                        }</span>

                        <span class="cov0" title="0">if found.Status == "ready" </span><span class="cov0" title="0">{
                                return found, nil
                        }</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package dbaas

import (
        "terraform-provider-infomaniak/internal/dynamic"

        "github.com/hashicorp/terraform-plugin-framework/resource/schema"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/dynamicplanmodifier"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/int64planmodifier"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/listplanmodifier"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
        "github.com/hashicorp/terraform-plugin-framework/schema/validator"
        "github.com/hashicorp/terraform-plugin-framework/types"
)

func getDbaasResourceSchema() schema.Schema <span class="cov0" title="0">{
        return schema.Schema{
                Version: 1,
                Attributes: map[string]schema.Attribute{
                        "public_cloud_id": schema.Int64Attribute{
                                Required:            true,
                                MarkdownDescription: "The id of the public cloud",
                                PlanModifiers: []planmodifier.Int64{
                                        int64planmodifier.RequiresReplace(),
                                },
                        },
                        "public_cloud_project_id": schema.Int64Attribute{
                                Required:            true,
                                MarkdownDescription: "The id of the public cloud project",
                                PlanModifiers: []planmodifier.Int64{
                                        int64planmodifier.RequiresReplace(),
                                },
                        },
                        "id": schema.Int64Attribute{
                                Computed:            true,
                                MarkdownDescription: "The unique identifier for the DBaaS instance.",
                                PlanModifiers: []planmodifier.Int64{
                                        int64planmodifier.UseStateForUnknown(),
                                },
                        },
                        "pack_name": schema.StringAttribute{
                                Required:            true,
                                MarkdownDescription: "The name of the pack associated to the DBaaS project",
                                PlanModifiers: []planmodifier.String{
                                        stringplanmodifier.RequiresReplace(),
                                },
                        },
                        "type": schema.StringAttribute{
                                Required:            true,
                                MarkdownDescription: "The type of database associated with the DBaaS being installed",
                                PlanModifiers: []planmodifier.String{
                                        stringplanmodifier.RequiresReplace(),
                                },
                        },
                        "version": schema.StringAttribute{
                                Required:            true,
                                MarkdownDescription: "The version of database associated with the DBaaS being installed",
                                PlanModifiers: []planmodifier.String{
                                        stringplanmodifier.RequiresReplace(),
                                },
                        },
                        "name": schema.StringAttribute{
                                Required:            true,
                                MarkdownDescription: "The name of the DBaaS project",
                                PlanModifiers: []planmodifier.String{
                                        stringplanmodifier.UseStateForUnknown(),
                                },
                        },
                        "region": schema.StringAttribute{
                                Required:            true,
                                MarkdownDescription: "The region where the DBaaS will reside.",
                                PlanModifiers: []planmodifier.String{
                                        stringplanmodifier.RequiresReplace(),
                                        stringplanmodifier.UseStateForUnknown(),
                                },
                        },
                        "host": schema.StringAttribute{
                                Computed:            true,
                                MarkdownDescription: "The host to access this database.",
                        },
                        "port": schema.StringAttribute{
                                Computed:            true,
                                MarkdownDescription: "The port to access this database.",
                        },
                        "user": schema.StringAttribute{
                                Computed:            true,
                                MarkdownDescription: "The username to access this database.",
                        },
                        "password": schema.StringAttribute{
                                Computed:            true,
                                Sensitive:           true,
                                MarkdownDescription: "The password to access this database.",
                        },
                        "ca": schema.StringAttribute{
                                Computed:            true,
                                MarkdownDescription: "The Database CA Certificate",
                        },
                        "allowed_cidrs": schema.ListAttribute{
                                Required:            true,
                                ElementType:         types.StringType,
                                MarkdownDescription: "Allowed to query Database IP whitelist",
                                PlanModifiers: []planmodifier.List{
                                        listplanmodifier.UseStateForUnknown(),
                                },
                        },
                        "kube_identifier": schema.StringAttribute{
                                Computed:            true,
                                MarkdownDescription: "DbaaS kubernetes name",
                        },
                        "configuration": schema.DynamicAttribute{
                                Optional: true,
                                PlanModifiers: []planmodifier.Dynamic{
                                        dynamicplanmodifier.UseStateForUnknown(),
                                },
                                Validators: []validator.Dynamic{
                                        dynamic.NewDynamicObjectValidator(),
                                },
                        },
                        "effective_configuration": schema.DynamicAttribute{
                                Computed: true,
                        },
                },
                MarkdownDescription: "The dbaas resource allows the user to manage a dbaas project",
        }
}</span>
</pre>
		
		<pre class="file" id="file28" style="display: none">package dbaas

import "terraform-provider-infomaniak/internal/provider/registry"

func Register() <span class="cov8" title="1">{
        registry.RegisterResource(NewDBaasResource)
        registry.RegisterResource(NewDBaasBackupScheduleResource)

        registry.RegisterDataSource(NewDBaasDataSource)
        registry.RegisterDataSource(NewDBaasPackDataSource)
        registry.RegisterDataSource(NewDBaasConstsDataSource)
}</span>
</pre>
		
		<pre class="file" id="file29" style="display: none">package dbaas

import (
        "errors"
        "fmt"
        "strconv"
        "strings"

        "github.com/hashicorp/terraform-plugin-framework/resource"
)

type ImportIds struct {
        PublicCloudId        int64
        PublicCloudProjectId int64
        DbaasId              int64
        Id                   string
}

func parseBackupRestoreImport(req resource.ImportStateRequest) (*ImportIds, error) <span class="cov0" title="0">{
        idParts := strings.Split(req.ID, ",")

        if len(idParts) != 4 || idParts[0] == "" || idParts[1] == "" || idParts[2] == "" || idParts[3] == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("expected import identifier with format: public_cloud_id,public_cloud_project_id,dbaas_id,id. got: %q", req.ID)
        }</span>

        <span class="cov0" title="0">var errorList error

        publicCloudId, err := strconv.ParseInt(idParts[0], 10, 64)
        errorList = errors.Join(errorList, err)
        publicCloudProjectId, err := strconv.ParseInt(idParts[1], 10, 64)
        errorList = errors.Join(errorList, err)
        dbaasId, err := strconv.ParseInt(idParts[2], 10, 64)
        errorList = errors.Join(errorList, err)
        id := idParts[3]

        if errorList != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("expected import identifier with format: public_cloud_id,public_cloud_project_id,dbaas_id,id. got: %q", req.ID)
        }</span>

        <span class="cov0" title="0">return &amp;ImportIds{
                PublicCloudId:        publicCloudId,
                PublicCloudProjectId: publicCloudProjectId,
                DbaasId:              dbaasId,
                Id:                   id,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">package domain

import (
        "fmt"
        "net"
        "strings"
        "terraform-provider-infomaniak/internal/apis/domain"

        "github.com/hashicorp/terraform-plugin-framework/types"
        "github.com/miekg/dns"
)

func (model *RecordModel) ComputeRawTarget() string <span class="cov0" title="0">{
        // don't do anything if it's already set
        if !model.Target.IsUnknown() &amp;&amp; !model.Target.IsNull() </span><span class="cov0" title="0">{
                return model.Target.ValueString()
        }</span>

        <span class="cov0" title="0">var record dns.RR

        switch model.Type.ValueString() </span>{
        case domain.RecordA:<span class="cov0" title="0">
                record = &amp;dns.A{
                        A: net.ParseIP(model.Data.IP.ValueString()),
                }</span>
        case domain.RecordAAAA:<span class="cov0" title="0">
                record = &amp;dns.AAAA{
                        AAAA: net.ParseIP(model.Data.IP.ValueString()),
                }</span>
        case domain.RecordCAA:<span class="cov0" title="0">
                record = &amp;dns.CAA{
                        Flag:  uint8(model.Data.Flags.ValueInt64()),
                        Tag:   model.Data.Tag.ValueString(),
                        Value: model.Data.Value.ValueString(),
                }</span>
        case domain.RecordCNAME:<span class="cov0" title="0">
                record = &amp;dns.CNAME{
                        Target: dns.Fqdn(model.Data.Target.ValueString()),
                }</span>
        case domain.RecordDNAME:<span class="cov0" title="0">
                record = &amp;dns.DNAME{
                        Target: dns.Fqdn(model.Data.Target.ValueString()),
                }</span>
        case domain.RecordDS:<span class="cov0" title="0">
                record = &amp;dns.DS{
                        KeyTag:     uint16(model.Data.KeyTag.ValueInt64()),
                        Algorithm:  uint8(model.Data.Algorithm.ValueInt64()),
                        DigestType: uint8(model.Data.DigestType.ValueInt64()),
                        Digest:     model.Data.Digest.ValueString(),
                }</span>
        case domain.RecordMX:<span class="cov0" title="0">
                record = &amp;dns.MX{
                        Preference: uint16(model.Data.Priority.ValueInt64()),
                        Mx:         dns.Fqdn(model.Data.Target.ValueString()),
                }</span>
        case domain.RecordNS:<span class="cov0" title="0">
                record = &amp;dns.NS{
                        Ns: dns.Fqdn(model.Data.Target.ValueString()),
                }</span>
        case domain.RecordSMIMEA:<span class="cov0" title="0">
                record = &amp;dns.SMIMEA{
                        Usage:        uint8(model.Data.Priority.ValueInt64()),
                        Selector:     uint8(model.Data.Selector.ValueInt64()),
                        MatchingType: uint8(model.Data.MatchingType.ValueInt64()),
                        Certificate:  model.Data.CertAssocData.ValueString(),
                }</span>
        case domain.RecordSRV:<span class="cov0" title="0">
                record = &amp;dns.SRV{
                        Priority: uint16(model.Data.Priority.ValueInt64()),
                        Weight:   uint16(model.Data.Weight.ValueInt64()),
                        Port:     uint16(model.Data.Port.ValueInt64()),
                        Target:   dns.Fqdn(model.Data.Target.ValueString()),
                }</span>
        case domain.RecordSSHFP:<span class="cov0" title="0">
                record = &amp;dns.SSHFP{
                        Algorithm:   uint8(model.Data.FingerprintAlgorithm.ValueInt64()),
                        Type:        uint8(model.Data.FingerprintType.ValueInt64()),
                        FingerPrint: model.Data.Fingerprint.ValueString(),
                }</span>
        case domain.RecordTLSA:<span class="cov0" title="0">
                record = &amp;dns.TLSA{
                        Usage:        uint8(model.Data.Priority.ValueInt64()),
                        Selector:     uint8(model.Data.Selector.ValueInt64()),
                        MatchingType: uint8(model.Data.MatchingType.ValueInt64()),
                        Certificate:  model.Data.CertAssocData.ValueString(),
                }</span>
        case domain.RecordTXT:<span class="cov0" title="0">
                record = &amp;dns.TXT{
                        Txt: []string{model.Data.Value.ValueString()},
                }</span>
        }

        <span class="cov0" title="0">return strings.TrimPrefix(record.String(), record.Header().String())</span>
}

func (model *RecordModel) ParseRawTarget(raw string) error <span class="cov0" title="0">{
        // We need to prepend a fake name to make dns.NewRR happy
        full := fmt.Sprintf("example.com. 3600 IN %s %s", model.Type.ValueString(), raw)

        rr, err := dns.NewRR(full)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to parse DNS record: %w", err)
        }</span>

        <span class="cov0" title="0">switch v := rr.(type) </span>{
        case *dns.A:<span class="cov0" title="0">
                model.Data.IP = types.StringValue(v.A.String())</span>

        case *dns.AAAA:<span class="cov0" title="0">
                model.Data.IP = types.StringValue(v.AAAA.String())</span>

        case *dns.CAA:<span class="cov0" title="0">
                model.Data.Flags = types.Int64Value(int64(v.Flag))
                model.Data.Tag = types.StringValue(v.Tag)
                model.Data.Value = types.StringValue(v.Value)</span>

        case *dns.CNAME:<span class="cov0" title="0">
                model.Data.Target = types.StringValue(strings.TrimSuffix(v.Target, "."))</span>

        case *dns.DNAME:<span class="cov0" title="0">
                model.Data.Target = types.StringValue(strings.TrimSuffix(v.Target, "."))</span>

        case *dns.DS:<span class="cov0" title="0">
                model.Data.KeyTag = types.Int64Value(int64(v.KeyTag))
                model.Data.Algorithm = types.Int64Value(int64(v.Algorithm))
                model.Data.DigestType = types.Int64Value(int64(v.DigestType))
                model.Data.Digest = types.StringValue(v.Digest)</span>

        case *dns.MX:<span class="cov0" title="0">
                model.Data.Priority = types.Int64Value(int64(v.Preference))
                model.Data.Target = types.StringValue(strings.TrimSuffix(v.Mx, "."))</span>

        case *dns.NS:<span class="cov0" title="0">
                model.Data.Target = types.StringValue(strings.TrimSuffix(v.Ns, "."))</span>

        case *dns.PTR:<span class="cov0" title="0">
                model.Data.Target = types.StringValue(strings.TrimSuffix(v.Ptr, "."))</span>

        case *dns.SMIMEA:<span class="cov0" title="0">
                model.Data.Priority = types.Int64Value(int64(v.Usage))
                model.Data.Selector = types.Int64Value(int64(v.Selector))
                model.Data.MatchingType = types.Int64Value(int64(v.MatchingType))
                model.Data.CertAssocData = types.StringValue(v.Certificate)</span>

        case *dns.SRV:<span class="cov0" title="0">
                model.Data.Priority = types.Int64Value(int64(v.Priority))
                model.Data.Weight = types.Int64Value(int64(v.Weight))
                model.Data.Port = types.Int64Value(int64(v.Port))
                model.Data.Target = types.StringValue(strings.TrimSuffix(v.Target, "."))</span>

        case *dns.SSHFP:<span class="cov0" title="0">
                model.Data.FingerprintAlgorithm = types.Int64Value(int64(v.Algorithm))
                model.Data.FingerprintType = types.Int64Value(int64(v.Type))
                model.Data.Fingerprint = types.StringValue(v.FingerPrint)</span>

        case *dns.TLSA:<span class="cov0" title="0">
                model.Data.Priority = types.Int64Value(int64(v.Usage))
                model.Data.Selector = types.Int64Value(int64(v.Selector))
                model.Data.MatchingType = types.Int64Value(int64(v.MatchingType))
                model.Data.CertAssocData = types.StringValue(v.Certificate)</span>

        case *dns.TXT:<span class="cov0" title="0">
                if len(v.Txt) &gt; 0 </span><span class="cov0" title="0">{
                        model.Data.Value = types.StringValue(v.Txt[0])
                }</span>

        default:<span class="cov0" title="0">
                return fmt.Errorf("unsupported record type: %T", rr)</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">package domain

import (
        "context"
        "errors"
        "fmt"
        "strconv"
        "strings"
        "terraform-provider-infomaniak/internal/apis"
        "terraform-provider-infomaniak/internal/provider"

        "github.com/hashicorp/terraform-plugin-framework/path"
        "github.com/hashicorp/terraform-plugin-framework/resource"

        "github.com/hashicorp/terraform-plugin-framework/types"
)

var (
        _ resource.Resource                = &amp;recordResource{}
        _ resource.ResourceWithConfigure   = &amp;recordResource{}
        _ resource.ResourceWithImportState = &amp;recordResource{}
        _ resource.ResourceWithModifyPlan  = &amp;recordResource{}
)

func NewRecordResource() resource.Resource <span class="cov0" title="0">{
        return &amp;recordResource{}
}</span>

type recordResource struct {
        client *apis.Client
}

type RecordModel struct {
        ZoneFqdn types.String `tfsdk:"zone_fqdn"`
        Id       types.Int64  `tfsdk:"id"`

        Type           types.String     `tfsdk:"type"`
        Source         types.String     `tfsdk:"source"`
        ComputedTarget types.String     `tfsdk:"computed_target"`
        Target         types.String     `tfsdk:"target"`
        TTL            types.Int64      `tfsdk:"ttl"`
        Description    types.String     `tfsdk:"description"`
        Data           *RecordDataModel `tfsdk:"data"`
}

type RecordDataModel struct {
        IP                   types.String `tfsdk:"ip"`                    // A, AAAA
        Priority             types.Int64  `tfsdk:"priority"`              // MX, SRV
        Target               types.String `tfsdk:"target"`                // MX, SRV, CNAME, NS, PTR
        Weight               types.Int64  `tfsdk:"weight"`                // SRV
        Port                 types.Int64  `tfsdk:"port"`                  // SRV
        KeyTag               types.Int64  `tfsdk:"key_tag"`               // DS
        Algorithm            types.Int64  `tfsdk:"algorithm"`             // DNSKEY, DS, SSHFP, TLSA
        DigestType           types.Int64  `tfsdk:"digest_type"`           // DS, TLSA
        Digest               types.String `tfsdk:"digest"`                // DS, TLSA, SSHFP
        Selector             types.Int64  `tfsdk:"selector"`              // SMIMEA, TLSA
        MatchingType         types.Int64  `tfsdk:"matching_type"`         // SMIMEA, TLSA
        CertAssocData        types.String `tfsdk:"cert_assoc_data"`       // SMIMEA, TLSA
        Flags                types.Int64  `tfsdk:"flags"`                 // CAA, DNSKEY
        Tag                  types.String `tfsdk:"tag"`                   // CAA
        Value                types.String `tfsdk:"value"`                 // CAA, TXT
        Fingerprint          types.String `tfsdk:"fingerprint"`           // SSHFP
        FingerprintType      types.Int64  `tfsdk:"fingerprint_type"`      // SSHFP
        FingerprintAlgorithm types.Int64  `tfsdk:"fingerprint_algorithm"` // SSHFP
}

func (r *recordResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) <span class="cov0" title="0">{
        resp.TypeName = req.ProviderTypeName + "_record"
}</span>

// Configure adds the provider configured client to the data source.
func (r *recordResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) <span class="cov0" title="0">{
        // Add a nil check when handling ProviderData because Terraform
        // sets that data after it calls the ConfigureProvider RPC.
        if req.ProviderData == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">client, err := provider.GetApiClient(req.ProviderData)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unexpected Record Resource Configure Type",
                        err.Error(),
                )
                return
        }</span>

        <span class="cov0" title="0">r.client = client</span>
}

func (r *recordResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) <span class="cov0" title="0">{
        resp.Schema = getRecordResourceSchema()
}</span>

func (r *recordResource) ModifyPlan(ctx context.Context, req resource.ModifyPlanRequest, resp *resource.ModifyPlanResponse) <span class="cov0" title="0">{
        if req.Plan.Raw.IsNull() </span><span class="cov0" title="0">{
                // Handle destroy plan (optional)
                return
        }</span>

        <span class="cov0" title="0">var plan RecordModel
        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;plan)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">computedTarget := plan.ComputeRawTarget()
        plan.ComputedTarget = types.StringValue(computedTarget)

        // Set the modified plan back
        resp.Diagnostics.Append(resp.Plan.Set(ctx, &amp;plan)...)</span>
}

func (r *recordResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) <span class="cov0" title="0">{
        var data RecordModel

        // Read Terraform plan data into the model
        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)

        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">rawTarget := data.ComputeRawTarget()

        record, err := r.client.Domain.CreateRecord(
                data.ZoneFqdn.ValueString(),
                data.Type.ValueString(),
                data.Source.ValueString(),
                rawTarget,
                data.TTL.ValueInt64(),
        )
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error when creating Record",
                        err.Error(),
                )
                return
        }</span>

        <span class="cov0" title="0">data.Id = types.Int64Value(int64(record.ID))
        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *recordResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) <span class="cov0" title="0">{
        var state RecordModel

        // Read Terraform plan data into the model
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;state)...)

        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // Read API call logic
        <span class="cov0" title="0">record, err := r.client.Domain.GetRecord(state.ZoneFqdn.ValueString(), state.Id.ValueInt64())
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error when reading Record",
                        err.Error(),
                )
                return
        }</span>

        <span class="cov0" title="0">state.Id = types.Int64Value(int64(record.ID))
        state.TTL = types.Int64Value(int64(record.TTL))
        state.Source = types.StringValue(record.Source)
        state.Type = types.StringValue(record.Type)

        // If we have neither of them, we fill them with the API
        // However in this state (import), we can't know which field is planned by the user
        if state.Target.IsNull() &amp;&amp; state.Data == nil </span><span class="cov0" title="0">{
                state.Target = types.StringValue(record.Target)
                state.Data = &amp;RecordDataModel{}
                state.ParseRawTarget(record.Target)
        }</span>

        // Save updated data into Terraform state
        <span class="cov0" title="0">resp.Diagnostics.Append(resp.State.Set(ctx, &amp;state)...)</span>
}

func (r *recordResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) <span class="cov0" title="0">{
        var state RecordModel
        var data RecordModel

        // Read Terraform plan data into the model
        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;state)...)

        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">rawTarget := data.ComputeRawTarget()

        record, err := r.client.Domain.UpdateRecord(
                data.ZoneFqdn.ValueString(),
                state.Id.ValueInt64(),
                data.Type.ValueString(),
                data.Source.ValueString(),
                rawTarget,
                data.TTL.ValueInt64(),
        )
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error when updating Record",
                        err.Error(),
                )
                return
        }</span>

        <span class="cov0" title="0">data.Id = types.Int64Value(int64(record.ID))
        // Save updated data into Terraform state
        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *recordResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) <span class="cov0" title="0">{
        var state RecordModel
        var data RecordModel

        // Read Terraform prior state data into the model
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;data)...)
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;state)...)

        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">_, err := r.client.Domain.DeleteRecord(
                data.ZoneFqdn.ValueString(),
                state.Id.ValueInt64(),
        )
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error when deleting Record",
                        err.Error(),
                )
                return
        }</span>
}

func (r *recordResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) <span class="cov0" title="0">{
        idParts := strings.Split(req.ID, ",")

        if len(idParts) != 2 || idParts[0] == "" || idParts[1] == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unexpected Import Identifier",
                        fmt.Sprintf("Expected import identifier with format: zone_fqdn,id. Got: %q", req.ID),
                )
                return
        }</span>

        <span class="cov0" title="0">var errorList error

        zoneFQDN := idParts[0]
        recordId, err := strconv.ParseInt(idParts[1], 10, 64)
        errorList = errors.Join(errorList, err)

        if errorList != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unexpected Import Identifier",
                        fmt.Sprintf("Expected import identifier with format: zone_fqdn,id. Got: %q", req.ID),
                )
                return
        }</span>

        <span class="cov0" title="0">resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("zone_fqdn"), zoneFQDN)...)
        resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("id"), recordId)...)</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">package domain

import (
        "terraform-provider-infomaniak/internal/apis/domain"

        "github.com/hashicorp/terraform-plugin-framework-validators/objectvalidator"
        "github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
        "github.com/hashicorp/terraform-plugin-framework/path"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/int64default"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/int64planmodifier"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
        "github.com/hashicorp/terraform-plugin-framework/schema/validator"
)

func getRecordResourceSchema() schema.Schema <span class="cov0" title="0">{
        return schema.Schema{
                Attributes: map[string]schema.Attribute{
                        "zone_fqdn": schema.StringAttribute{
                                Required:            true,
                                MarkdownDescription: "The FQDN of the zone where the record should be put in.",
                                PlanModifiers: []planmodifier.String{
                                        stringplanmodifier.RequiresReplace(),
                                },
                        },
                        "source": schema.StringAttribute{
                                Required:            true,
                                MarkdownDescription: "The source of the Record.",
                                PlanModifiers: []planmodifier.String{
                                        stringplanmodifier.RequiresReplace(),
                                        stringplanmodifier.UseStateForUnknown(),
                                },
                        },
                        "type": schema.StringAttribute{
                                Required:            true,
                                MarkdownDescription: "The type of the Record.",
                                Validators: []validator.String{
                                        stringvalidator.OneOf(domain.RecordTypes...),
                                },
                                PlanModifiers: []planmodifier.String{
                                        stringplanmodifier.RequiresReplace(),
                                        stringplanmodifier.UseStateForUnknown(),
                                },
                        },
                        "description": schema.StringAttribute{
                                Optional:            true,
                                MarkdownDescription: "The description of the Record.",
                                PlanModifiers: []planmodifier.String{
                                        stringplanmodifier.UseStateForUnknown(),
                                },
                        },
                        "ttl": schema.Int64Attribute{
                                Optional:            true,
                                Computed:            true,
                                MarkdownDescription: "The TTL of the Record.",
                                Default:             int64default.StaticInt64(3600),
                                PlanModifiers: []planmodifier.Int64{
                                        int64planmodifier.UseStateForUnknown(),
                                },
                        },
                        "computed_target": schema.StringAttribute{
                                Computed:            true,
                                MarkdownDescription: "The computed target of the Record.",
                        },
                        "target": schema.StringAttribute{
                                Optional:            true,
                                MarkdownDescription: "The target of the Record.",
                                Validators: []validator.String{
                                        stringvalidator.ConflictsWith(path.MatchRoot("data")),
                                },
                        },
                        "data": schema.SingleNestedAttribute{
                                Description: "Components of a DNS record.",
                                Optional:    true,
                                Validators: []validator.Object{
                                        objectvalidator.All(
                                                objectvalidator.ConflictsWith(path.MatchRoot("target")),
                                        ),
                                },
                                Attributes: map[string]schema.Attribute{
                                        "ip": schema.StringAttribute{
                                                Optional:            true,
                                                MarkdownDescription: "IP for the record",
                                        },
                                        // For MX, SRV, TLSA, SMIMEA, SSHFP
                                        "priority": schema.Int64Attribute{
                                                Optional:            true,
                                                MarkdownDescription: "The priority/usage/weight of the Record (MX, SRV, TLSA, SMIMEA).",
                                        },
                                        // For SRV
                                        "weight": schema.Int64Attribute{
                                                Optional:            true,
                                                MarkdownDescription: "The weight of the Record (SRV).",
                                        },
                                        "port": schema.Int64Attribute{
                                                Optional:            true,
                                                MarkdownDescription: "The port of the Record (SRV).",
                                        },

                                        // For CAA
                                        "flags": schema.Int64Attribute{
                                                Optional:            true,
                                                MarkdownDescription: "The flags of the Record (CAA).",
                                        },
                                        "tag": schema.StringAttribute{
                                                Optional:            true,
                                                MarkdownDescription: "The tag of the Record (CAA).",
                                        },

                                        // For DNSKEY
                                        "algorithm": schema.Int64Attribute{
                                                Optional:            true,
                                                MarkdownDescription: "The algorithm of the Record (DNSKEY, DS, SSHFP).",
                                        },

                                        // For DS
                                        "key_tag": schema.Int64Attribute{
                                                Optional:            true,
                                                MarkdownDescription: "The Key Tag of the Record (DS).",
                                        },
                                        "digest_type": schema.Int64Attribute{
                                                Optional:            true,
                                                MarkdownDescription: "The digest type of the Record (DS).",
                                        },
                                        "digest": schema.StringAttribute{
                                                Optional:            true,
                                                MarkdownDescription: "The digest of the Record (DS).",
                                        },

                                        // For TLSA / SMIMEA
                                        "selector": schema.Int64Attribute{
                                                Optional:            true,
                                                MarkdownDescription: "The selector of the Record (TLSA, SMIMEA).",
                                        },
                                        "matching_type": schema.Int64Attribute{
                                                Optional:            true,
                                                MarkdownDescription: "The matching type of the Record (TLSA, SMIMEA).",
                                        },
                                        "cert_assoc_data": schema.StringAttribute{
                                                Optional:            true,
                                                MarkdownDescription: "The certificate association data (TLSA, SMIMEA).",
                                        },

                                        // For SSHFP
                                        "fingerprint_algorithm": schema.Int64Attribute{
                                                Optional:            true,
                                                MarkdownDescription: "The algorithm of the Record (DNSKEY, DS, SSHFP).",
                                        },
                                        "fingerprint_type": schema.Int64Attribute{
                                                Optional:            true,
                                                MarkdownDescription: "The fingerprint type of the Record (SSHFP).",
                                        },
                                        "fingerprint": schema.StringAttribute{
                                                Optional:            true,
                                                MarkdownDescription: "The fingerprint of the Record (SSHFP).",
                                        },

                                        "target": schema.StringAttribute{
                                                Optional:            true,
                                                MarkdownDescription: "The target of the Record (MX, CNAME, DNAME, NS, PTR, etc).",
                                        },
                                        // For generic text value (e.g. TXT, CAA value, etc)
                                        "value": schema.StringAttribute{
                                                Optional:            true,
                                                MarkdownDescription: "The value of the Record (TXT, CAA, etc).",
                                        },
                                },
                        },
                        "id": schema.Int64Attribute{
                                Computed:            true,
                                MarkdownDescription: "The id of the Record.",
                                PlanModifiers: []planmodifier.Int64{
                                        int64planmodifier.UseStateForUnknown(),
                                },
                        },
                },
                MarkdownDescription: "The record resource allows the user to manage a record inside a zone of a domain",
        }
}</span>
</pre>
		
		<pre class="file" id="file33" style="display: none">package domain

import "terraform-provider-infomaniak/internal/provider/registry"

func Register() <span class="cov0" title="0">{
        registry.RegisterResource(NewZoneResource)
        registry.RegisterResource(NewRecordResource)
}</span>
</pre>
		
		<pre class="file" id="file34" style="display: none">package domain

import (
        "context"
        "terraform-provider-infomaniak/internal/apis"
        "terraform-provider-infomaniak/internal/provider"

        "github.com/hashicorp/terraform-plugin-framework/path"
        "github.com/hashicorp/terraform-plugin-framework/resource"
        "github.com/hashicorp/terraform-plugin-framework/types"
)

var (
        _ resource.Resource                = &amp;zoneResource{}
        _ resource.ResourceWithConfigure   = &amp;zoneResource{}
        _ resource.ResourceWithImportState = &amp;zoneResource{}
)

func NewZoneResource() resource.Resource <span class="cov0" title="0">{
        return &amp;zoneResource{}
}</span>

type zoneResource struct {
        client *apis.Client
}

type ZoneModel struct {
        Fqdn types.String `tfsdk:"fqdn"`
        Id   types.Int64  `tfsdk:"id"`
}

func (r *zoneResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) <span class="cov0" title="0">{
        resp.TypeName = req.ProviderTypeName + "_zone"
}</span>

// Configure adds the provider configured client to the data source.
func (r *zoneResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) <span class="cov0" title="0">{
        // Add a nil check when handling ProviderData because Terraform
        // sets that data after it calls the ConfigureProvider RPC.
        if req.ProviderData == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">client, err := provider.GetApiClient(req.ProviderData)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unexpected Zone Resource Configure Type",
                        err.Error(),
                )
                return
        }</span>

        <span class="cov0" title="0">r.client = client</span>
}

func (r *zoneResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) <span class="cov0" title="0">{
        resp.Schema = getZoneResourceSchema()
}</span>

func (r *zoneResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) <span class="cov0" title="0">{
        var data ZoneModel

        // Read Terraform plan data into the model
        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)

        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // CreateZone API call logic
        <span class="cov0" title="0">zone, err := r.client.Domain.CreateZone(data.Fqdn.ValueString())
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error when creating Zone",
                        err.Error(),
                )
                return
        }</span>

        <span class="cov0" title="0">data.Id = types.Int64Value(int64(zone.ID))
        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *zoneResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) <span class="cov0" title="0">{
        var state ZoneModel

        // Read Terraform plan data into the model
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;state)...)

        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // Read API call logic
        <span class="cov0" title="0">zone, err := r.client.Domain.GetZone(state.Fqdn.ValueString())
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error when reading Zone",
                        err.Error(),
                )
                return
        }</span>

        <span class="cov0" title="0">state.Id = types.Int64Value(int64(zone.ID))
        state.Fqdn = types.StringValue(zone.FQDN)

        // Save updated data into Terraform state
        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;state)...)</span>
}

func (r *zoneResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) <span class="cov0" title="0">{
        var state ZoneModel
        var data ZoneModel

        // Read Terraform plan data into the model
        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;state)...)

        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // Save updated data into Terraform state
        <span class="cov0" title="0">resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *zoneResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) <span class="cov0" title="0">{
        var data ZoneModel

        // Read Terraform prior state data into the model
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;data)...)

        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // DeleteZone API call logic
        <span class="cov0" title="0">_, err := r.client.Domain.DeleteZone(data.Fqdn.ValueString())
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error when deleting Zone",
                        err.Error(),
                )
                return
        }</span>
}

func (r *zoneResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) <span class="cov0" title="0">{
        resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("fqdn"), req.ID)...)
}</span>
</pre>
		
		<pre class="file" id="file35" style="display: none">package domain

import (
        "github.com/hashicorp/terraform-plugin-framework/resource/schema"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/int64planmodifier"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
)

func getZoneResourceSchema() schema.Schema <span class="cov0" title="0">{
        return schema.Schema{
                Attributes: map[string]schema.Attribute{
                        "fqdn": schema.StringAttribute{
                                Required:            true,
                                MarkdownDescription: "The fqdn of the zone",
                                PlanModifiers: []planmodifier.String{
                                        stringplanmodifier.RequiresReplace(),
                                },
                        },
                        "id": schema.Int64Attribute{
                                Computed:            true,
                                MarkdownDescription: "The unique identifier for the zone. Mandatory for acceptance testing.",
                                PlanModifiers: []planmodifier.Int64{
                                        int64planmodifier.UseStateForUnknown(),
                                },
                        },
                },
                MarkdownDescription: "The Zone resource allows the user to manage a zone for a domain project",
        }
}</span>
</pre>
		
		<pre class="file" id="file36" style="display: none">package kaas

import (
        "context"
        "terraform-provider-infomaniak/internal/apis"
        "terraform-provider-infomaniak/internal/provider"

        "github.com/hashicorp/terraform-plugin-framework/datasource"
        "github.com/hashicorp/terraform-plugin-framework/types"
)

// Ensure the implementation satisfies the expected interfaces.
var (
        _ datasource.DataSource              = &amp;kaasDataSource{}
        _ datasource.DataSourceWithConfigure = &amp;kaasDataSource{}
)

type kaasDataSource struct {
        client *apis.Client
}

// NewKaasDataSource is a helper function to simplify the provider implementation.
func NewKaasDataSource() datasource.DataSource <span class="cov0" title="0">{
        return &amp;kaasDataSource{}
}</span>

// Configure adds the provider configured client to the data source.
func (d *kaasDataSource) Configure(_ context.Context, req datasource.ConfigureRequest, resp *datasource.ConfigureResponse) <span class="cov0" title="0">{
        // Add a nil check when handling ProviderData because Terraform
        // sets that data after it calls the ConfigureProvider RPC.
        if req.ProviderData == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">client, err := provider.GetApiClient(req.ProviderData)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unexpected Data Source Configure Type",
                        err.Error(),
                )
                return
        }</span>

        <span class="cov0" title="0">d.client = client</span>
}

// Schema defines the schema for the data source.
func (d *kaasDataSource) Schema(ctx context.Context, _ datasource.SchemaRequest, resp *datasource.SchemaResponse) <span class="cov0" title="0">{
        resp.Schema = getKaasDataSourceSchema()
}</span>

// Read refreshes the Terraform state with the latest data.
func (d *kaasDataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) <span class="cov0" title="0">{
        var data KaasModel

        resp.Diagnostics.Append(req.Config.Get(ctx, &amp;data)...)

        obj, err := d.client.Kaas.GetKaas(
                data.PublicCloudId.ValueInt64(),
                data.PublicCloudProjectId.ValueInt64(),
                data.Id.ValueInt64(),
        )
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unable to find KaaS",
                        err.Error(),
                )
                return
        }</span>

        <span class="cov0" title="0">kubeconfig, err := d.client.Kaas.GetKubeconfig(
                data.PublicCloudId.ValueInt64(),
                data.PublicCloudProjectId.ValueInt64(),
                data.Id.ValueInt64(),
        )
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unable to get kubeconfig from KaaS",
                        err.Error(),
                )
                return
        }</span>

        <span class="cov0" title="0">data.Kubeconfig = types.StringValue(kubeconfig)
        data.Region = types.StringValue(obj.Region)
        data.KubernetesVersion = types.StringValue(obj.KubernetesVersion)

        apiserverParams, err := d.client.Kaas.GetApiserverParams(
                data.PublicCloudId.ValueInt64(),
                data.PublicCloudProjectId.ValueInt64(),
                data.Id.ValueInt64(),
        )
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unable to get Oidc from KaaS",
                        err.Error(),
                )
                return
        }</span>

        <span class="cov0" title="0">if apiserverParams != nil </span><span class="cov0" title="0">{
                data.fillApiserverState(ctx, apiserverParams)
        }</span>

        // Set state
        <span class="cov0" title="0">diags := resp.State.Set(ctx, &amp;data)
        resp.Diagnostics.Append(diags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>
}

// Metadata returns the data source type name.
func (d *kaasDataSource) Metadata(_ context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) <span class="cov0" title="0">{
        resp.TypeName = req.ProviderTypeName + "_kaas"
}</span>
</pre>
		
		<pre class="file" id="file37" style="display: none">package kaas

import (
        "github.com/hashicorp/terraform-plugin-framework/datasource/schema"
        "github.com/hashicorp/terraform-plugin-framework/types"
)

func getKaasDataSourceSchema() schema.Schema <span class="cov0" title="0">{
        return schema.Schema{
                Attributes: map[string]schema.Attribute{
                        "public_cloud_id": schema.Int64Attribute{
                                Required:            true,
                                Description:         "The id of the public cloud where KaaS is installed",
                                MarkdownDescription: "The id of the public cloud where KaaS is installed",
                        },
                        "public_cloud_project_id": schema.Int64Attribute{
                                Required:            true,
                                Description:         "The id of the public cloud project where KaaS is installed",
                                MarkdownDescription: "The id of the public cloud project where KaaS is installed",
                        },
                        "id": schema.Int64Attribute{
                                Required:            true,
                                Description:         "The id of this KaaS",
                                MarkdownDescription: "The id of this KaaS",
                        },
                        "name": schema.StringAttribute{
                                Computed:            true,
                                Description:         "The name of the KaaS project",
                                MarkdownDescription: "The name of the KaaS project",
                        },
                        "pack_name": schema.StringAttribute{
                                Computed:            true,
                                Description:         "The name of the pack associated to the KaaS project",
                                MarkdownDescription: "The name of the pack associated to the KaaS project",
                        },
                        "region": schema.StringAttribute{
                                Computed:            true,
                                Description:         "The region where the KaaS project resides in.",
                                MarkdownDescription: "The region where the KaaS project resides in.",
                        },
                        "kubeconfig": schema.StringAttribute{
                                Computed:            true,
                                Sensitive:           true,
                                Description:         "The kubeconfig generated to access to KaaS project",
                                MarkdownDescription: "The kubeconfig generated to access to KaaS project",
                        },
                        "kubernetes_version": schema.StringAttribute{
                                Computed:            true,
                                Description:         "The version of Kubernetes associated with the KaaS project",
                                MarkdownDescription: "The version of Kubernetes associated with the KaaS project",
                        },
                        "apiserver": schema.SingleNestedAttribute{
                                Description:         "Kubernetes Apiserver editable params",
                                MarkdownDescription: "Kubernetes Apiserver editable params",
                                Attributes: map[string]schema.Attribute{
                                        "params": schema.MapAttribute{
                                                ElementType:         types.StringType,
                                                Optional:            true,
                                                Description:         "Map of Kubernetes Apiserver params in case the terraform provider does not already abstracts them",
                                                MarkdownDescription: "Map of Kubernetes Apiserver params in case the terraform provider does not already abstracts them",
                                        },
                                        "audit": schema.SingleNestedAttribute{
                                                MarkdownDescription: "Kubernetes audit logs specification files",
                                                Computed:            true,
                                                Attributes: map[string]schema.Attribute{
                                                        "webhook_config": schema.StringAttribute{
                                                                MarkdownDescription: "YAML manifest for audit webhook config",
                                                                Computed:            true,
                                                        },
                                                        "policy": schema.StringAttribute{
                                                                MarkdownDescription: "YAML manifest for audit policy",
                                                                Computed:            true,
                                                        },
                                                },
                                        },
                                        "oidc": schema.SingleNestedAttribute{
                                                Description:         "OIDC specific Apiserver params",
                                                MarkdownDescription: "OIDC specific Apiserver params",
                                                Computed:            true,
                                                Attributes: map[string]schema.Attribute{
                                                        "ca": schema.StringAttribute{
                                                                Computed:            true,
                                                                Description:         "OIDC Ca Certificate",
                                                                MarkdownDescription: "OIDC Ca Certificate",
                                                        },
                                                        "groups_claim": schema.StringAttribute{
                                                                Computed:            true,
                                                                MarkdownDescription: "OIDC groups claim",
                                                        },
                                                        "groups_prefix": schema.StringAttribute{
                                                                Computed:            true,
                                                                MarkdownDescription: "OIDC groups prefix",
                                                        },
                                                        "issuer_url": schema.StringAttribute{
                                                                Computed:            true,
                                                                Description:         "OIDC issuer URL",
                                                                MarkdownDescription: "OIDC issuer URL",
                                                        },
                                                        "client_id": schema.StringAttribute{
                                                                Computed:            true,
                                                                Description:         "OIDC client identifier",
                                                                MarkdownDescription: "OIDC client identifier",
                                                        },
                                                        "username_claim": schema.StringAttribute{
                                                                Optional:            true,
                                                                Description:         "OIDC username claim",
                                                                MarkdownDescription: "OIDC username claim",
                                                        },
                                                        "username_prefix": schema.StringAttribute{
                                                                Computed:            true,
                                                                Description:         "OIDC username prefix",
                                                                MarkdownDescription: "OIDC username prefix",
                                                        },
                                                        "required_claim": schema.StringAttribute{
                                                                Computed:            true,
                                                                MarkdownDescription: "A key=value pair that describes a required claim in the ID Token.",
                                                        },
                                                        "signing_algs": schema.StringAttribute{
                                                                Computed:            true,
                                                                Description:         "OIDC signing algorithm. Kubernetes will default it to RS256",
                                                                MarkdownDescription: "OIDC signing algorithm. Kubernetes will default it to RS256",
                                                        },
                                                },
                                        },
                                },
                                Optional: true,
                        },
                },
                MarkdownDescription: "The kaas data source allows the user to manage a kaas project",
        }
}</span>
</pre>
		
		<pre class="file" id="file38" style="display: none">package kaas

import (
        "context"
        "terraform-provider-infomaniak/internal/apis"
        "terraform-provider-infomaniak/internal/provider"

        "github.com/hashicorp/terraform-plugin-framework/datasource"
        "github.com/hashicorp/terraform-plugin-framework/types"
)

// Ensure the implementation satisfies the expected interfaces.
var (
        _ datasource.DataSource              = &amp;kaasInstancePoolDataSource{}
        _ datasource.DataSourceWithConfigure = &amp;kaasInstancePoolDataSource{}
)

type kaasInstancePoolDataSource struct {
        client *apis.Client
}

// NewKaasInstancePoolDataSource is a helper function to simplify the provider implementation.
func NewKaasInstancePoolDataSource() datasource.DataSource <span class="cov0" title="0">{
        return &amp;kaasInstancePoolDataSource{}
}</span>

// Configure adds the provider configured client to the data source.
func (d *kaasInstancePoolDataSource) Configure(_ context.Context, req datasource.ConfigureRequest, resp *datasource.ConfigureResponse) <span class="cov0" title="0">{
        // Add a nil check when handling ProviderData because Terraform
        // sets that data after it calls the ConfigureProvider RPC.
        if req.ProviderData == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">client, err := provider.GetApiClient(req.ProviderData)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unexpected Data Source Configure Type",
                        err.Error(),
                )
                return
        }</span>

        <span class="cov0" title="0">d.client = client</span>
}

// Schema defines the schema for the data source.
func (d *kaasInstancePoolDataSource) Schema(ctx context.Context, _ datasource.SchemaRequest, resp *datasource.SchemaResponse) <span class="cov0" title="0">{
        resp.Schema = getKaasInstancePoolDataSourceSchema()
}</span>

// Read refreshes the Terraform state with the latest data.
func (d *kaasInstancePoolDataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) <span class="cov0" title="0">{
        var data KaasInstancePoolModel

        resp.Diagnostics.Append(req.Config.Get(ctx, &amp;data)...)

        obj, err := d.client.Kaas.GetInstancePool(
                data.PublicCloudId.ValueInt64(),
                data.PublicCloudProjectId.ValueInt64(),
                data.KaasId.ValueInt64(),
                data.Id.ValueInt64(),
        )
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unable to find KaaS instance pool",
                        err.Error(),
                )
                return
        }</span>

        <span class="cov0" title="0">data.Id = types.Int64Value(obj.Id)
        data.Name = types.StringValue(obj.Name)
        data.FlavorName = types.StringValue(obj.FlavorName)
        data.MinInstances = types.Int64Value(obj.MinInstances)
        data.MaxInstances = types.Int64Value(obj.MaxInstances)
        labels, diags := types.MapValueFrom(ctx, types.StringType, obj.Labels)
        resp.Diagnostics.Append(diags...)
        data.Labels = labels

        // Set state
        diags = resp.State.Set(ctx, &amp;data)
        resp.Diagnostics.Append(diags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>
}

// Metadata returns the data source type name.
func (d *kaasInstancePoolDataSource) Metadata(_ context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) <span class="cov0" title="0">{
        resp.TypeName = req.ProviderTypeName + "_kaas_instance_pool"
}</span>
</pre>
		
		<pre class="file" id="file39" style="display: none">package kaas

import (
        "github.com/hashicorp/terraform-plugin-framework/datasource/schema"
        "github.com/hashicorp/terraform-plugin-framework/types"
)

func getKaasInstancePoolDataSourceSchema() schema.Schema <span class="cov0" title="0">{
        return schema.Schema{
                Attributes: map[string]schema.Attribute{
                        "public_cloud_id": schema.Int64Attribute{
                                Required:    true,
                                Description: "The id of the public cloud where KaaS is installed",
                        },
                        "public_cloud_project_id": schema.Int64Attribute{
                                Required:    true,
                                Description: "The id of the public cloud project where KaaS is installed",
                        },
                        "kaas_id": schema.Int64Attribute{
                                Required:    true,
                                Description: "The id of the kaas project.",
                        },
                        "id": schema.Int64Attribute{
                                Required:    true,
                                Description: "The unique identifier for the instance pool.",
                        },
                        "name": schema.StringAttribute{
                                Computed:    true,
                                Description: "The name of this instance pool",
                        },
                        "availability_zone": schema.StringAttribute{
                                Computed:            true,
                                Description:         "The availability zone for the instances in the pool",
                                MarkdownDescription: "The availability zone for the instances in the pool",
                        },
                        "flavor_name": schema.StringAttribute{
                                Computed:    true,
                                Description: "The flavor name of the instance in this instance pool",
                        },
                        "min_instances": schema.Int64Attribute{
                                Computed:    true,
                                Description: "The minimum amount of instances in the instance pool",
                        },
                        "max_instances": schema.Int64Attribute{
                                Computed:    true,
                                Description: "The maximum amount of instances in the instance pool",
                        },
                        "labels": schema.MapAttribute{
                                ElementType: types.StringType,
                                Computed:    true,
                                Description: "Kubernetes node labels",
                        },
                },
                MarkdownDescription: "The KaaS Instance Pool data source retrieves information about a KaaS instance pool.",
        }
}</span>
</pre>
		
		<pre class="file" id="file40" style="display: none">package kaas

import (
        "context"
        "errors"
        "fmt"
        "strconv"
        "strings"
        "terraform-provider-infomaniak/internal/apis"
        "terraform-provider-infomaniak/internal/apis/kaas"
        "terraform-provider-infomaniak/internal/provider"
        "time"

        "github.com/hashicorp/terraform-plugin-framework/path"
        "github.com/hashicorp/terraform-plugin-framework/resource"

        "github.com/hashicorp/terraform-plugin-framework/types"
)

var (
        _ resource.Resource              = &amp;kaasInstancePoolResource{}
        _ resource.ResourceWithConfigure = &amp;kaasInstancePoolResource{}
)

func NewKaasInstancePoolResource() resource.Resource <span class="cov0" title="0">{
        return &amp;kaasInstancePoolResource{}
}</span>

type kaasInstancePoolResource struct {
        client *apis.Client
}

type KaasInstancePoolModel struct {
        PublicCloudId        types.Int64 `tfsdk:"public_cloud_id"`
        PublicCloudProjectId types.Int64 `tfsdk:"public_cloud_project_id"`
        KaasId               types.Int64 `tfsdk:"kaas_id"`
        Id                   types.Int64 `tfsdk:"id"`

        Name             types.String `tfsdk:"name"`
        AvailabilityZone types.String `tfsdk:"availability_zone"`
        FlavorName       types.String `tfsdk:"flavor_name"`
        MinInstances     types.Int64  `tfsdk:"min_instances"`
        MaxInstances     types.Int64  `tfsdk:"max_instances"`
        Labels           types.Map    `tfsdk:"labels"`
}

func (r *kaasInstancePoolResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) <span class="cov0" title="0">{
        resp.TypeName = req.ProviderTypeName + "_kaas_instance_pool"
}</span>

// Configure adds the provider configured client to the data source.
func (r *kaasInstancePoolResource) Configure(_ context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) <span class="cov0" title="0">{
        // Add a nil check when handling ProviderData because Terraform
        // sets that data after it calls the ConfigureProvider RPC.
        if req.ProviderData == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">client, err := provider.GetApiClient(req.ProviderData)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unexpected Resource Configure Type",
                        err.Error(),
                )
                return
        }</span>

        <span class="cov0" title="0">r.client = client</span>
}

func (r *kaasInstancePoolResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) <span class="cov0" title="0">{
        resp.Schema = getKaasInstancePoolResourceSchema()
}</span>

func (r *kaasInstancePoolResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) <span class="cov0" title="0">{
        var data KaasInstancePoolModel

        // Read Terraform plan data into the model
        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)

        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">input := &amp;kaas.InstancePool{
                KaasId:           data.KaasId.ValueInt64(),
                Name:             data.Name.ValueString(),
                AvailabilityZone: data.AvailabilityZone.ValueString(),
                FlavorName:       data.FlavorName.ValueString(),
                MinInstances:     data.MinInstances.ValueInt64(),
                MaxInstances:     data.MaxInstances.ValueInt64(),
                Labels:           r.getLabelsValues(data),
        }

        // CreateKaas API call logic
        instancePoolId, err := r.client.Kaas.CreateInstancePool(
                data.PublicCloudId.ValueInt64(),
                data.PublicCloudProjectId.ValueInt64(),
                input,
        )
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error when creating KaaS instance pool",
                        err.Error(),
                )
                return
        }</span>

        <span class="cov0" title="0">data.Id = types.Int64Value(instancePoolId)
        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)

        isScalingDown := false
        instancePoolObject, err := r.waitUntilActive(ctx, data, instancePoolId, isScalingDown)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error when waiting for KaaS Instance Pool to be Active",
                        err.Error(),
                )
                return
        }</span>

        <span class="cov0" title="0">if instancePoolObject == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">data.fill(instancePoolObject)

        // Save data into Terraform state
        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *kaasInstancePoolResource) getLabelsValues(data KaasInstancePoolModel) map[string]string <span class="cov0" title="0">{
        labels := make(map[string]string)

        if !data.Labels.IsNull() &amp;&amp; !data.Labels.IsUnknown() </span><span class="cov0" title="0">{
                for key, val := range data.Labels.Elements() </span><span class="cov0" title="0">{
                        if strVal, ok := val.(types.String); ok &amp;&amp; !strVal.IsNull() &amp;&amp; !strVal.IsUnknown() </span><span class="cov0" title="0">{
                                labels[key] = strVal.ValueString()
                        }</span>
                }
        }

        <span class="cov0" title="0">return labels</span>
}

func (r *kaasInstancePoolResource) waitUntilActive(ctx context.Context, data KaasInstancePoolModel, id int64, scalingDown bool) (*kaas.InstancePool, error) <span class="cov0" title="0">{
        scaleDownFailedQuotaCount := 0
        scaleDownFailedQuotaAllowedRetrys := 5
        ticker := time.NewTicker(5 * time.Second)
        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return nil, nil</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        found, err := r.client.Kaas.GetInstancePool(
                                data.PublicCloudId.ValueInt64(),
                                data.PublicCloudProjectId.ValueInt64(),
                                data.KaasId.ValueInt64(),
                                id,
                        )
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>

                        <span class="cov0" title="0">if len(found.ErrorMessages) &gt; 0 </span><span class="cov0" title="0">{
                                // Special case when we hit quota failure but we are scaling down. OpenStack can take some time to update so we let him do his work
                                if (found.Status == "ScalingDown" || scalingDown) &amp;&amp; scaleDownFailedQuotaCount &lt;= scaleDownFailedQuotaAllowedRetrys </span><span class="cov0" title="0">{
                                        scaleDownFailedQuotaCount++
                                        continue</span>
                                }
                                <span class="cov0" title="0">return nil, errors.New(strings.Join(found.ErrorMessages, ","))</span>
                        }

                        // We need the instance pool to be active, have the same state as us, be scaled properly and be in bound of the autoscaling
                        <span class="cov0" title="0">isActive := found.Status == "Active"
                        isEquivalent := found.MinInstances == data.MinInstances.ValueInt64()
                        isScaledProperly := found.AvailableInstances == found.TargetInstances
                        isInBound := found.MinInstances &lt;= found.TargetInstances &amp;&amp; found.TargetInstances &lt;= found.MaxInstances
                        if isActive &amp;&amp; isEquivalent &amp;&amp; isScaledProperly &amp;&amp; isInBound </span><span class="cov0" title="0">{
                                return found, nil
                        }</span>
                }
        }
}

func (r *kaasInstancePoolResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) <span class="cov0" title="0">{
        var data KaasInstancePoolModel

        // Read Terraform prior state data into the model
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;data)...)

        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // Read API call logic
        <span class="cov0" title="0">obj, err := r.client.Kaas.GetInstancePool(
                data.PublicCloudId.ValueInt64(),
                data.PublicCloudProjectId.ValueInt64(),
                data.KaasId.ValueInt64(),
                data.Id.ValueInt64(),
        )
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error when reading KaaS Instance Pool",
                        err.Error(),
                )
                return
        }</span>

        <span class="cov0" title="0">if len(obj.ErrorMessages) &gt; 0 </span><span class="cov0" title="0">{
                resp.Diagnostics.AddWarning(
                        "KaaS was in error state:",
                        strings.Join(obj.ErrorMessages, ","),
                )
        }</span>

        <span class="cov0" title="0">data.fill(obj)

        // Save updated data into Terraform state
        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *kaasInstancePoolResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) <span class="cov0" title="0">{
        var state KaasInstancePoolModel
        var data KaasInstancePoolModel

        // Read Terraform plan data into the model
        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;state)...)

        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // Update API call logic
        <span class="cov0" title="0">input := &amp;kaas.InstancePool{
                KaasId: data.KaasId.ValueInt64(),
                Id:     state.Id.ValueInt64(),

                Name:         data.Name.ValueString(),
                FlavorName:   data.FlavorName.ValueString(),
                MinInstances: data.MinInstances.ValueInt64(),
                MaxInstances: data.MaxInstances.ValueInt64(),
                Labels:       r.getLabelsValues(data),
        }

        _, err := r.client.Kaas.UpdateInstancePool(
                data.PublicCloudId.ValueInt64(),
                data.PublicCloudProjectId.ValueInt64(),
                input,
        )
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error when updating KaaS Instance Pool",
                        err.Error(),
                )
                return
        }</span>

        <span class="cov0" title="0">scalingDown := data.MaxInstances.ValueInt64() &lt; state.MaxInstances.ValueInt64()
        instancePoolObject, err := r.waitUntilActive(ctx, data, state.Id.ValueInt64(), scalingDown)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error when waiting for KaaS Instance Pool to be Active",
                        err.Error(),
                )
                return
        }</span>

        <span class="cov0" title="0">if instancePoolObject == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">data.fill(instancePoolObject)

        // Save updated data into Terraform state
        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *kaasInstancePoolResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) <span class="cov0" title="0">{
        var data KaasInstancePoolModel

        // Read Terraform prior state data into the model
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;data)...)

        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // DeleteKaas API call logic
        <span class="cov0" title="0">_, err := r.client.Kaas.DeleteInstancePool(
                data.PublicCloudId.ValueInt64(),
                data.PublicCloudProjectId.ValueInt64(),
                data.KaasId.ValueInt64(),
                data.Id.ValueInt64(),
        )
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error when deleting KaaS",
                        err.Error(),
                )
                return
        }</span>
}

func (r *kaasInstancePoolResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) <span class="cov0" title="0">{
        idParts := strings.Split(req.ID, ",")

        if len(idParts) != 4 || idParts[0] == "" || idParts[1] == "" || idParts[2] == "" || idParts[3] == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unexpected Import Identifier",
                        fmt.Sprintf("Expected import identifier with format: public_cloud_id,public_cloud_project_id,kaas_id,id. Got: %q", req.ID),
                )
                return
        }</span>

        <span class="cov0" title="0">var errorList error

        publicCloudId, err := strconv.ParseInt(idParts[0], 10, 64)
        errorList = errors.Join(errorList, err)
        publicCloudProjectId, err := strconv.ParseInt(idParts[1], 10, 64)
        errorList = errors.Join(errorList, err)
        kaasId, err := strconv.ParseInt(idParts[2], 10, 64)
        errorList = errors.Join(errorList, err)
        instancePoolId, err := strconv.ParseInt(idParts[3], 10, 64)
        errorList = errors.Join(errorList, err)

        if errorList != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unexpected Import Identifier",
                        fmt.Sprintf("Expected import identifier with format: public_cloud_id,public_cloud_project_id,kaas_id,id. Got: %q", req.ID),
                )
                return
        }</span>

        <span class="cov0" title="0">resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("public_cloud_id"), publicCloudId)...)
        resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("public_cloud_project_id"), publicCloudProjectId)...)
        resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("kaas_id"), kaasId)...)
        resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("id"), instancePoolId)...)</span>
}

func (model *KaasInstancePoolModel) fill(instancePool *kaas.InstancePool) <span class="cov0" title="0">{
        model.Id = types.Int64Value(instancePool.Id)
        model.Name = types.StringValue(instancePool.Name)
        model.FlavorName = types.StringValue(instancePool.FlavorName)
        model.MinInstances = types.Int64Value(instancePool.MinInstances)
        model.MaxInstances = types.Int64Value(instancePool.MaxInstances)
        model.AvailabilityZone = types.StringValue(instancePool.AvailabilityZone)
}</span>
</pre>
		
		<pre class="file" id="file41" style="display: none">package kaas

import (
        "github.com/hashicorp/terraform-plugin-framework/resource/schema"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/int64planmodifier"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/mapplanmodifier"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
        "github.com/hashicorp/terraform-plugin-framework/types"
)

func getKaasInstancePoolResourceSchema() schema.Schema <span class="cov0" title="0">{
        return schema.Schema{
                Attributes: map[string]schema.Attribute{
                        "public_cloud_id": schema.Int64Attribute{
                                Required:            true,
                                Description:         "The id of the public cloud where KaaS is installed",
                                MarkdownDescription: "The id of the public cloud where KaaS is installed",
                                PlanModifiers: []planmodifier.Int64{
                                        int64planmodifier.RequiresReplace(),
                                },
                        },
                        "public_cloud_project_id": schema.Int64Attribute{
                                Required:            true,
                                Description:         "The id of the public cloud project where KaaS is installed",
                                MarkdownDescription: "The id of the public cloud project where KaaS is installed",
                                PlanModifiers: []planmodifier.Int64{
                                        int64planmodifier.RequiresReplace(),
                                },
                        },
                        "kaas_id": schema.Int64Attribute{
                                Required:            true,
                                Description:         "The id of the kaas project.",
                                MarkdownDescription: "The id of the kaas project.",
                                PlanModifiers: []planmodifier.Int64{
                                        int64planmodifier.RequiresReplace(),
                                },
                        },
                        "id": schema.Int64Attribute{
                                Computed:            true,
                                Description:         "A computed value representing the unique identifier for the instance pool. Mandatory for acceptance testing.",
                                MarkdownDescription: "A computed value representing the unique identifier for the instance pool. Mandatory for acceptance testing.",
                                PlanModifiers: []planmodifier.Int64{
                                        int64planmodifier.UseStateForUnknown(),
                                },
                        },
                        "name": schema.StringAttribute{
                                Required:            true,
                                Description:         "The name of the instance pool",
                                MarkdownDescription: "The name of the instance pool",
                                PlanModifiers: []planmodifier.String{
                                        stringplanmodifier.UseStateForUnknown(),
                                },
                        },
                        "availability_zone": schema.StringAttribute{
                                Required:            true,
                                Description:         "The availability zone for the instances in the pool",
                                MarkdownDescription: "The availability zone for the instances in the pool",
                                PlanModifiers: []planmodifier.String{
                                        stringplanmodifier.RequiresReplace(),
                                },
                        },
                        "flavor_name": schema.StringAttribute{
                                Required:            true,
                                Description:         "The flavor name for the instances in the pool",
                                MarkdownDescription: "The flavor name for the instances in the pool",
                                PlanModifiers: []planmodifier.String{
                                        stringplanmodifier.RequiresReplace(),
                                },
                        },
                        "min_instances": schema.Int64Attribute{
                                Required:            true,
                                Description:         "The minimum amount of instances in this instance pool",
                                MarkdownDescription: "The minimum amount of instances in this instance pool",
                                PlanModifiers: []planmodifier.Int64{
                                        int64planmodifier.UseStateForUnknown(),
                                },
                        },
                        "max_instances": schema.Int64Attribute{
                                Required:            true,
                                Description:         "The maximum amount of instances in this instance pool",
                                MarkdownDescription: "The maximum amount of instances in this instance pool",
                                PlanModifiers: []planmodifier.Int64{
                                        int64planmodifier.UseStateForUnknown(),
                                },
                        },
                        "labels": schema.MapAttribute{
                                ElementType: types.StringType,
                                Optional:    true,
                                PlanModifiers: []planmodifier.Map{
                                        mapplanmodifier.UseStateForUnknown(),
                                        mapplanmodifier.RequiresReplace(),
                                },
                                Description:         "Kubernetes labels to apply to the instances. The label must have a prefix of node-role.kubernetes.io or belong to the domains node-restriction.kubernetes.io or custom.kaas.infomaniak.cloud.",
                                MarkdownDescription: "Kubernetes labels to apply to the instances. The label must have a prefix of node-role.kubernetes.io or belong to the domains node-restriction.kubernetes.io or custom.kaas.infomaniak.cloud.",
                        },
                },
                MarkdownDescription: "The kaas instance pool resource is used to manage instance pools inside a kaas project",
        }
}</span>
</pre>
		
		<pre class="file" id="file42" style="display: none">package kaas

import (
        "context"
        "errors"
        "fmt"
        "strconv"
        "strings"
        "terraform-provider-infomaniak/internal/apis"
        "terraform-provider-infomaniak/internal/apis/kaas"
        "terraform-provider-infomaniak/internal/provider"
        "time"

        "github.com/hashicorp/terraform-plugin-framework/diag"
        "github.com/hashicorp/terraform-plugin-framework/path"
        "github.com/hashicorp/terraform-plugin-framework/resource"

        "github.com/hashicorp/terraform-plugin-framework/types"
)

var (
        _ resource.Resource                = &amp;kaasResource{}
        _ resource.ResourceWithConfigure   = &amp;kaasResource{}
        _ resource.ResourceWithImportState = &amp;kaasResource{}
)

func NewKaasResource() resource.Resource <span class="cov0" title="0">{
        return &amp;kaasResource{}
}</span>

type kaasResource struct {
        client *apis.Client
}

type KaasModel struct {
        PublicCloudId        types.Int64 `tfsdk:"public_cloud_id"`
        PublicCloudProjectId types.Int64 `tfsdk:"public_cloud_project_id"`
        Id                   types.Int64 `tfsdk:"id"`

        Name              types.String    `tfsdk:"name"`
        PackName          types.String    `tfsdk:"pack_name"`
        Region            types.String    `tfsdk:"region"`
        Kubeconfig        types.String    `tfsdk:"kubeconfig"`
        KubernetesVersion types.String    `tfsdk:"kubernetes_version"`
        Apiserver         *ApiserverModel `tfsdk:"apiserver"`
}

func (m *KaasModel) SetDefaultValues(ctx context.Context) <span class="cov0" title="0">{
        if m.Apiserver == nil </span><span class="cov0" title="0">{
                defaultParams, _ := types.MapValueFrom(ctx, types.StringType, map[string]string{})
                m.Apiserver = &amp;ApiserverModel{
                        Params: defaultParams,
                }
        }</span>
        <span class="cov0" title="0">if m.Apiserver.Audit == nil </span><span class="cov0" title="0">{
                m.Apiserver.Audit = &amp;Audit{}
        }</span>
        <span class="cov0" title="0">if m.Apiserver.Oidc == nil </span><span class="cov0" title="0">{
                m.Apiserver.Oidc = &amp;OidcModel{}
        }</span>
}

type ApiserverModel struct {
        Params types.Map  `tfsdk:"params"`
        Oidc   *OidcModel `tfsdk:"oidc"`
        Audit  *Audit     `tfsdk:"audit"`
}

type OidcModel struct {
        IssuerUrl      types.String `tfsdk:"issuer_url"`
        ClientId       types.String `tfsdk:"client_id"`
        UsernameClaim  types.String `tfsdk:"username_claim"`
        UsernamePrefix types.String `tfsdk:"username_prefix"`
        SigningAlgs    types.String `tfsdk:"signing_algs"`
        GroupsClaim    types.String `tfsdk:"groups_claim"`
        GroupsPrefix   types.String `tfsdk:"groups_prefix"`
        RequiredClaim  types.String `tfsdk:"required_claim"`
        Ca             types.String `tfsdk:"ca"`
}

type Audit struct {
        WebhookConfig types.String `tfsdk:"webhook_config"`
        Policy        types.String `tfsdk:"policy"`
}

func (r *kaasResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) <span class="cov0" title="0">{
        resp.TypeName = req.ProviderTypeName + "_kaas"
}</span>

// Configure adds the provider configured client to the data source.
func (r *kaasResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) <span class="cov0" title="0">{
        // Add a nil check when handling ProviderData because Terraform
        // sets that data after it calls the ConfigureProvider RPC.
        if req.ProviderData == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">client, err := provider.GetApiClient(req.ProviderData)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unexpected Resource Configure Type",
                        err.Error(),
                )
                return
        }</span>

        <span class="cov0" title="0">r.client = client</span>
}

func (r *kaasResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) <span class="cov0" title="0">{
        resp.Schema = getKaasResourceSchema()
}</span>

func (r *kaasResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) <span class="cov0" title="0">{
        var data KaasModel

        // Read Terraform plan data into the model
        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">chosenPack, err := r.getPackId(data, &amp;resp.Diagnostics)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">input := &amp;kaas.Kaas{
                Project: kaas.KaasProject{
                        PublicCloudId: data.PublicCloudId.ValueInt64(),
                        ProjectId:     data.PublicCloudProjectId.ValueInt64(),
                },
                Region:            data.Region.ValueString(),
                KubernetesVersion: data.KubernetesVersion.ValueString(),
                Name:              data.Name.ValueString(),
                PackId:            chosenPack.Id,
        }

        // CreateKaas API call logic
        kaasId, err := r.client.Kaas.CreateKaas(input)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error when creating KaaS",
                        err.Error(),
                )
                return
        }</span>

        <span class="cov0" title="0">data.Id = types.Int64Value(kaasId)
        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)

        kaasObject, err := r.waitUntilActive(ctx, input, kaasId)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error when waiting for KaaS to be Active",
                        err.Error(),
                )
                return
        }</span>

        <span class="cov0" title="0">if kaasObject == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">err = r.fetchAndSetKubeconfig(&amp;data, kaasObject)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddWarning("could not fetch and set kubeconfig", err.Error())
        }</span>

        <span class="cov0" title="0">data.fill(kaasObject)

        resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)

        if data.Apiserver != nil </span><span class="cov0" title="0">{
                apiserverParamsInput := r.buildApiserverParamsInput(data)
                created, err := r.client.Kaas.PatchApiserverParams(apiserverParamsInput, input.Project.PublicCloudId, input.Project.ProjectId, kaasId)
                if !created || err != nil </span><span class="cov0" title="0">{
                        resp.Diagnostics.AddError(
                                "Error when creating Oidc",
                                err.Error(),
                        )
                        return
                }</span>

                <span class="cov0" title="0">data.fillApiserverState(ctx, apiserverParamsInput)</span>
        }

        // Save data into Terraform state
        <span class="cov0" title="0">resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (state *KaasModel) fillApiserverState(ctx context.Context, apiserverParams *kaas.Apiserver) <span class="cov0" title="0">{
        if state.shouldUpdateApiserver() </span><span class="cov0" title="0">{
                state.SetDefaultValues(ctx)
                state.updateAuditConfig(apiserverParams)
                state.updateOIDCConfig(apiserverParams)
                if state.canSetApiserverToNil() </span><span class="cov0" title="0">{
                        state.Apiserver = nil
                }</span>
        }
}

func (state *KaasModel) shouldUpdateApiserver() bool <span class="cov0" title="0">{
        apiserver := state.Apiserver
        return apiserver != nil &amp;&amp; (apiserver.Audit != nil || apiserver.Oidc != nil || !apiserver.Params.IsNull())
}</span>

func (state *KaasModel) updateAuditConfig(apiserverParams *kaas.Apiserver) <span class="cov0" title="0">{
        if apiserverParams.AuditLogPolicy == nil &amp;&amp; apiserverParams.AuditLogWebhook == nil </span><span class="cov0" title="0">{
                state.Apiserver.Audit = nil
        }</span> else<span class="cov0" title="0"> {
                state.Apiserver.Audit.Policy = types.StringPointerValue(apiserverParams.AuditLogPolicy)
                state.Apiserver.Audit.WebhookConfig = types.StringPointerValue(apiserverParams.AuditLogWebhook)
        }</span>
}

func (state *KaasModel) updateOIDCConfig(apiserverParams *kaas.Apiserver) <span class="cov0" title="0">{
        if apiserverParams.Params != nil </span><span class="cov0" title="0">{
                params := apiserverParams.Params
                state.Apiserver.Oidc = &amp;OidcModel{
                        ClientId:       types.StringPointerValue(params.ClientId),
                        IssuerUrl:      types.StringPointerValue(params.IssuerUrl),
                        UsernameClaim:  types.StringPointerValue(params.UsernameClaim),
                        UsernamePrefix: types.StringPointerValue(params.UsernamePrefix),
                        SigningAlgs:    types.StringPointerValue(params.SigningAlgs),
                        GroupsClaim:    types.StringPointerValue(params.GroupsClaim),
                        GroupsPrefix:   types.StringPointerValue(params.GroupsPrefix),
                        RequiredClaim:  types.StringPointerValue(params.RequiredClaim),
                        Ca:             types.StringPointerValue(apiserverParams.OidcCa),
                }
        }</span> else<span class="cov0" title="0"> {
                state.Apiserver.Oidc = nil
                state.Apiserver.Params = types.MapNull(types.StringType)
        }</span>
}

func (state *KaasModel) canSetApiserverToNil() bool <span class="cov0" title="0">{
        apiserver := state.Apiserver
        return apiserver.Audit == nil &amp;&amp; apiserver.Oidc == nil &amp;&amp; apiserver.Params.IsNull()
}</span>

func (r *kaasResource) waitUntilActive(ctx context.Context, kaas *kaas.Kaas, id int64) (*kaas.Kaas, error) <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                found, err := r.client.Kaas.GetKaas(kaas.Project.PublicCloudId, kaas.Project.ProjectId, id)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">if ctx.Err() != nil </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>

                <span class="cov0" title="0">if found.Status == "Active" </span><span class="cov0" title="0">{
                        return found, nil
                }</span>

                <span class="cov0" title="0">time.Sleep(5 * time.Second)</span>
        }
}

func (r *kaasResource) getApiserverParamsValues(data KaasModel) map[string]string <span class="cov0" title="0">{
        params := make(map[string]string)
        if !data.Apiserver.Params.IsNull() &amp;&amp; !data.Apiserver.Params.IsUnknown() </span><span class="cov0" title="0">{
                for key, val := range data.Apiserver.Params.Elements() </span><span class="cov0" title="0">{
                        if strVal, ok := val.(types.String); ok &amp;&amp; !strVal.IsNull() &amp;&amp; !strVal.IsUnknown() </span><span class="cov0" title="0">{
                                params[key] = strVal.ValueString()
                        }</span>
                }
        }

        <span class="cov0" title="0">return params</span>
}

func (r *kaasResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) <span class="cov0" title="0">{
        var state KaasModel

        // Read Terraform plan data into the model
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;state)...)

        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // Read API call logic
        <span class="cov0" title="0">kaasObject, err := r.client.Kaas.GetKaas(
                state.PublicCloudId.ValueInt64(),
                state.PublicCloudProjectId.ValueInt64(),
                state.Id.ValueInt64(),
        )
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error when reading KaaS",
                        err.Error(),
                )
                return
        }</span>

        <span class="cov0" title="0">state.fill(kaasObject)

        err = r.fetchAndSetKubeconfig(&amp;state, kaasObject)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddWarning("could not fetch and set kubeconfig", err.Error())
        }</span>

        <span class="cov0" title="0">apiserverParams, err := r.client.Kaas.GetApiserverParams(state.PublicCloudId.ValueInt64(), state.PublicCloudProjectId.ValueInt64(), kaasObject.Id)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddWarning(
                        "Could not get Oidc",
                        err.Error(),
                )
        }</span>

        <span class="cov0" title="0">if apiserverParams != nil </span><span class="cov0" title="0">{
                state.fillApiserverState(ctx, apiserverParams)
        }</span>

        // Save updated data into Terraform state
        <span class="cov0" title="0">resp.Diagnostics.Append(resp.State.Set(ctx, &amp;state)...)</span>
}

func (r *kaasResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) <span class="cov0" title="0">{
        var state KaasModel
        var data KaasModel

        resp.Diagnostics.Append(req.Plan.Get(ctx, &amp;data)...)
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;state)...)

        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">chosenPackState, err := r.getPackId(state, &amp;resp.Diagnostics)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">input := r.prepareUpdateInput(state, data, chosenPackState.Id)

        if _, err := r.client.Kaas.UpdateKaas(input); err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError("Error when updating KaaS", err.Error())
                return
        }</span>

        <span class="cov0" title="0">kaasObject, err := r.waitUntilActive(ctx, input, input.Id)
        if err != nil || kaasObject == nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError("Error waiting for KaaS activation", err.Error())
                return
        }</span>

        <span class="cov0" title="0">err = r.fetchAndSetKubeconfig(&amp;data, kaasObject)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddWarning("could not fetch and set kubeconfig", err.Error())
        }</span>

        <span class="cov0" title="0">data.fill(kaasObject)

        if data.Apiserver != nil </span><span class="cov0" title="0">{
                r.handleApiserverConfig(ctx, &amp;data, input, resp)
        }</span>

        <span class="cov0" title="0">resp.Diagnostics.Append(resp.State.Set(ctx, &amp;data)...)</span>
}

func (r *kaasResource) prepareUpdateInput(state, data KaasModel, packID int64) *kaas.Kaas <span class="cov0" title="0">{
        input := &amp;kaas.Kaas{
                Project: kaas.KaasProject{
                        PublicCloudId: data.PublicCloudId.ValueInt64(),
                        ProjectId:     data.PublicCloudProjectId.ValueInt64(),
                },
                Id:                state.Id.ValueInt64(),
                Name:              data.Name.ValueString(),
                PackId:            packID,
                Region:            state.Region.ValueString(),
                KubernetesVersion: data.KubernetesVersion.ValueString(),
        }

        if state.KubernetesVersion.ValueString() == data.KubernetesVersion.ValueString() </span><span class="cov0" title="0">{
                input.KubernetesVersion = ""
        }</span>

        <span class="cov0" title="0">return input</span>
}

func (r *kaasResource) fetchAndSetKubeconfig(data *KaasModel, input *kaas.Kaas) error <span class="cov0" title="0">{
        kubeconfig, err := r.client.Kaas.GetKubeconfig(
                input.Project.PublicCloudId,
                input.Project.ProjectId,
                input.Id,
        )
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("could not get kubeconfig: %w", err)
        }</span>
        <span class="cov0" title="0">data.Kubeconfig = types.StringValue(kubeconfig)
        return nil</span>
}

func (r *kaasResource) handleApiserverConfig(ctx context.Context, data *KaasModel, input *kaas.Kaas, resp *resource.UpdateResponse) <span class="cov0" title="0">{
        apiserverParamsInput := r.buildApiserverParamsInput(*data)
        patched, err := r.client.Kaas.PatchApiserverParams(apiserverParamsInput, input.Project.PublicCloudId, input.Project.ProjectId, input.Id)
        if !patched || err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError("Error when patching Apiserver params", err.Error())
                return
        }</span>
        <span class="cov0" title="0">data.fillApiserverState(ctx, apiserverParamsInput)</span>
}

func (r *kaasResource) buildApiserverParamsInput(data KaasModel) *kaas.Apiserver <span class="cov0" title="0">{
        apiserverParamsInput := &amp;kaas.Apiserver{
                NonSpecificApiServerParams: r.getApiserverParamsValues(data),
        }
        if data.Apiserver.Audit != nil </span><span class="cov0" title="0">{
                apiserverParamsInput.AuditLogPolicy = data.Apiserver.Audit.Policy.ValueStringPointer()
                apiserverParamsInput.AuditLogWebhook = data.Apiserver.Audit.WebhookConfig.ValueStringPointer()
        }</span>
        <span class="cov0" title="0">if data.Apiserver.Oidc != nil </span><span class="cov0" title="0">{
                apiserverParamsInput.OidcCa = data.Apiserver.Oidc.Ca.ValueStringPointer()
                apiserverParamsInput.Params = &amp;kaas.ApiServerParams{
                        IssuerUrl:      data.Apiserver.Oidc.IssuerUrl.ValueStringPointer(),
                        ClientId:       data.Apiserver.Oidc.ClientId.ValueStringPointer(),
                        UsernameClaim:  data.Apiserver.Oidc.UsernameClaim.ValueStringPointer(),
                        UsernamePrefix: data.Apiserver.Oidc.UsernamePrefix.ValueStringPointer(),
                        SigningAlgs:    data.Apiserver.Oidc.SigningAlgs.ValueStringPointer(),
                        GroupsClaim:    data.Apiserver.Oidc.GroupsClaim.ValueStringPointer(),
                        GroupsPrefix:   data.Apiserver.Oidc.GroupsPrefix.ValueStringPointer(),
                        RequiredClaim:  data.Apiserver.Oidc.RequiredClaim.ValueStringPointer(),
                }
        }</span>
        <span class="cov0" title="0">return apiserverParamsInput</span>
}

func (r *kaasResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) <span class="cov0" title="0">{
        var data KaasModel

        // Read Terraform prior state data into the model
        resp.Diagnostics.Append(req.State.Get(ctx, &amp;data)...)

        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // DeleteKaas API call logic
        <span class="cov0" title="0">_, err := r.client.Kaas.DeleteKaas(
                data.PublicCloudId.ValueInt64(),
                data.PublicCloudProjectId.ValueInt64(),
                data.Id.ValueInt64(),
        )
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error when deleting KaaS",
                        err.Error(),
                )
                return
        }</span>
}

func (r *kaasResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) <span class="cov0" title="0">{
        idParts := strings.Split(req.ID, ",")

        if len(idParts) != 3 || idParts[0] == "" || idParts[1] == "" || idParts[2] == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unexpected Import Identifier",
                        fmt.Sprintf("Expected import identifier with format: public_cloud_id,public_cloud_project_id,id. Got: %q", req.ID),
                )
                return
        }</span>

        <span class="cov0" title="0">var errorList error

        publicCloudId, err := strconv.ParseInt(idParts[0], 10, 64)
        errorList = errors.Join(errorList, err)
        publicCloudProjectId, err := strconv.ParseInt(idParts[1], 10, 64)
        errorList = errors.Join(errorList, err)
        kaasId, err := strconv.ParseInt(idParts[2], 10, 64)
        errorList = errors.Join(errorList, err)

        if errorList != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unexpected Import Identifier",
                        fmt.Sprintf("Expected import identifier with format: public_cloud_id,public_cloud_project_id,id. Got: %q", req.ID),
                )
                return
        }</span>

        <span class="cov0" title="0">resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("public_cloud_id"), publicCloudId)...)
        resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("public_cloud_project_id"), publicCloudProjectId)...)
        resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("id"), kaasId)...)</span>
}

func (r *kaasResource) getPackId(data KaasModel, diagnostic *diag.Diagnostics) (*kaas.KaasPack, error) <span class="cov0" title="0">{
        packs, err := r.client.Kaas.GetPacks()
        if err != nil </span><span class="cov0" title="0">{
                diagnostic.AddError(
                        "Could not get KaaS Packs",
                        err.Error(),
                )
                return nil, err
        }</span>

        <span class="cov0" title="0">var chosenPack *kaas.KaasPack
        for _, pack := range packs </span><span class="cov0" title="0">{
                if pack.Name == data.PackName.ValueString() </span><span class="cov0" title="0">{
                        chosenPack = pack
                        break</span>
                }
        }

        <span class="cov0" title="0">if chosenPack == nil </span><span class="cov0" title="0">{
                var packNames []string
                for _, pack := range packs </span><span class="cov0" title="0">{
                        packNames = append(packNames, pack.Name)
                }</span>

                <span class="cov0" title="0">diagnostic.AddError(
                        "Unknown KaaS Pack",
                        fmt.Sprintf("pack_name must be one of : %v", packNames),
                )
                return nil, fmt.Errorf("pack name has not been found")</span>
        }

        <span class="cov0" title="0">return chosenPack, nil</span>
}

func (model *KaasModel) fill(kaas *kaas.Kaas) <span class="cov0" title="0">{
        model.Id = types.Int64Value(kaas.Id)
        model.Region = types.StringValue(kaas.Region)
        model.KubernetesVersion = types.StringValue(kaas.KubernetesVersion)
        model.Name = types.StringValue(kaas.Name)
        model.PackName = types.StringValue(kaas.Pack.Name)
}</span>
</pre>
		
		<pre class="file" id="file43" style="display: none">package kaas

import (
        "github.com/hashicorp/terraform-plugin-framework/resource/schema"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/int64planmodifier"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/mapplanmodifier"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/objectplanmodifier"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"

        "github.com/hashicorp/terraform-plugin-framework/types"
)

func getKaasResourceSchema() schema.Schema <span class="cov0" title="0">{
        return schema.Schema{
                Attributes: map[string]schema.Attribute{
                        "public_cloud_id": schema.Int64Attribute{
                                Required:            true,
                                Description:         "The id of the public cloud where KaaS is installed",
                                MarkdownDescription: "The id of the public cloud where KaaS is installed",
                                PlanModifiers: []planmodifier.Int64{
                                        int64planmodifier.RequiresReplace(),
                                },
                        },
                        "public_cloud_project_id": schema.Int64Attribute{
                                Required:            true,
                                Description:         "The id of the public cloud project where KaaS is installed",
                                MarkdownDescription: "The id of the public cloud project where KaaS is installed",
                                PlanModifiers: []planmodifier.Int64{
                                        int64planmodifier.RequiresReplace(),
                                },
                        },
                        "pack_name": schema.StringAttribute{
                                Required:            true,
                                Description:         "The name of the pack associated to the KaaS project",
                                MarkdownDescription: "The name of the pack associated to the KaaS project",
                                PlanModifiers: []planmodifier.String{
                                        stringplanmodifier.RequiresReplace(),
                                },
                        },
                        "kubernetes_version": schema.StringAttribute{
                                Required:            true,
                                Description:         "The version of Kubernetes associated with the KaaS being installed",
                                MarkdownDescription: "The version of Kubernetes associated with the KaaS being installed",
                                PlanModifiers: []planmodifier.String{
                                        stringplanmodifier.UseStateForUnknown(),
                                },
                        },
                        "name": schema.StringAttribute{
                                Required:            true,
                                Description:         "The name of the KaaS project",
                                MarkdownDescription: "The name of the KaaS project",
                                PlanModifiers: []planmodifier.String{
                                        stringplanmodifier.UseStateForUnknown(),
                                },
                        },
                        "id": schema.Int64Attribute{
                                Computed:            true,
                                Description:         "A computed value representing the unique identifier for the architecture. Mandatory for acceptance testing.",
                                MarkdownDescription: "A computed value representing the unique identifier for the architecture. Mandatory for acceptance testing.",
                                PlanModifiers: []planmodifier.Int64{
                                        int64planmodifier.UseStateForUnknown(),
                                },
                        },
                        "region": schema.StringAttribute{
                                Required:            true,
                                Description:         "The region where the KaaS will reside.",
                                MarkdownDescription: "The region where the KaaS will reside.",
                                PlanModifiers: []planmodifier.String{
                                        stringplanmodifier.RequiresReplace(),
                                        stringplanmodifier.UseStateForUnknown(),
                                },
                        },
                        "kubeconfig": schema.StringAttribute{
                                Computed:            true,
                                Sensitive:           true,
                                Description:         "The kubeconfig generated to access to KaaS project",
                                MarkdownDescription: "The kubeconfig generated to access to KaaS project",
                        },
                        "apiserver": schema.SingleNestedAttribute{
                                MarkdownDescription: "Kubernetes Apiserver editable params",
                                Attributes: map[string]schema.Attribute{
                                        "params": schema.MapAttribute{
                                                Optional:            true,
                                                ElementType:         types.StringType,
                                                MarkdownDescription: "Map of Kubernetes Apiserver params in case the terraform provider does not already abstracts them",
                                                PlanModifiers: []planmodifier.Map{
                                                        mapplanmodifier.UseStateForUnknown(),
                                                },
                                        },
                                        "audit": schema.SingleNestedAttribute{
                                                MarkdownDescription: "Kubernetes audit logs specification files",
                                                Optional:            true,
                                                PlanModifiers: []planmodifier.Object{
                                                        objectplanmodifier.UseStateForUnknown(),
                                                },
                                                Attributes: map[string]schema.Attribute{
                                                        "webhook_config": schema.StringAttribute{
                                                                MarkdownDescription: "YAML manifest for audit webhook config",
                                                                Optional:            true,
                                                                PlanModifiers: []planmodifier.String{
                                                                        stringplanmodifier.UseStateForUnknown(),
                                                                },
                                                        },
                                                        "policy": schema.StringAttribute{
                                                                MarkdownDescription: "YAML manifest for audit policy",
                                                                Optional:            true,
                                                                PlanModifiers: []planmodifier.String{
                                                                        stringplanmodifier.UseStateForUnknown(),
                                                                },
                                                        },
                                                },
                                        },
                                        "oidc": schema.SingleNestedAttribute{
                                                MarkdownDescription: "OIDC specific Apiserver params",
                                                Optional:            true,
                                                Attributes: map[string]schema.Attribute{
                                                        "ca": schema.StringAttribute{
                                                                Optional: true,
                                                                PlanModifiers: []planmodifier.String{
                                                                        stringplanmodifier.UseStateForUnknown(),
                                                                },
                                                                MarkdownDescription: "OIDC Ca Certificate",
                                                        },
                                                        "groups_claim": schema.StringAttribute{
                                                                Optional: true,
                                                                PlanModifiers: []planmodifier.String{
                                                                        stringplanmodifier.UseStateForUnknown(),
                                                                },
                                                                MarkdownDescription: "OIDC groups claim",
                                                        },
                                                        "groups_prefix": schema.StringAttribute{
                                                                Optional: true,
                                                                PlanModifiers: []planmodifier.String{
                                                                        stringplanmodifier.UseStateForUnknown(),
                                                                },
                                                                MarkdownDescription: "OIDC groups prefix",
                                                        },
                                                        "issuer_url": schema.StringAttribute{
                                                                Optional: true,
                                                                PlanModifiers: []planmodifier.String{
                                                                        stringplanmodifier.UseStateForUnknown(),
                                                                },
                                                                MarkdownDescription: "OIDC issuer URL",
                                                        },
                                                        "client_id": schema.StringAttribute{
                                                                Optional: true,
                                                                PlanModifiers: []planmodifier.String{
                                                                        stringplanmodifier.UseStateForUnknown(),
                                                                },
                                                                MarkdownDescription: "OIDC client identifier",
                                                        },
                                                        "username_claim": schema.StringAttribute{
                                                                Optional: true,
                                                                PlanModifiers: []planmodifier.String{
                                                                        stringplanmodifier.UseStateForUnknown(),
                                                                },
                                                                MarkdownDescription: "OIDC username claim",
                                                        },
                                                        "username_prefix": schema.StringAttribute{
                                                                Optional: true,
                                                                PlanModifiers: []planmodifier.String{
                                                                        stringplanmodifier.UseStateForUnknown(),
                                                                },
                                                                MarkdownDescription: "OIDC username prefix",
                                                        },
                                                        "required_claim": schema.StringAttribute{
                                                                Optional: true,
                                                                PlanModifiers: []planmodifier.String{
                                                                        stringplanmodifier.UseStateForUnknown(),
                                                                },
                                                                MarkdownDescription: "A key=value pair that describes a required claim in the ID Token. If set, the claim is verified to be present in the ID Token with a matching value. Repeat this flag to specify multiple claims.",
                                                        },
                                                        "signing_algs": schema.StringAttribute{
                                                                Optional: true,
                                                                PlanModifiers: []planmodifier.String{
                                                                        stringplanmodifier.UseStateForUnknown(),
                                                                },
                                                                MarkdownDescription: "OIDC signing algorithm. Kubernetes will default it to RS256",
                                                        },
                                                },
                                        },
                                },
                                Optional: true,
                        },
                },
                MarkdownDescription: "The kaas resource allows the user to manage a kaas project",
        }
}</span>
</pre>
		
		<pre class="file" id="file44" style="display: none">package kaas

import "terraform-provider-infomaniak/internal/provider/registry"

func Register() <span class="cov8" title="1">{
        registry.RegisterResource(NewKaasResource)
        registry.RegisterResource(NewKaasInstancePoolResource)

        registry.RegisterDataSource(NewKaasDataSource)
        registry.RegisterDataSource(NewKaasInstancePoolDataSource)
}</span>
</pre>
		
		<pre class="file" id="file45" style="display: none">package test

import (
        "fmt"
        "os"
        "path"

        "github.com/hashicorp/terraform-plugin-testing/terraform"
)

func MustGetTestFile(subgroup, file string) string <span class="cov0" title="0">{
        body, err := os.ReadFile(path.Join("tests", subgroup, file))
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov0" title="0">return string(body)</span>
}

func TestCheckGetFromState(name string, key string, out *string) func(s *terraform.State) error <span class="cov0" title="0">{
        return func(s *terraform.State) error </span><span class="cov0" title="0">{
                ms := s.RootModule()

                rs, ok := ms.Resources[name]
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("Not found: %s in %s", name, ms.Path)
                }</span>

                <span class="cov0" title="0">is := rs.Primary
                if is == nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("No primary instance: %s in %s", name, ms.Path)
                }</span>

                <span class="cov0" title="0">val, ok := is.Attributes[key]

                if ok &amp;&amp; val != "" </span><span class="cov0" title="0">{
                        *out = val
                        return nil
                }</span>

                <span class="cov0" title="0">if _, ok := is.Attributes[key+".#"]; ok </span><span class="cov0" title="0">{
                        return fmt.Errorf(
                                "%s: list or set attribute '%s' must be checked by element count key (%s) or element value keys (e.g. %s). Set element value checks should use TestCheckTypeSet functions instead.",
                                name,
                                key,
                                key+".#",
                                key+".0",
                        )
                }</span>

                <span class="cov0" title="0">if _, ok := is.Attributes[key+".%"]; ok </span><span class="cov0" title="0">{
                        return fmt.Errorf(
                                "%s: map attribute '%s' must be checked by element count key (%s) or element value keys (e.g. %s).",
                                name,
                                key,
                                key+".%",
                                key+".examplekey",
                        )
                }</span>

                <span class="cov0" title="0">return fmt.Errorf("%s: Attribute '%s' expected to be set", name, key)</span>
        }
}
</pre>
		
		<pre class="file" id="file46" style="display: none">package utils

import (
        "context"
        "encoding/json"
        "fmt"
        "terraform-provider-infomaniak/internal/dynamic"

        "github.com/hashicorp/terraform-plugin-framework/attr"
        "github.com/hashicorp/terraform-plugin-framework/diag"
        "github.com/hashicorp/terraform-plugin-framework/types"
        "github.com/hashicorp/terraform-plugin-framework/types/basetypes"
)

// ObjectStateManager will keep the state of stateEffective up to date with newEffective.
// It will also keep userDefined up to date (prevents changes when API set default values)
func ObjectStateManager(ctx context.Context, newEffective types.Dynamic, stateEffective types.Dynamic, userDefined types.Dynamic) (types.Dynamic, types.Dynamic, diag.Diagnostics) <span class="cov8" title="1">{
        var diags diag.Diagnostics

        incomingFromApi, d := ConvertDynamicObjectToTerraformMap(newEffective)
        diags.Append(d...)

        incomingFromState, d := ConvertDynamicObjectToTerraformMap(stateEffective)
        diags.Append(d...)

        local, d := ConvertDynamicObjectToTerraformMap(userDefined)
        diags.Append(d...)

        for incomingEffectiveKey, incomingEffectiveValue := range incomingFromApi </span><span class="cov8" title="1">{
                _, localManagerUseKey := local[incomingEffectiveKey]
                if localManagerUseKey </span><span class="cov8" title="1">{
                        local[incomingEffectiveKey] = incomingEffectiveValue
                }</span>
        }

        <span class="cov8" title="1">for incomingEffectiveKey, incomingEffectiveValue := range incomingFromApi </span><span class="cov8" title="1">{
                stateEffectiveValue, stateEffectiveUseKey := incomingFromState[incomingEffectiveKey]
                if stateEffectiveUseKey </span><span class="cov8" title="1">{
                        // The user changed the value from an other source than terraform
                        stateEffectiveTfValue, err := stateEffectiveValue.ToTerraformValue(ctx)
                        if err != nil </span><span class="cov0" title="0">{
                                diags.AddError("could not get terraform value", "could not get a state effective value")
                        }</span>
                        <span class="cov8" title="1">incomingEffectiveTfValue, err := incomingEffectiveValue.ToTerraformValue(ctx)
                        if err != nil </span><span class="cov0" title="0">{
                                diags.AddError("could not get terraform value", "could not get an incoming from api effective value")
                        }</span>
                        <span class="cov8" title="1">if !stateEffectiveTfValue.Equal(incomingEffectiveTfValue) </span><span class="cov8" title="1">{
                                local[incomingEffectiveKey] = incomingEffectiveValue
                        }</span>
                }
                <span class="cov8" title="1">incomingFromState[incomingEffectiveKey] = incomingEffectiveValue</span>
        }

        <span class="cov8" title="1">localMap, d := ConvertMapToDynamicObject(ctx, local)
        diags.Append(d...)

        effectiveMap, d := ConvertMapToDynamicObject(ctx, incomingFromState)
        diags.Append(d...)

        return effectiveMap, localMap, diags</span>
}

// ConvertDynamicObjectToTerraformMap will transform a Dynamic terraform object into a map of terraform values
func ConvertDynamicObjectToTerraformMap(dyn types.Dynamic) (map[string]attr.Value, diag.Diagnostics) <span class="cov8" title="1">{
        var diags diag.Diagnostics

        if dyn.IsNull() || dyn.IsUnknown() </span><span class="cov8" title="1">{
                return make(map[string]attr.Value), diags
        }</span>

        <span class="cov8" title="1">objVal, ok := dyn.UnderlyingValue().(basetypes.ObjectValue)
        if !ok </span><span class="cov0" title="0">{
                diags.AddError(
                        "Invalid type",
                        fmt.Sprintf("dynamic should be an object, got %T", dyn.UnderlyingValue()),
                )
                return nil, diags
        }</span>
        <span class="cov8" title="1">elems := objVal.Attributes()
        return elems, diags</span>
}

// ConvertDynamicObjectToMapAny will transform a Dynamic terraform object into a map of any go values
func ConvertDynamicObjectToMapAny(dyn types.Dynamic) (map[string]any, diag.Diagnostics) <span class="cov0" title="0">{
        var diags diag.Diagnostics

        converted := make(map[string]any)

        if dyn.IsNull() || dyn.IsUnknown() </span><span class="cov0" title="0">{
                return converted, diags
        }</span>

        <span class="cov0" title="0">body, err := dynamic.ToJSON(dyn)
        if err != nil </span><span class="cov0" title="0">{
                diags.AddError("json error", fmt.Sprintf("could not convert dynamic to json: %v", err))
        }</span>

        <span class="cov0" title="0">err = json.Unmarshal(body, &amp;converted)
        if err != nil </span><span class="cov0" title="0">{
                diags.AddError("json error", fmt.Sprintf("could not unmarshall json: %v", err))
        }</span>

        <span class="cov0" title="0">return converted, diags</span>
}

// ConvertMapToDynamicObject will transform a map of terraform values into a terraform dynamic object
func ConvertMapToDynamicObject(ctx context.Context, toconvert map[string]attr.Value) (types.Dynamic, diag.Diagnostics) <span class="cov8" title="1">{
        var diags diag.Diagnostics

        if len(toconvert) == 0 </span><span class="cov8" title="1">{
                return types.DynamicNull(), diags
        }</span>

        <span class="cov8" title="1">typesMap := make(map[string]attr.Type)
        valuesMap := make(map[string]attr.Value)

        for k, v := range toconvert </span><span class="cov8" title="1">{
                typesMap[k] = v.Type(ctx)
                valuesMap[k] = v
        }</span>

        <span class="cov8" title="1">obj, d := types.ObjectValue(typesMap, valuesMap)

        diags.Append(d...)
        dyn := types.DynamicValue(obj)

        return dyn, diags</span>
}

// ConvertIntsToStrings will transform comparable types
// E.g: 100 = "100"
func ConvertIntsToStrings(input map[string]any) map[string]any <span class="cov0" title="0">{
        output := make(map[string]any)
        for key, value := range input </span><span class="cov0" title="0">{
                switch typedValue := value.(type) </span>{
                case uint, uint8, uint16, uint32, uint64, int, int8, int16, int32, int64, float32, float64:<span class="cov0" title="0">
                        output[key] = fmt.Sprint(typedValue)</span>
                case map[string]any:<span class="cov0" title="0">
                        newOutput := make(map[string]any)
                        ConvertIntsToStrings(typedValue)
                        output[key] = newOutput</span>
                default:<span class="cov0" title="0">
                        output[key] = typedValue</span>
                }
        }
        <span class="cov0" title="0">return output</span>
}
</pre>
		
		<pre class="file" id="file47" style="display: none">package main

import (
        "context"
        "flag"
        "log"
        "terraform-provider-infomaniak/internal/provider"
        "terraform-provider-infomaniak/internal/services/dbaas"
        "terraform-provider-infomaniak/internal/services/domain"
        "terraform-provider-infomaniak/internal/services/kaas"

        "github.com/hashicorp/terraform-plugin-framework/providerserver"
)

var (
        // these will be set by the goreleaser configuration
        // to appropriate values for the compiled binary.
        version string = "dev"

        // goreleaser can pass other information to the main package, such as the specific commit
        // https://goreleaser.com/cookbooks/using-main.version/
)

func main() <span class="cov0" title="0">{
        var debug bool

        flag.BoolVar(&amp;debug, "debug", false, "set to true to run the kaas with support for debuggers like delve")
        flag.Parse()

        opts := providerserver.ServeOpts{
                Address: "registry.terraform.io/Infomaniak/infomaniak",
                Debug:   debug,
        }

        // Register resources
        kaas.Register()
        domain.Register()
        dbaas.Register()

        err := providerserver.Serve(context.Background(), provider.New(version), opts)

        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err.Error())
        }</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
